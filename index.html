<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Massachusetts Building Analysis Dashboard - NSI-Enhanced USA Structures Dataset</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --dark-gradient: linear-gradient(135deg, #30cfd0 0%, #330867 100%);
            --soil-gradient: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
        }
        
        /* Modern Theme (Default) */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--primary-gradient);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            transition: all 0.3s ease;
        }
        
        /* Professional Theme */
        body.professional-theme {
            background: #f5f5f5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: slideIn 0.6s ease;
            transition: all 0.3s ease;
        }
        
        .professional-theme .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            animation: none;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .header {
            background: var(--primary-gradient);
            color: white;
            padding: 50px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .professional-theme .header {
            background: #2c3e50;
            padding: 30px 40px;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }
        
        .professional-theme .header::before {
            display: none;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.3; }
        }
        
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 1;
        }
        
        .professional-theme .header h1 {
            font-size: 2.2em;
            text-shadow: none;
            font-weight: 400;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }
        
        .professional-theme .header p {
            font-size: 1em;
            opacity: 0.9;
        }
        
        .dataset-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            margin-top: 10px;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
        }
        
        .professional-theme .dataset-badge {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            backdrop-filter: none;
        }
        
        .nav-container {
            background: white;
            padding: 25px 20px;
            border-bottom: 2px solid #f0f0f0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .professional-theme .nav-container {
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
            box-shadow: none;
        }
        
        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }
        
        .nav-tab {
            padding: 14px 28px;
            background: #f5f5f5;
            border: 2px solid transparent;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 15px;
            font-weight: 600;
            color: #555;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .nav-tab {
            padding: 10px 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--primary-gradient);
            transition: left 0.3s ease;
            z-index: -1;
        }
        
        .professional-theme .nav-tab::before {
            display: none;
        }
        
        .nav-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .nav-tab:hover {
            transform: none;
            background: #f8f9fa;
            box-shadow: none;
        }
        
        .nav-tab:hover::before {
            left: 0;
        }
        
        .nav-tab:hover {
            color: white;
        }
        
        .professional-theme .nav-tab:hover {
            color: #333;
        }
        
        .nav-tab.active {
            background: var(--primary-gradient);
            color: white;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .professional-theme .nav-tab.active {
            background: #2c3e50;
            color: white;
            box-shadow: none;
            border-color: #2c3e50;
        }
        
        /* Special style for Soil Analysis tab */
        .nav-tab.soil-tab.active {
            background: var(--soil-gradient);
        }
        
        .content {
            padding: 40px;
            min-height: 600px;
        }
        
        .section {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .professional-theme .section {
            animation: none;
        }
        
        .section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .section-header {
            margin-bottom: 35px;
            padding-bottom: 20px;
            border-bottom: 3px solid #f0f0f0;
            position: relative;
        }
        
        .professional-theme .section-header {
            border-bottom: 2px solid #e0e0e0;
        }
        
        .section-header::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 100px;
            height: 3px;
            background: var(--primary-gradient);
        }
        
        .professional-theme .section-header::after {
            background: #2c3e50;
            height: 2px;
            bottom: -2px;
        }
        
        .section-header h2 {
            color: #333;
            font-size: 2.2em;
            margin-bottom: 12px;
        }
        
        .professional-theme .section-header h2 {
            font-size: 1.8em;
            font-weight: 500;
        }
        
        .section-header p {
            color: #666;
            font-size: 1.15em;
            line-height: 1.6;
        }
        
        .professional-theme .section-header p {
            font-size: 1em;
        }
        
        .controls {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.05);
        }
        
        .professional-theme .controls {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 20px;
            box-shadow: none;
            border: 1px solid #dee2e6;
        }
        
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            font-weight: 700;
            color: #495057;
            min-width: 120px;
        }
        
        .professional-theme .control-group label {
            font-weight: 600;
        }
        
        .control-group select,
        .control-group input {
            padding: 10px 18px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 15px;
            transition: all 0.3s ease;
            background: white;
            min-width: 150px;
        }
        
        .professional-theme .control-group select,
        .professional-theme .control-group input {
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 8px 12px;
        }
        
        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .professional-theme .control-group select:focus,
        .professional-theme .control-group input:focus {
            border-color: #2c3e50;
            box-shadow: none;
        }
        
        .control-button {
            padding: 12px 28px;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .control-button {
            background: #2c3e50;
            border-radius: 4px;
            padding: 10px 20px;
            font-weight: 600;
            box-shadow: none;
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .professional-theme .control-button:hover {
            transform: none;
            background: #34495e;
            box-shadow: none;
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        .toggle-switch {
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-switch input[type="checkbox"] {
            width: 50px;
            height: 26px;
            appearance: none;
            background: #ddd;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch input[type="checkbox"]:checked {
            background: #667eea;
        }
        
        .professional-theme .toggle-switch input[type="checkbox"]:checked {
            background: #2c3e50;
        }
        
        .toggle-switch input[type="checkbox"]::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        
        .toggle-switch input[type="checkbox"]:checked::after {
            left: 26px;
        }
        
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }
        
        .professional-theme .chart-container {
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 25px;
        }
        
        .chart-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        .professional-theme .chart-container:hover {
            transform: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 35px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            transition: all 0.3s ease;
            color: white;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .stat-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 25px;
            color: #333;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
            animation: rotate 10s linear infinite;
        }
        
        .professional-theme .stat-card::before {
            display: none;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .stat-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .stat-card:hover {
            transform: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .stat-card:nth-child(2) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .professional-theme .stat-card:nth-child(2) {
            background: white;
        }
        
        .stat-card:nth-child(3) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .professional-theme .stat-card:nth-child(3) {
            background: white;
        }
        
        .stat-card:nth-child(4) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
        
        .professional-theme .stat-card:nth-child(4) {
            background: white;
        }
        
        /* Soil-specific stat cards */
        .stat-card.soil-card {
            background: var(--soil-gradient);
        }
        
        .professional-theme .stat-card.soil-card {
            background: white;
            border-color: #8B4513;
        }
        
        .stat-value {
            font-size: 3em;
            font-weight: 800;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .professional-theme .stat-value {
            font-size: 2.5em;
            font-weight: 600;
            text-shadow: none;
            color: #2c3e50;
        }
        
        .stat-label {
            font-size: 1.1em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
            font-weight: 600;
        }
        
        .professional-theme .stat-label {
            opacity: 1;
            font-weight: 500;
            color: #6c757d;
        }
        
        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #2196f3;
            margin-bottom: 25px;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .info-box {
            background: #f0f8ff;
            border-radius: 4px;
            border-left: 4px solid #2196f3;
            padding: 20px;
        }
        
        .info-box.soil-info {
            background: linear-gradient(135deg, #f4e4c1 0%, #e8d4a1 100%);
            border-left-color: #8B4513;
        }
        
        .professional-theme .info-box.soil-info {
            background: #faf0e6;
            border-left-color: #8B4513;
        }
        
        .info-box h3 {
            color: #1565c0;
            margin-bottom: 12px;
            font-size: 1.3em;
        }
        
        .info-box.soil-info h3 {
            color: #6B4423;
        }
        
        .professional-theme .info-box h3 {
            font-size: 1.2em;
            font-weight: 600;
        }
        
        .info-box p {
            color: #0d47a1;
            line-height: 1.6;
        }
        
        .info-box.soil-info p {
            color: #5D4E37;
        }
        
        .professional-theme .info-box p {
            color: #333;
        }
        
        .warning-box {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #ff9800;
            margin: 20px 0;
        }
        
        .professional-theme .warning-box {
            background: #fff9e6;
            border-radius: 4px;
            border-left: 4px solid #ff9800;
        }
        
        .warning-box h4 {
            color: #e65100;
            margin-bottom: 10px;
        }
        
        .professional-theme .warning-box h4 {
            font-weight: 600;
        }
        
        .warning-box p {
            color: #bf360c;
            line-height: 1.5;
        }
        
        .professional-theme .warning-box p {
            color: #666;
        }
        
        .error-box {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #f44336;
            margin: 20px 0;
            display: none;
        }
        
        .professional-theme .error-box {
            background: #ffebee;
            border-radius: 4px;
            border-left: 4px solid #f44336;
        }
        
        .error-box.show {
            display: block;
            animation: shake 0.5s ease;
        }
        
        .professional-theme .error-box.show {
            animation: none;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        @keyframes fadeInBadge {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        .export-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .export-button {
            padding: 10px 20px;
            background: var(--dark-gradient);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .professional-theme .export-button {
            background: #34495e;
            border-radius: 4px;
        }
        
        .export-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .professional-theme .export-button:hover {
            transform: none;
            background: #2c3e50;
            box-shadow: none;
        }
        
        /* New styles for heatmap tabs */
        .heatmap-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: #f5f5f5;
            padding: 5px;
            border-radius: 10px;
        }
        
        .heatmap-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }
        
        .heatmap-tab.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .heatmap-tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.5);
        }
        
        /* Map container styles */
        .map-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            min-height: 600px;
        }
        
        .professional-theme .map-container {
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .nav-tabs {
                flex-direction: column;
            }
            
            .nav-tab {
                width: 100%;
                text-align: center;
            }
            
            .content {
                padding: 20px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-group label {
                min-width: auto;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

            .flowchart-container {
                display: flex;
                flex-direction: column;
                gap: 40px;
                font-family: 'Segoe UI', sans-serif;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 8px;
            }

            .flow-stage {
                background: #ffffff;
                border: 1px solid #dee2e6;
                border-radius: 8px;
                padding: 25px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            }

            .stage-title {
                text-align: center;
                font-size: 1.5em;
                color: #343a40;
                margin-bottom: 25px;
                padding-bottom: 10px;
                border-bottom: 2px solid #e9ecef;
            }

            .flow-content {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }

            .flow-inputs {
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 20px;
                width: 100%;
            }

            .flow-box {
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                width: 100%;
                max-width: 320px;
                border: 2px solid;
                box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            }

            .flow-box h4 {
                margin-bottom: 10px;
                font-size: 1.1em;
            }

            .flow-box p {
                margin: 5px 0;
                font-size: 1em;
                color: #495057;
            }

            .flow-box small {
                display: block;
                margin-top: 10px;
                font-style: italic;
                color: #6c757d;
                font-size: 0.85em;
            }

            .data-source.usa-structures { background-color: #eaf1ff; border-color: #667eea; }
            .data-source.nsi { background-color: #f1eaff; border-color: #764ba2; }
            .data-source.soil-survey { background-color: #ffeeee; border-color: #f5576c; }
            .data-source.nsi-enhanced-input { background-color: #e3f2fd; border-color: #4facfe; }

            .result {
                width: 100%;
                max-width: 500px;
            }

            .result.nsi-enhanced { background-color: #e3f2fd; border-color: #4facfe; }
            .result.final-dataset { background-color: #e8f5e9; border-color: #2E7D32; }


            .operation {
                width: 100%;
                max-width: 600px;
                text-align: left;
                background: #fffbe6;
                border: 2px dashed #f9b115;
            }

            .operation ul {
                list-style-type: none;
                padding-left: 0;
            }

            .operation ul li {
                margin-bottom: 8px;
                padding-left: 20px;
                position: relative;
            }

            .operation ul li::before {
                content: '✓';
                position: absolute;
                left: 0;
                color: #28a745;
                font-weight: bold;
            }

   
            #stage1-metrics details { 
            margin-top: 12px;      
            }
            #stage1-metrics details:first-of-type { 
            margin-top: 0;   
            }
            #stage1-metrics summary {
            font-weight: 700;        
            margin-bottom: 6px;         
            }

        
            #stage1-metrics .funnel-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            }
            @media (min-width: 700px) {
            #stage1-metrics .funnel-grid {
                grid-template-columns: 1fr 1fr;  
            }
            }
            #stage1-metrics .funnel-block em {
            display: block;       
            margin-bottom: 4px;
            font-style: italic;
            }
            #stage1-metrics .span-2 {
            grid-column: 1 / -1;        
            }


            .plus-icon {
                font-size: 2em;
                color: #6c757d;
                font-weight: bold;
            }

            .flow-arrow {
                font-size: 1.8em;
                color: #6c757d;
            }

            .stage-title {
                text-align: center;
                font-size: 1.5em;
                color: #343a40;
                margin-bottom: 25px; 
                padding-bottom: 10px;
                border-bottom: 2px solid #e9ecef;
                cursor: pointer; 
                display: flex; 
                justify-content: center; 
                align-items: center;
                position: relative; 
                padding-right: 40px; 
                transition: color 0.3s ease;
            }

            .stage-title:hover {
                color: #007bff; 
            }

            .collapse-icon {
                position: absolute;
                right: 20px;
                font-size: 0.8em; 
                transition: transform 0.3s ease;
                color: #6c757d;
            }

            .collapsible-content {
                max-height: 0; 
                overflow: hidden;
                transition: max-height 0.5s ease-out, padding 0.5s ease-out; 
                padding: 0 10px; 
            }

            .collapsible-content.active {
                max-height: 5000px; 
                padding: 15px 10px; 
            }


            .stage-title.active .collapse-icon {
                transform: rotate(180deg);
            }

            .map-container {
                background: white;
                padding: 20px;
                border-radius: 15px;
                margin-bottom: 30px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
                min-height: 650px; /* Ensure the map has enough height */
            }

            .professional-theme .map-container {
                border-radius: 4px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            }
            /* END: New Map Plot CSS */

            .data-source.boston-permits { background-color: #e0f2f1; border-color: #009688; }

            /* CHANGE: allow the Sankey labels/links to overflow outside the container if needed */
            #yearOccSankey,
            #yearOccSankey > div {
            overflow: visible !important;
            }

            /* (Optional) If your parent container clips content, unclip it too */
            .chart-container,
            .card {
            overflow: visible;
            }

  
            #stage1-metrics > details.stage-panel {
            margin-top: 0;              
            }
            #stage1-metrics > details.stage-panel > summary {
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 8px;       
            }

   
            #stage1-metrics details { 
            margin-top: 12px;            
            }
            #stage1-metrics details:first-of-type { 
            margin-top: 0;
            }
            #stage1-metrics summary { 
            font-weight: 700;
            margin-bottom: 6px;
            }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; 
            gap: 30px;
            width: 100%;
        }

        .comparison-grid .panel {
            min-width: 0; 
            width: 100%;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #dee2e6;
        }

        @media (max-width: 1200px) {
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }

        .radio-group-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 5px;
        }

        .radio-pill {
            display: inline-block;
            cursor: pointer;
        }

        .radio-pill input[type="radio"] {
            display: none; 
        }

        .radio-pill span {
            display: inline-block;
            padding: 8px 16px;
            background-color: #f0f2f5;
            border: 1px solid #d1d5db;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            color: #4b5563;
            transition: all 0.2s ease;
        }

        .radio-pill input[type="radio"]:checked + span {
        background-color: #667eea; 
            
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .radio-pill:hover span {
            background-color: #e5e7eb;
        }

        .radio-pill input[type="radio"]:checked:hover + span {
            opacity: 0.9;
        }

        .map-legend-overlay {
            position: absolute;
            bottom: 10px;       
            right: 10px;       
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 10px;  
            border-radius: 6px;  
            border: none;
            box-shadow: none; 
            z-index: 999;
            font-size: 11px;    
            pointer-events: none;
            line-height: 1.2;   
        }

        .size-legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;  
        }

        .size-legend-circle {
            background: #888;
            border-radius: 50%;
            margin-right: 6px;   
            opacity: 0.5;
            display: inline-block;
        }

    </style>
</head>
<body class="professional-theme">
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>Massachusetts Building Analysis Dashboard</h1>
            <p>Interactive Visualization of Building Inventory Data with Soil Analysis</p>
            <div class="dataset-badge">NSI-Enhanced USA Structures Dataset</div>
        </div>
        
        <div class="nav-container">
            <div class="nav-tabs">
                <button class="nav-tab active" onclick="showSection('overview')">Overview</button>
                <button class="nav-tab" onclick="showSection('dataAnalysis')">Data Pipelines</button>
                <button class="nav-tab" onclick="showSection('simpleClustering')">Simple Clustering</button>
                <button class="nav-tab" onclick="showSection('temporal')">Temporal</button>
                <button class="nav-tab" onclick="showSection('occupancyClustering')">Occupancy Clustering</button>
                <button class="nav-tab" onclick="showSection('materials')">Materials</button>
                <button class="nav-tab soil-tab" onclick="showSection('soilAnalysis')">Soil Analysis</button>
                <button class="nav-tab" onclick="showSection('historicShoreline')">Boston Historic Shoreline</button>
                <button class="nav-tab" onclick="showSection('foundationAnalysis')">Boston Foundation-Height Statistics</button>
                <button class="nav-tab" onclick="showSection('clf')">CLF Analysis</button>
                <button class="nav-tab" onclick="showSection('interactive')">Explorer</button>
            </div>
        </div>
        
        <div class="content">
            <!-- OVERVIEW SECTION -->
            <div id="overview" class="section active">
                <div class="section-header">
                    <h2>Dashboard Overview</h2>
                    <p>Comprehensive analysis of Massachusetts building inventory from NSI-Enhanced USA Structures Dataset</p>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalBuildings">Loading...</div>
                        <div class="stat-label">Total Buildings(Cleaned)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgYear">Loading...</div>
                        <div class="stat-label">Average Year Built</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgArea">Loading...</div>
                        <div class="stat-label">Avg Area (sqm)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="numClusters">Loading...</div>
                        <div class="stat-label">Identified Clusters</div>
                    </div>
                </div>
                

                <div class="info-box">
                    <h3>About This Dashboard</h3>
                    <p class="intro-paragraph">  This interactive dashboard analyzes building data from the NSI-Enhanced USA Structures Dataset for Massachusetts. The analysis includes clustering patterns, temporal distributions, material characteristics, and soil properties of buildings across different time periods. All visualizations use color-blind friendly palettes and are fully interactive.
                        Developed during the fall of 2025 by Lang Shao and supervised by Prof. Demi Fang of the <a href="https://structural-futures.org/">Structural Futures Lab</a>. Data visualizations may not be suitable for distribution at this time and should include attribution. If you have any questions, please contact us.
                    </p>
                </div>
                

                <div class="chart-container">
                    <div id="overviewChart"></div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Filter by Occupancy:</label>
                        <select id="overviewOccFilter" onchange="createOverviewMap()"></select>
                        
                        <label>Filter by Material:</label>
                        <select id="overviewMaterialFilter" onchange="createOverviewMap()"></select>
                        
                        <label>Filter by Foundation:</label>
                        <select id="overviewFoundationFilter" onchange="createOverviewMap()"></select>
                    </div>
                
                <div class="control-group">
                    <label>Color Points By:</label>
                    <select id="overviewColorBy" onchange="handleColorByChange()">
                        <option value="OCC_CLS">Occupancy Class</option>
                        <option value="material_type">Material Type</option>
                        <option value="foundation_type">Foundation Type</option>
                        <option value="Est GFA sqmeters">Total GFA (Continuous)</option>
                        <option value="cluster">Simple Cluster</option>
                    </select>

                    <span id="overviewKSelectorContainer" style="display: inline-flex; margin-left: 10px; align-items: center;">
                        <label style="min-width: auto; margin-right: 5px;">K=</label>
                        <select id="overviewKSelector" onchange="createOverviewMap()" style="min-width: 60px; padding: 8px;">
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7" selected>7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                        </select>
                    </span>

                    <span id="overviewClusterFilterContainer" style="display: inline-flex; margin-left: 10px; align-items: center;">
                        <label style="min-width: auto; margin-right: 5px;">Filter:</label>
                        <select id="overviewClusterFilter" onchange="createOverviewMap()" style="min-width: 120px; padding: 8px;">
                            <option value="All">All Clusters</option>
                        </select>
                    </span>

                    <div class="toggle-switch" style="margin-left: 20px; border-left: 2px solid #ddd; padding-left: 20px;">
                        <label>Size by GFA:</label>
                        <input type="checkbox" id="overviewSizeByGFA" onchange="createOverviewMap()">
                    </div>
                </div>
                </div>

                <div class="map-container" style="position: relative;">
                    <div id="overviewMapPlot"></div>
                    <div id="mapLegendOverlay" class="map-legend-overlay" style="display: none;"></div>
                </div>

                <div class="chart-container">
                    <div id="overviewTimelineChart"></div>
                </div>
                


                <!-- MA Building Distribution Sankey -->
                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">MA Building Hierarchical Distribution</h3>
                        <p style="color: #555;">Multi-level breakdown: Occupancy → Area → Height → Year → Drainage</p>
                    </div>
                    
                    <div class="controls" style="margin-bottom: 20px; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <div class="control-group">
                            <label style="font-weight: 600; margin-right: 10px;">Select Occupancy Class:</label>
                            <select id="hierarchicalOccupancy" onchange="createBuildingDistributionSankey()" 
                                    style="padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 14px;">
                                <option value="all">All Buildings</option>
                                <option value="Residential">Residential</option>
                                <option value="Commercial">Commercial</option>
                                <option value="Industrial">Industrial</option>
                                <option value="Agriculture">Agriculture</option>
                                <option value="Government">Government</option>
                                <option value="Assembly">Assembly</option>
                                <option value="Education">Education</option>
                                <option value="Utility and Misc">Utility and Misc</option>
                                <option value="Unclassified">Unclassified</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label style="font-weight: 600; margin-right: 10px;">Sankey Diagram View:</label>
                            <select id="sankeyViewSelector" onchange="createBuildingDistributionSankey()"
                                    style="padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 14px;">
                                <option value="by_count" selected>By Building Count</option>
                                <option value="by_gfa">By Total GFA (sqm)</option>
                                <option value="by_count_simplified">By Building Count (Simplified)</option>
                                <option value="by_gfa_simplified">By Total GFA (Simplified)</option>
                            </select>
                        </div>

                    </div>
                    
                    <div id="buildingDistributionSankey"></div>

                    <!-- Year → Occupancy → Material → Foundation → Soil (compname) Sankey -->
                    <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 id="yearOccSankeyTitle" style="color:#2c3e50;">Construction Year → Occupancy → Material → Foundation → Soil</h3>
                        <p style="color:#555;">Base: Year → Occupancy. Toggle columns to the right.</p>

                        <!-- Toggles -->
                        <div style="margin-top:8px;">
                        <label style="margin-right:16px;">
                            <input type="checkbox" id="toggleMaterial" checked onchange="handleYearOccToggleChange()">
                            Show Material
                        </label>
                        <label style="margin-right:16px;">
                            <input type="checkbox" id="toggleFoundation" checked onchange="handleYearOccToggleChange()">
                            Show Foundation
                        </label>
                        <label>
                            <input type="checkbox" id="toggleSoil" checked onchange="handleYearOccToggleChange()">
                            Show Soil (compname)
                        </label>

                        <!-- NEW: metric selector for Year→Occ→... Sankey -->
                        <span style="display:inline-block; margin-left:20px; font-weight:600;">Metric:</span>
                        <select id="yearOccMetric" onchange="createYearOccSankey()"
                                style="padding:6px 10px; border:1px solid #dee2e6; border-radius:4px; font-size:13px;">
                        <option value="count" selected>Buildings count</option>
                        <option value="gfa">GFA (sqm)</option>
                        </select>

                        <!-- Export / Screenshot bar -->
                        <span style="display:inline-block; margin-left:20px; font-weight:600;">Export:</span>

                        <select id="yearOccExportFormat"
                                style="padding:6px 10px; border:1px solid #dee2e6; border-radius:4px; font-size:13px; margin-left:6px;">
                        <option value="png" selected>PNG (raster)</option>
                        <option value="svg">SVG (vector)</option>
                        <option value="jpeg">JPEG</option>
                        <option value="webp">WEBP</option>
                        </select>

                        <select id="yearOccExportScale"
                                title="Scale for PNG/JPEG/WEBP"
                                style="padding:6px 10px; border:1px solid #dee2e6; border-radius:4px; font-size:13px; margin-left:6px;">
                        <option value="1">1×</option>
                        <option value="2">2×</option>
                        <option value="3" selected>3×</option>
                        <option value="4">4×</option>
                        </select>

                        <label style="margin-left:8px; font-weight:500;">
                        <input type="checkbox" id="yearOccTransparentBg"> Transparent BG
                        </label>

                        <button onclick="downloadYearOccSankey()"
                                style="margin-left:8px; padding:6px 10px; border:1px solid #ced4da; border-radius:6px; background:#f8f9fa; cursor:pointer;">
                        Save
                        </button>



                        </div>
                    </div>

                    <!-- The actual Sankey container -->
                    <div id="yearOccSankey"></div>
                    </div>



                </div>

                
                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">Occupancy Class Hierarchy</h3>
                        <p style="color: #555;">Breakdown of Occupancy Classes (OCC_CLS) into Primary Occupancy types (PRIM_OCC).</p>
                    </div>
                    <div id="occupancyHierarchySankey"></div>
                </div>

                <!-- OCC_CLS → NSI occtype sankey -->
                <div class="section-header" style="margin-top:24px; padding-top: 8px; border: none;">
                <h3 style="color:#2c3e50;">OCC_CLS → NSI occtype matches</h3>
                <p style="color:#555; margin: 4px 0 12px;">
                    Each link sums the number of NSI points in <em>polygons whose OCC_CLS equals the left-hand class</em>.
                    Counts are pooled per class (RES pool, COM pool, ...); points in other classes do not affect this pool.
                </p>
                </div>

                 <div class="info-box" id="occSankeyNotes" style="margin-top:16px;">
                <h3>Notes on NSI Damage Categories vs. Our Sankey Labels</h3>
                <p>
                    The NSI technical documentation states that certain occtypes are folded into broader
                    <em>‘damage categories’</em> : <strong>AGR</strong> and <strong>REL</strong> are counted under
                    <strong>Commercial</strong>, while <strong>GOV</strong> and <strong>EDU</strong> are counted under
                    <strong>Public</strong>. In this Sankey, we intentionally retain the original occtype labels and do
                    not re-bucket them into those damage-category umbrellas (e.g., <strong>REL is not folded into Commercial</strong>).
                </p>
                </div>
                <div id="occClsOccDictSankey" style="height: 1220px;"></div>



                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">Occupancy Homogeneity Score (MIX_SC) Distribution</h3>
                        <p style="color: #555;">Distribution of buildings based on the homogeneity of NSI point types within their footprint.</p>
                    </div>
                    <div class="controls" style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <div class="toggle-switch">
                            <label for="toggleSameType">Include 'Same Type Only' Category:</label>
                            <input type="checkbox" id="toggleSameType" onchange="createMixScPieChart()" checked>
                        </div>
                    </div>
                    <div id="mixScPieChart"></div>
                    <div class="info-box" style="margin-top: 20px;">
                        <h3>MIX_SC Categories Explained</h3>
                        <p>
                            <strong>Same Type Only (NaN in data):</strong> All NSI points inside the building polygon are of the same primary type as the building itself.<br>
                            <strong>1 Conflict Type (MIX_SC1):</strong> No NSI points of the same type as the building, and all conflicting points are of a single different type.<br>
                            <strong>Same & Different Types (MIX_SC2):</strong> The building contains NSI points of its own type plus one or more conflicting types.<br>
                            <strong>>1 Conflict Types (MIX_SC3):</strong> The building contains no NSI points of the same type as the building, and has two or more different conflicting types.
                        </p>
                    </div>
                </div>



                <div class="export-buttons">
                    <button class="export-button" onclick="exportChart('overviewChart', 'overview')">Export Chart</button>
                    <button class="export-button" onclick="exportAllData()">Export All Data</button>
                </div>

            </div>
            
            <!-- NEW DATA PIPELINES SECTION -->
            <div id="dataAnalysis" class="section">
                <div class="section-header">
                    <h2>Data Pipelines & Processing Pipeline</h2>
                    <p>Understanding the data sources, predictions, cleaning, and distribution</p>
                </div>
                
                <div class="info-box">
                    <h3>Data Pipeline Overview</h3>
                    <p>This section visualizes the journey of forging our powerful, multi-layered dataset from three distinct sources. We began with the USA Structures building inventory(MA only*) as our foundational layer. This base was then systematically enriched, first by incorporating structural characteristics('Year Built', 'Foundation Type', etc.) from the National Structure Inventory(NSI), and second, by adding crucial geotechnical context from the Web Soil Survey. The following diagrams visualize these complex joins, data cleaning procedures, and the final composition of the dataset...</p>
                </div>
                
            <div class="chart-container" style="background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">NSI-Enhanced USA Structures Dataset Composition</h3>
                        <p style="color: #555;">Click on any data source to explore its contributed columns</p>
                    </div>
                    <div id="dataSourcesFlowchart" style="position: relative; min-height: 500px;"></div>
                    
                    <div id="columnDetailsPanel" style="display: none; background: white; border-radius: 10px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <h4 id="columnDetailsTitle" style="color: #2c3e50; margin-bottom: 15px;"></h4>
                        <div id="columnDetailsList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;"></div>
                    </div>
                </div>

            <div class="flowchart-container">
                <!-- Stage 1 -->
                <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 1: Spatial Join to Create NSI Enhanced Version
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
                        <div class="flow-content">
                            <div class="flow-inputs">
                                <div class="flow-box data-source usa-structures">
                                    <h4>USA Structures (Base)</h4>
                                    <p>2,091,488 Records</p>
                                    <p>38 Columns</p>
                                </div>
                                <div class="plus-icon">+</div>
                                <div class="flow-box data-source nsi">
                                    <h4>NSI Data Points</h4>
                                    <p>2,095,529 Records</p>
                                    <p>15 Columns Added</p>
                                </div>
                            </div>

                            <div class="flow-arrow">▼</div>
                            
                            <div class="flow-box operation">
                                <h4>Operation: Advanced Multi-Stage Spatial Join</h4>
                                <p>An enhanced, multi-stage process was implemented to accurately enrich building footprints with NSI point data. This updated methodology features flexible handling of mixed-use properties, a precise nearest-neighbor buffer match, and systematic occupancy conflict detection to ensure data quality.</p>
                                <ul>
                                    <li><strong>Strategy 1: Intelligent Single-Family Matching</strong>
                                        <ul>
                                            <li>For buildings classified as 'Single Family', the process now flexibly considers both residential (<code>RES</code>) and commercial (<code>COM</code>) NSI points inside. This accommodates mixed-use scenarios like in-home businesses.</li>
                                            <li><strong>If one point is found,</strong> a direct one-to-one match is made.</li>
                                            <li><strong>If multiple points are found,</strong> their attributes are <strong>aggregated</strong> to create a composite profile, replacing the previous centroid-based selection. This robustly handles properties with multiple distinct units (e.g., a house with a separate commercial unit).</li>
                                        </ul>
                                    </li>
                                    <li><strong>Strategy 2: Standard Aggregation for Other Buildings</strong>
                                        <ul>
                                            <li>For all other building types (multi-family, commercial, etc.), all NSI points falling within the footprint are used.</li>
                                            <li>Their attributes are <strong>aggregated</strong> to create a comprehensive profile for the building:
                                                <ul>
                                                    <li><strong>Value & Area (`structure_value`, `nsi_sqft`):</strong> Summed to get a total.</li>
                                                    <li><strong>Stories (`nsi_num_story`):</strong> The maximum value is taken.</li>
                                                    <li><strong>Characteristics (`year_built`, `material_type`):</strong> The statistical mode (most frequent value) is used.</li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                    <li><strong>Strategy 3: Nearest Neighbor Buffer Match</strong>
                                        <ul>
                                            <li>For NSI points that remain unmatched, this strategy finds the <strong>single nearest building polygon</strong> within a <strong>5-meter radius</strong>.</li>
                                            <li>This ensures each point is uniquely assigned to its closest building, correcting for minor spatial inaccuracies. A single building can "absorb" multiple nearby points via this method.</li>
                                            <li>A configurable option also allows buildings already matched in earlier stages to absorb additional nearby points, capturing features like adjacent garages or utility structures.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Extra Feature: Systematic Occupancy Conflict Detection</strong>
                                        <ul>
                                            <li>Throughout the process, the script will actively compare the land use category of the NSI point (e.g., 'Commercial') against the category of the building polygon it falls into (e.g., 'Residential').</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>

                            <div class="flow-inputs">
                            <div class="flow-box operation" id="stage1-metrics">
                                <details class="stage-panel" >
                                <summary><strong>Stage Details & Unmatched Points(Click for detail)</strong></summary>
                                <div id="stage1MetricsMount"></div>
                                </details>
                            </div>
                            </div>

                                                        
                            <div class="flow-arrow">▼</div>

                            <div class="flow-box result nsi-enhanced">
                                <h4>Result: NSI Enhanced Structures v1</h4>
                                <p>2,091,488 Records</p>
                                <p>53 Columns (38 Base + 15 from NSI)</p>
                                <small>A Left Join was performed, so all original buildings were retained. Unmatched buildings(405,037 in total) have NaN values for NSI columns(year_built, foundation_type, etc.).</small>
                            </div>


                        
                    </div>
                </div>

                </div> <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 1.5: 'Unclassified' buildings from USA Structures were re-defined using NSI point data
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
        <div class="info-box" style="border-left-color:#00b894; margin-top:16px;">
            <h3>How we re-label “Unclassified” using <code>OCC_DICT</code></h3>
            <ul style="margin-left: 16px;">
                <li><b>Vote by counts</b> in <code>OCC_DICT</code> (e.g., <code>RES: 0, COM: 8, IND: 1, GOV: 0, EDU: 0 ...</code> → Commercial).</li>
                <li><b>REL is counted as Assembly</b> according to USA Structure PRIM_OCC column (e.g., <code>RES: 1, IND: 1, REL: 2</code> → Assembly).</li>
                <li>If all <code>RES/COM/IND/GOV/EDU/AGR/REL</code> are 0 → keep <b>Unclassified</b>.</li>
                <li>If there is a tie in the vote (e.g., <code>RES: 1, COM: 1</code>), the building will <b>remain Unclassified</b>.</li>
            </ul>
            <p style="margin-top:6px;">
                This relabeling occurs in the data cleaning step before any downstream charts/tables,
                so all occupancy analyses reflect the updated <code>OCC_CLS</code>.
            </p>
        </div>

                        <div class="chart-container" id="unclassifiedResolutionSection">
                            <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                                <h3 style="color:#2c3e50;">Unclassified Reclassification Summary</h3>
                                <p style="color:#555;">How many Unclassified records were re-labeled into each class</p>
                            </div>

                            <div class="stats-grid">
                                <div class="stat-card">
                                <div class="stat-value" id="unclsTotalBefore">—</div>
                                <div class="stat-label">Total Unclassified (Before)</div>
                                </div>
                                <div class="stat-card">
                                <div class="stat-value" id="unclsWithOccDict">—</div>
                                <div class="stat-label">With OCC_DICT</div>
                                </div>
                                <div class="stat-card">
                                <div class="stat-value" id="unclsChanged">—</div>
                                <div class="stat-label">Changed</div>
                                </div>
                                <div class="stat-card">
                                <div class="stat-value" id="unclsUnchanged">—</div>
                                <div class="stat-label">Kept Unclassified</div>
                                </div>
                            </div>

                            <div id="unclassifiedResolutionTable" style="margin-top:16px;"></div>
                            <div id="unclassifiedTieBreakerSection" style="margin-top: 24px; border: 1px solid #dee2e6; border-radius: 4px; background: #fdfdfd;">
                                <details>
                                    <summary style="padding: 12px; font-weight: 600; color: #2c3e50; cursor: pointer; list-style: inside;">
                                        Tie-Breaker Situations (Kept as Unclassified) - Click to expand
                                    </summary>
                                    <div id="unclassifiedTieBreakerTable" style="padding: 0 12px 12px 12px; border-top: 1px solid #eee; max-height: 300px; overflow-y: auto;">
                                        </div>
                                </details>
                            </div>
                        </div>
                        <div id="unclassifiedDetailsSection" class="info-box" style="border-left-color:#00b894; margin-top:16px; display:none;">
                            <h3>Reclassification Details</h3>
                            <div style="display:flex; gap:12px; align-items:center; margin-bottom:10px;">
                                <label for="reclassFilter">Filter by New Class:</label>
                                <select id="reclassFilter">
                                <option value="All">All</option>
                                <option value="R">Residential</option>
                                <option value="C">Commercial</option>
                                <option value="I">Industrial</option>
                                <option value="G">Government</option>
                                <option value="E">Education</option>
                                <option value="A">Agriculture</option>
                                <option value="S">Assembly</option>
                                </select>

                                <div style="margin-left:auto;">
                                <button id="prevPageBtn">Prev</button>
                                <span id="pageInfo" style="margin:0 8px;">–/–</span>
                                <button id="nextPageBtn">Next</button>
                                </div>
                            </div>

                            <div id="unclassifiedDetailsTable" style="overflow:auto; max-height:460px; border:1px solid #eee;"></div>
                            
                            <div id="unclassifiedDetailsTable" style="overflow:auto; max-height:420px; border:1px solid #eee;"></div>
                        </div>
                        </div>
                </div>

                <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 2: Building the Enhanced Soil Layer & Final Join
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
                        <div class="flow-content">
                            <div class="flow-inputs">
                                <div class="flow-box data-source nsi-enhanced-input">
                                    <h4>NSI-Enhanced USA Structures Dataset v1</h4>
                                    <p>2,091,488 Records (Polygons)</p>
                                    <p>53 Columns</p>
                                    <small>Input: GPKG (Preserves footprints)</small>
                                </div>
                                <div class="plus-icon">+</div>
                                <div class="flow-box data-source soil-survey">
                                    <h4>Web Soil Survey (WSS) Data</h4>
                                    <p>Sources: gsmsoilmu_a_ma.shp</p>
                                    <p>Tables: comp.txt, chorizon.txt</p>
                                    <p>12 Columns</p>
                                </div>
                            </div>

                            <div class="flow-arrow">▼</div>
                            <div class="flow-box operation">
                                <h4>Operation: Soil Enrichment & Area-Weighted Spatial Join</h4>
                                <ul>
                                    <li><strong>Part A: Preparing the Enhanced Soil Layer</strong>
                                        <ul>
                                            <li><strong>1. Component Filtering:</strong> Reads <code>comp.txt</code> and selects only the single <strong>Dominant Component</strong> (highest percentage) for each Map Unit.</li>
                                            <li><strong>2. Horizon Filtering:</strong> Reads <code>chorizon.txt</code> and selects only <strong>Topsoil</strong> properties (depth < 10cm) to capture engineering characteristics relevant to foundations.</li>
                                            <li><strong>3. Merge:</strong> Attributes are merged onto the Soil Shapefile to create a single, simplified soil layer.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Part B: Spatial Intersection (EPSG:26986)</strong>
                                        <ul>
                                            <li>Data is projected to <strong>Mass State Plane (Meters)</strong> for accurate area measurement.</li>
                                            <li>A <strong>Polygon-on-Polygon</strong> intersection (<code>predicate='intersects'</code>) is performed between buildings and soil layers.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Part C: Area-Weighted Conflict Resolution</strong>
                                        <ul>
                                            <li><strong>Problem:</strong> Some buildings straddle the boundary between two or more soil map units.</li>
                                            <li><strong>Solution:</strong> The script calculates the exact <strong>Overlap Area</strong> for every match. If a building touches multiple soil units, it is assigned to the one with the <strong>largest intersection area</strong>.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                            <div class="flow-arrow">▼</div>
                            
                            <div class="flow-box result final-dataset">
                                <h4>Result: NSI-Enhanced USA Structures Dataset v2</h4>
                                <p>2,091,488 Records</p>
                                <p>65 Total Columns (53 + 12 from Soil)</p>
                                <p>Preserved Geometry: Polygons</p>
                                <small>
                                    <strong>Cleanup:</strong> IDs renamed to <code>soil_mukey</code>/<code>soil_cokey</code>. 
                                    Buildings outside soil map coverage are labeled as "Unmatched" (retained via Left Join).
                                </small>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 2.5: CLF-Based Foundation Classification
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
                        <div class="flow-content">
                            <div class="flow-inputs">
                                <div class="flow-box data-source final-dataset">
                                    <h4>NSI-Enhanced USA Structures Dataset v2</h4>
                                    <p>Input: GPKG (Polygons)</p>
                                    <p>Target Column: <code>foundation_type</code></p>
                                    <p>65 Columns</p>
                                </div>
                                <div class="plus-icon">+</div>
                                <div class="flow-box data-source" style="background-color: #fff8e1; border-color: #ffc107;">
                                    <h4>CLF Categorization</h4>
                                    <p>Carbon Leadership Forum</p>
                                    <p>Target Column: <code>str_fdn_type</code></p>
                                </div>
                            </div>

                            <div class="flow-arrow">▼</div>

                            <div class="flow-box operation">
                                <h4>Operation: Dictionary Mapping & Type Cleaning</h4>
                                <p>Mapping specific NSI foundation codes to broader str_fdn_type for standardized Carbon Analysis.</p>
                                
                                <div style="margin-top: 15px; background: white; border: 1px solid #eee; border-radius: 6px; overflow: hidden;">
                                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                                        <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                            <th style="padding: 8px; text-align: left;">NSI Codes (Original)</th>
                                            <th style="padding: 8px; text-align: left;">General Type (Mapped)</th>
                                        </tr>
                                        <tr style="border-bottom: 1px solid #eee;">
                                            <td style="padding: 8px;">
                                                <strong>C, B, S, W, F</strong><br>
                                                <span style="color: #666; font-size: 0.85em;">(Crawl, Basement, Slab, Wall, Fill)</span>
                                            </td>
                                            <td style="padding: 8px; color: #2E7D32; font-weight: bold;">Shallow Foundation</td>
                                        </tr>
                                        <tr>
                                            <td style="padding: 8px;">
                                                <strong>P, I</strong><br>
                                                <span style="color: #666; font-size: 0.85em;">(Pier, Pile)</span>
                                            </td>
                                            <td style="padding: 8px; color: #d35400; font-weight: bold;">Deep Foundation &lt; 50' (15m)</td>
                                        </tr>
                                    </table>
                                </div>
                            </div>

                            <div class="flow-arrow">▼</div>
                            
                            <div class="flow-box result nsi-enhanced-input">
                                <h4>Result: NSI-Enhanced USA Structures Dataset v2.5</h4>
                                <p>2,091,488 Records (Polygons Preserved)</p>
                                <p>+1 Column: <code>general_fnd_type</code></p>
                                <p>66 Columns</p>
                                <small>
                                    <strong>Data Cleaning:</strong> All object columns converted to String to ensure GPKG stability and prevent "Error adding field" issues.
                                </small>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 3: Enriching with Demolition Permit Data
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
                        <div class="flow-content">
                            <div class="flow-inputs">
                                <div class="flow-box result final-dataset" style="background-color: #e8f5e9; border-color: #2E7D32;">
                                    <h4>NSI-Enhanced USA Structures Dataset v2.5</h4>
                                    <p>Input: GPKG (Polygons)</p>
                                    <p>66 Columns</p>
                                    <small>Includes <code>general_fnd_type</code></small>
                                </div>
                                <div class="plus-icon">+</div>
                                <div class="flow-box data-source boston-permits">
                                    <h4>Boston Approved Permit Dataset</h4>
                                    <p>Source: tmpbtz4x7bc.csv</p>
                                    <p>Filter: EXTDEM, INTDEM, RAZE</p>
                                    <p>3 Key Columns</p>
                                </div>
                            </div>
                            <div class="flow-arrow">▼</div>
                            <div class="flow-box operation">
                                <h4>Operation: Spatial Join (Polygons Preserved)</h4>
                                <ul>
                                <li><strong>1. Priority-Based Deduplication:</strong> Filters permits and selects the "best" record per address. 
                                    <br><em>Priority Rule:</em> <strong>Closed/Completed</strong> > Open > Most Recent Date.</li>
                                <li><strong>2. CRS Alignment (EPSG:2249):</strong> Both datasets are projected to <strong>MA State Plane (Meters)</strong> for precise distance calculation.</li>
                                <li><strong>3. Nearest Neighbor Join (5m Radius):</strong> Uses <code>sjoin_nearest</code> to find the single closest permit within <strong>5 meters</strong> (from polygon edge).
                                    
                                    <div style="margin-top: 8px; padding: 8px; background: #eef2f7; border-left: 3px solid #3498db; border-radius: 4px; font-size: 0.9em;">
                                        <strong>Matching Statistics (Total: 5,018):</strong><br>
                                        <span style="color: #27ae60;">●</span> Exact Matches (In Polygon): <strong>4,922 (98.1%)</strong><br>
                                        <span style="color: #e67e22;">●</span> Buffer Matches (<5m): <strong>96 (1.9%)</strong>
                                    </div>
                                </li>
                                <li><strong>4. Non-Destructive Merge:</strong> New attributes (`DEMOLITION_TYPE`, `DATE`, `STATUS`) are joined back using <strong>Index Alignment</strong>. This guarantees zero data loss and perfectly preserves original Polygon geometry.</li>
                                </ul>
                            </div>
                            <div class="flow-arrow">▼</div>
                            <div class="flow-box data-source nsi-enhanced-input" style="border-color: #2E7D32; background-color: #e8f5e9;">
                                <h4>Result: NSI-Enhanced USA Structures Dataset v3</h4>
                                <p>2,091,488 Records</p>
                                <p>69 Total Columns (66 + 3 from Permits)</p>
                                <p>Geometry: MultiPolygon (Unchanged)</p>
                                <small>
                                    <strong>Validation:</strong> Original row count (2,091,488) perfectly preserved.
                                    <br><strong>Final Format:</strong> GPKG (Layer: <code>structures_demolition</code>)
                                </small>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flow-stage">
                    <h3 class="stage-title collapsible-trigger">
                        Stage 4: MassGIS Parcel Integration & Temporal Fusion Strategy
                        <span class="collapse-icon">▼</span>
                    </h3>
                    <div class="collapsible-content">
                        <div class="flow-content">
                            <div class="flow-inputs">
                                <div class="flow-box result final-dataset">
                                    <h4>NSI-Enhanced USA Structures Dataset v3</h4>
                                    <p>Input: GPKG (Polygons)</p>
                                    <p>2,091,488 Records</p>
                                    <p>68 Columns</p>
                                    <small>Contains original NSI Year Data</small>
                                </div>
                                <div class="plus-icon">+</div>
                                <div class="flow-box data-source" style="background-color: #fb9f3a20; border-color: #fb9f3a;">
                                    <h4>MassGIS Parcels L3 Data</h4>
                                    <p>Source: Parquet (Chunked)</p>
                                    <p>Unique Parcels: 2,623,246</p>
                                    <p>1 Column</p>
                                    <small>Processed via Dask LocalCluster</small>
                                </div>
                            </div>

                            <div class="flow-arrow">▼</div>

                            <div class="flow-box operation" style="max-width: 800px;">
                                <h4>Operation: High-Performance Spatial Join & Logic-Based Fusion</h4>
                                <ul>
                                    <li><strong>1. Centroid-Based Spatial Indexing:</strong> 
                                        To optimize performance and accuracy, building geometries were converted to <strong>Centroids</strong> before performing a `within` spatial join against the MassGIS Parcel polygons.
                                    </li>
                                    <li><strong>2. Temporal Conflict Resolution (Latest Year Heuristic):</strong>
                                        <br><span style="font-size:0.9em; color:#666;">Handling parcels with multiple build years:</span>
                                        <ul>
                                            <li>When a single building matched multiple parcel records (potential duplicates or subdivisions), the system prioritized the <strong>most recent construction year</strong>.</li>
                                            <li>Method: Data was sorted by <code>[BUILD_ID, YEAR_BUILT]</code> in <code>[Ascending, Descending]</code> order, retaining only the top record.</li>
                                        </ul>
                                    </li>
                                    <li><strong>3. Data Cleaning:</strong> 
                                        Outliers were removed by filtering <code>massgis_yr_built</code> to the valid range of <strong>1630 - 2025</strong>. (1,709 invalid values detected and removed).
                                    </li>
                                    <li><strong>4. Source Prioritization Strategy:</strong>
                                        <p style="margin-top: 8px; margin-bottom: 8px; color: #555;">
                                            The decision logic for merging MassGIS and NSI year data is illustrated below:
                                        </p>
                                        <img src="workflow.png" alt="Source Tracking Workflow Logic" style="max-width: 100%; height: auto; border: 1px solid #dee2e6; border-radius: 6px; padding: 4px; background: white;">
                                    </li>
                                </ul>
                            </div>

                            <div class="flow-arrow">▼</div>

                            <div class="flow-box result final-dataset" style="max-width: 800px; background: #fff;">
                                <h4 style="margin-bottom: 15px;">Data Fusion Statistics</h4>
                                
                                <div class="stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 0;">
                                    <div class="stat-card" style="padding: 15px; background: white; border: 1px solid #eee; border-top: 4px solid #fb9f3a; box-shadow: 0 2px 5px rgba(0,0,0,0.03);">
                                        <div class="stat-value" style="font-size: 1.8em; color: #2c3e50;">97.79%</div>
                                        <div class="stat-label" style="color: #666;">Sourced from MassGIS</div>
                                        <div style="font-size: 0.85em; color: #999; margin-top: 5px;">(2,045,196 buildings)</div>
                                    </div>
                                    
                                    <div class="stat-card" style="padding: 15px; background: white; border: 1px solid #eee; border-top: 4px solid #764ba2; box-shadow: 0 2px 5px rgba(0,0,0,0.03);">
                                        <div class="stat-value" style="font-size: 1.8em; color: #2c3e50;">0.66%</div>
                                        <div class="stat-label" style="color: #666;">Filled by NSI</div>
                                        <div style="font-size: 0.85em; color: #999; margin-top: 5px;">(13,720 buildings)</div>
                                    </div>
                                    
                                    <div class="stat-card" style="padding: 15px; background: white; border: 1px solid #eee; border-top: 4px solid #95a5a6; box-shadow: 0 2px 5px rgba(0,0,0,0.03);">
                                        <div class="stat-value" style="font-size: 1.8em; color: #2c3e50;">1.55%</div>
                                        <div class="stat-label" style="color: #666;">No Year Data</div>
                                        <div style="font-size: 0.85em; color: #999; margin-top: 5px;">(32,572 buildings)</div>
                                    </div>
                                </div>
                            </div>

                            <div class="flow-arrow">▼</div>
                            
                            <div class="flow-box result final-dataset">
                                <h4>Result: Final Integrated Dataset</h4>
                                <p>2,091,488 Records (Polygons Preserved)</p>
                                <p>+3 Columns: <code>massgis_yr_built</code>, <code>nsi_yr_built</code>, <code>yr_built_belong</code></p>
                                <p>72 Columns Total</p>
                                <small>
                                    <strong>Output:</strong> ma_structures_FINAL_with_YR_SOURCE.gpkg
                                </small>
                            </div>

                            <div class="chart-container" style="margin-top: 30px; border-top: 2px dashed #eee; padding-top: 30px; width: 100%;">
                                <div class="section-header" style="border: none; margin-bottom: 15px;">
                                    <h3 style="color: #2c3e50;">Data Sources vs. Final Result</h3>
                                    <p style="color: #555;">Compare the original data sources (NSI vs MassGIS) or view the final cleaned distribution.</p>
                                </div>

                                <div class="controls" style="background: #f8f9fa; padding: 12px 20px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center;">
                                    <div class="toggle-switch">
                                        <label style="cursor: pointer; display: flex; align-items: center;">
                                            <input type="checkbox" id="toggleShowFinal" onchange="createYearSourceComparisonChart()">
                                            <span style="font-weight: 600; color: #495057; margin-left: 8px;">Switch to Final Cleaned Dataset</span>
                                        </label>
                                    </div>
                                </div>

                                <div id="yearSourceComparisonChartCount" style="height: 450px; margin-bottom: 30px;"></div>
                                
                                <div id="yearSourceComparisonChartGFA" style="height: 450px;"></div>
                            </div>

                        </div>
                    </div>
                </div>

                
            </div>



                <!-- Data Cleaning Sankey -->
                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">Geopackage data to Json data - Cleaning Process</h3>
                        <p style="color: #555;">How .gpkg data is filtered, cleaned and preprocessed to couple .json files</p>
                    </div>
                    <div id="dataCleaningSankey"></div>
                </div>



                <!-- NSI Data Sources Sankey -->
                <div class="chart-container">
                    <div class="info-box">
                        <h3>NSI Methodology Explained</h3>
                        <p>The National Structural Inventory (NSI) sources key building attributes—such as year built and construction material—primarily from the commercial data provider Lightbox. When gaps or missing values occur in the Lightbox data, the NSI applies a logical random imputation methodology based on HAZUS tables to fill in those gaps. This process helps ensure the dataset’s overall completeness and quality.

The diagram below shows the fill rate of attributes obtained directly from Lightbox. For any missing data, the NSI may have used HAZUS tables as substitutes.</p>
                    </div>
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">NSI Data Sources & Predictions</h3>
                        <p style="color: #555;">How building material and foundation type data are obtained</p>
                    </div>
                    <div id="nsiDataSourcesSankey"></div>
                    <div class="warning-box">
                        <h4>Data Source Information</h4>
                        <p>Lightbox provides 2,542,265 total MA building data records. Building material data is available for 1,208,023 records (47.52% coverage), 
                        and foundation type data for 54,497 records (2.14% coverage). Missing values are predicted using HAZUS methodology.</p>
                    </div>
                </div>

                
            </div>
            <!-- SOIL ANALYSIS SECTION (with modifications) -->
            <div id="soilAnalysis" class="section">
                <div class="section-header">
                    <h2>Soil Properties and Risk Analysis</h2>
                    <p>Comprehensive analysis of soil conditions and their impact on building infrastructure</p>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="highRiskBuildings">Loading...</div>
                        <div class="stat-label">High Risk Buildings</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="avgWaterTable">Loading...</div>
                        <div class="stat-label">Avg Water Table (cm)</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="poorDrainageCount">Loading...</div>
                        <div class="stat-label">Poor Drainage Sites</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="floodRiskCount">Loading...</div>
                        <div class="stat-label">Flood Risk Buildings</div>
                    </div>
                </div>
                
                <div class="info-box soil-info">
                    <h3>Soil Data Categories</h3>
                    <p><strong>Drainage Classes:</strong> Well drained, Moderately well drained, Somewhat excessively drained, Poorly drained, Very poorly drained, Excessively drained<br>
                    <strong>Flooding Frequency:</strong> Low, Moderate, High<br>
                    <strong>Engineering Properties:</strong> <= 0.17 Favorable,	> 0.17 and <= 0.24 Fair, > 0.24 and <= 0.32	Poor,  > 0.32 Very poor<br>
                    <strong>Soil Component:</strong> Various soil types identified by compname field</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Analysis Type:</label>
                        <select id="soilAnalysisType" onchange="updateSoilAnalysis()">
                            <option value="drainage">Drainage Class</option>
                            <option value="flooding">Flooding Frequency</option>
                            <option value="engineering">Engineering Properties</option>
                            <option value="compname">Soil Component Name</option>
                            <option value="risk">Risk Assessment</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Show Risk Overlay(*For Map plot):</label>
                            <input type="checkbox" id="showRiskOverlay" onchange="updateSoilMap()">
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="soilDistributionChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="soilByOccupancyChart"></div>
                </div>
                
                <div class="map-container">
                    <div id="soilMap"></div>
                </div>
                
                <div class="chart-container">
                    <div id="waterTableHistogram"></div>
                </div>
                
                <div class="warning-box">
                    <h4>Risk Assessment Methodology</h4>
                    <p>High-risk buildings are identified based on poor drainage conditions (Poorly drained or Very poorly drained) 
                    and/or frequent flooding risk (Occasional or Frequent). These conditions can impact foundation stability, 
                    basement flooding potential, and overall structural integrity over time. Buildings in high-risk zones may 
                    require additional maintenance and waterproofing measures.</p>
                </div>
            </div>

            <!-- CLUSTERING SECTION -->
            <div id="simpleClustering" class="section">
                <div class="section-header">
                    <h2>Clustering Analysis</h2>
                    <p>K-means clustering results based on building area, year built, and occupancy class (using a random sample for visualization)</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Number of Clusters:</label>
                        <select id="clusterCount">
                            <option value="5">5 Clusters</option>
                            <option value="6">6 Clusters</option>
                            <option value="7" selected>7 Clusters</option>
                            <option value="8">8 Clusters</option>
                            <option value="9">9 Clusters</option>
                        </select>
                        <button class="control-button" onclick="updateClusteringWithNewK()">Update Analysis</button>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterScatter"></div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterElbow"></div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterTable"></div>
                </div>
                
                <div class="chart-container">
                    <div class="control-group">
                        <label>Treemap Size By:</label>
                        <select id="treemapSizeBy" onchange="updateClusterTreemap()">
                            <option value="count">Building Count</option>
                            <option value="area">Total Floor Area</option>
                        </select>
                    </div>
                    <div id="clusterTreemap"></div>
                </div>

                <div class="map-container" style="margin-top: 30px;">
                    <div class="section-header" style="border:none; margin-bottom:10px;">
                        <h3>Geographic Distribution of Clusters</h3>
                        <p>Visualizing how the K-means clusters identified above are distributed spatially.</p>
                    </div>
                    <div id="clusterMapPlot"></div>
                </div>
            </div>

            <!-- TEMPORAL SECTION -->
            <div id="temporal" class="section">
                <div class="section-header">
                    <h2>Temporal Distribution (1630 - 2025)</h2>
                    <p>Building construction patterns over four centuries</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Year Range:</label>
                        <input type="number" id="temporalStart" value="1630" min="1630" max="2025" style="width: 80px" onchange="updateTemporalChart()">
                        <span style="margin: 0 10px; align-self: center;">to</span>
                        <input type="number" id="temporalEnd" value="2025" min="1630" max="2025" style="width: 80px" onchange="updateTemporalChart()">
                    </div>

                    <div class="control-group">
                        <div class="toggle-switch" style="margin-right: 20px;">
                            <label style="cursor:pointer;">
                                <input type="checkbox" id="temporalDecadeToggle" onchange="updateTemporalChart()" checked>
                                <span style="font-weight:600; color:#555;">Group by Decade</span>
                            </label>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Chart Type:</label>
                        <select id="chartType" onchange="updateTemporalChart()">
                            <option value="bar" selected>Bar Chart</option> <option value="line">Line Chart</option>    <option value="stacked">Stacked Area</option>
                            <option value="normalized">Normalized (100%)</option>
                            <option value="cumulative">Cumulative</option>
                        </select>
                        
                        <label>Building Type:</label>
                        <select id="buildingType" onchange="updateTemporalChart()">
                            <option value="all">All Buildings</option>
                            <option value="residential">Residential Only</option>
                            <option value="non-residential">Non-Residential Only</option>
                        </select>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalAreaChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalTrendChart"></div>
                </div>
            </div>
            


            <!-- ENHANCED OCCUPANCY CLUSTERING SECTION -->
            <div id="occupancyClustering" class="section">
                <div class="section-header">
                    <h2>Multi-Dimensional Occupancy Clustering Analysis</h2>
                    <p>Advanced clustering analysis with dynamic feature selection for true multi-dimensional clustering</p>
                </div>
                
                <div class="info-box" style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); border-left-color: #ff9800;">
                    <h3 style="color: #e65100;">Dynamic Clustering Features</h3>
                    <p style="color: #bf360c;">
                        <strong>Base Dimensions (4D):</strong> Year Built, Footprint Area (SQMETERS), Height (HEIGHT_USED — measured HEIGHT when available, otherwise PRED_HEIGHT), Occupancy Class<br>
                        <strong>+ Material Type (5D):</strong> Adds material type as a clustering dimension<br>
                        <strong>+ Foundation Type (5D):</strong> Adds foundation type as a clustering dimension<br>
                        <strong>+ Both (6D):</strong> Includes all dimensions for comprehensive clustering<br>
                        <strong>Real-time Reclustering:</strong> Each toggle change triggers new clustering calculations based on selected features
                    </p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Select Occupancy Class:</label>
                        <select id="occupancyClass" onchange="updateOccupancyClustering()">
                            <option value="all">All Classes</option>
                            <option value="Residential">Residential</option>
                            <option value="Commercial">Commercial</option>
                            <option value="Industrial">Industrial</option>
                            <option value="Agriculture">Agriculture</option>
                            <option value="Government">Government</option>
                            <option value="Assembly">Assembly</option>
                            <option value="Education">Education</option>
                            <option value="Utility and Misc">Utility & Misc</option>
                            <option value="Unclassified">Unclassified</option>
                        </select>
                        
                        <label>Number of Clusters (K):</label>
                        <select id="occupancyK" onchange="updateOccupancyClustering()">
                            <option value="2">K = 2</option>
                            <option value="3">K = 3</option>
                            <option value="4">K = 4</option>
                            <option value="5" selected>K = 5</option>
                            <option value="6">K = 6</option>
                            <option value="7">K = 7</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <div class="toggle-switch" style="border: 2px solid #4facfe; padding: 10px; border-radius: 8px; background: rgba(79, 172, 254, 0.05);">
                            <label style="font-weight: bold; color: #0066cc;">Include Material Type:</label>
                            <input type="checkbox" id="includeMaterial" onchange="updateOccupancyClustering()">
                            <select id="materialTypeFilter" style="margin-left: 10px; display: none;" onchange="updateOccupancyClustering()">
                                <option value="all">All Materials</option>
                                <option value="W">Wood</option>
                                <option value="M">Masonry</option>
                                <option value="C">Concrete</option>
                                <option value="S">Steel</option>
                                <option value="H">Manufactured</option>
                            </select>
                        </div>
                        
                        <div class="toggle-switch" style="border: 2px solid #00f2fe; padding: 10px; border-radius: 8px; background: rgba(0, 242, 254, 0.05);">
                            <label style="font-weight: bold; color: #0099cc;">Include Foundation Type:</label>
                            <input type="checkbox" id="includeFoundation" onchange="updateOccupancyClustering()">
                            <select id="foundationTypeFilter" style="margin-left: 10px; display: none;" onchange="updateOccupancyClustering()">
                                <option value="all">All Foundations</option>
                                <option value="S">Slab</option>
                                <option value="B">Basement</option>
                                <option value="C">Crawl Space</option>
                                <option value="P">Pier</option>
                                <option value="I">Pile</option>
                                <option value="F">Fill</option>
                                <option value="W">Solid Wall</option>
                            </select>
                        </div>
                        
                        <label>Sample Type:</label>
                        <select id="sampleType" onchange="updateOccupancyClustering()" style="border: 2px solid #bd3786; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);">
                            <option value="balanced" selected>Balanced Sample (Equal Representation)</option>
                            <option value="random">Random Sample (True Distribution)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Sample Size for Visualization:</label>
                        <select id="sampleSize" onchange="updateOccupancyClustering()">
                            <option value="1000">1,000 buildings</option>
                            <option value="5000" selected>5,000 buildings</option>
                            <option value="10000">10,000 buildings</option>
                            <option value="20000">20,000 buildings</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Log Scale (Area):</label>
                            <input type="checkbox" id="logScale" onchange="updateOccupancyClustering()">
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: linear-gradient(135deg, #f0f4ff 0%, #e8f0ff 100%); border-radius: 8px; border-left: 4px solid #667eea;">
                        <div id="sampleTypeIndicator" style="font-size: 14px; color: #495057;">
                            <strong>Current View:</strong> <span id="currentSampleType" style="color: #7201a8; font-weight: bold;">Balanced Sample</span> - 
                            <span id="sampleDescription" style="color: #666;">Shows equal representation of all occupancy classes for better pattern visibility</span>
                        </div>
                        <div id="clusteringDimensions" style="margin-top: 8px; font-size: 14px; color: #495057;">
                            <strong>Active Clustering Dimensions:</strong> <span id="activeDimensions" style="color: #667eea; font-weight: bold;">Year, Area, Occupancy (3D)</span>
                        </div>
                        <div id="clusteringStatus" style="margin-top: 8px; font-size: 14px; color: #495057;">
                            <strong>Clustering Status:</strong> <span id="clusteringStatusText" style="color: #4facfe; font-weight: bold;">Using pre-computed base clustering</span>
                        </div>
                        <div id="filterStatus" style="margin-top: 8px; font-size: 14px; color: #495057; display: none;">
                            <strong>Active Filters:</strong> <span id="activeFilters" style="color: #4facfe; font-weight: bold;"></span>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyClusterChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyFullStatsChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancySampleStatsChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyElbowChart"></div>
                </div>
            </div>

            <!-- MATERIALS SECTION -->
            <div id="materials" class="section">
                <div class="section-header">
                    <h2>Building Materials & Foundation Analysis</h2>
                    <p>Correlation between material types and foundation types - Click on any cell to see occupancy breakdown</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Data Filter:</label>
                        <select id="materialFilter" onchange="updateMaterialsHeatmap()">
                            <option value="all">All Buildings</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Log Scale (Heatmap Only):</label>
                            <input type="checkbox" id="heatmapLogScale" onchange="updateHeatmapOnly()">
                        </div>

                        <div style="display: flex; align-items: center;">
                            <label style="font-size: 0.9em; margin-right: 8px; font-weight: 500;">Metric:</label>
                            <select id="structMetric" onchange="updateStructureHeatmapUI()" style="padding: 4px; font-size: 0.9em;">
                                <option value="count" selected>Count</option>
                                <option value="area">Gross Area (sq ft)</option>
                            </select>
                        </div>

                        <div style="border-left: 1px solid #ccc; height: 20px;"></div>
                        
                        <label style="margin-left: 20px;">Breakdown Chart Type:</label>
                        <select id="breakdownChartType" onchange="updateOccupancyBreakdown()">
                            <option value="pie">Pie Chart</option>
                            <option value="bar">Bar Chart</option>
                            <option value="horizontal-bar">Horizontal Bar</option>
                        </select>
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>Material & Foundation Type Codes</h3>
                    <p><strong>Material Types:</strong> M = Masonry, W = Wood, H = Manufactured, S = Steel, C = Concrete<br>
                    <strong>Foundation Types:</strong> C = Crawl Space, B = Basement, S = Slab, P = Pier, I = Pile, F = Fill, W = Solid Wall<br>
                    <strong style="color: #667eea;">👉 Click on any cell in either heatmap to see the occupancy class distribution for that combination</strong></p>
                </div>
                
                <!-- Heatmap tabs for switching between count and area -->
                <div class="heatmap-tabs">
                    <button class="heatmap-tab active" id="countHeatmapTab" onclick="showHeatmap('count')">Building Count</button>
                    <button class="heatmap-tab" id="areaHeatmapTab" onclick="showHeatmap('area')">Total Est GFA (sqm)</button>
                </div>
                
                <div class="chart-container" id="countHeatmapContainer">
                    <div id="materialsHeatmap"></div>
                </div>
                
                <div class="chart-container" id="areaHeatmapContainer" style="display: none;">
                    <div id="materialsAreaHeatmap"></div>
                </div>
                
                <div class="chart-container" id="occupancyBreakdownContainer" style="display: none;">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px;">
                        <h3 id="breakdownTitle">Occupancy Class Distribution</h3>
                        <p id="breakdownSubtitle">Click on a heatmap cell to see the breakdown</p>
                    </div>
                    <div id="occupancyBreakdownChart"></div>
                </div>
                
                <div class="chart-container">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px; border: none;">
                        <h3 style="color: #2c3e50;">Material Usage Trends Over Time</h3>
                        <p style="color: #555;">Normalized percentage of material types for new construction in each decade.</p>
                    </div>
                    <div class="controls" style="margin-bottom: 20px;">
                        <div class="control-group">
                            <label>Normalize By:</label>
                            <select id="materialTrendNormalizeBy" onchange="createMaterialTrendsChart()">
                                <option value="count">Building Count</option>
                                <option value="gfa">Est GFA (sqm)</option>
                            </select>
                        </div>
                    </div>
                    <div id="materialsTrendChart"></div>
                </div>

            </div>


            <div id="historicShoreline" class="section">
                <div class="section-header">
                    <h2>Boston's Historic Shoreline and Filled Land</h2>
                    <p>Visualizing buildings constructed on land reclaimed since 1630.</p>
                </div>
                
                <div class="info-box">
                    <h3>The Filling of Boston</h3>
                    <p>
                        The map of Boston has changed dramatically since its founding in 1630. Much of what is now considered central Boston was once tidal flats and marshes. 
                        Through extensive land reclamation projects over centuries, areas like Back Bay, the South End, and parts of Downtown were created from fill. 
                        This historic map shows the original 1630 shoreline, and the interactive map below displays modern buildings that now stand on this reclaimed land.
                    </p>
                </div>

                <div class="chart-container">
                    <h3>Historic Shoreline Map (c. 1630)</h3>
                    <img src="boston_shoreline_1630.png" alt="Historic Map of Boston Shoreline" style="width: 100%; height: auto; border-radius: 10px;">
                </div>
                
                <div class="section-header" style="margin-top: 40px;">
                    <h2>Buildings on Reclaimed Land</h2>
                    <p>An interactive map of structures located on areas that were filled after 1630.</p>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label>Filter by Occupancy:</label>
                        <select id="historicOccFilter" onchange="updateHistoricShorelineCharts()"></select>
                        
                        <label>Filter by Material:</label>
                        <select id="historicMaterialFilter" onchange="updateHistoricShorelineCharts()"></select>
                        
                        <label>Filter by Foundation:</label>
                        <select id="historicFoundationFilter" onchange="updateHistoricShorelineCharts()"></select>
                    </div>
                    <div class="control-group">
                        <label>Color Points By:</label>
                        <select id="historicColorBy" onchange="updateHistoricShorelineCharts()">
                            <option value="OCC_CLS">Occupancy Class</option>
                            <option value="material_type">Material Type</option>
                            <option value="foundation_type">Foundation Type</option>
                        </select>
                    </div>
                </div>

                <div class="map-container">
                    <div id="historicShorelineMapPlot"></div>
                </div>

                                <div class="stats-grid" style="margin-top: 30px; grid-template-columns: repeat(auto-fit, minmax(48%, 1fr));">
                    
                    <div class="chart-container">
                        <div id="historicOccupancyChart"></div>
                    </div>
                    
                    <div class="chart-container">
                        <div id="historicYearChart"></div>
                    </div>
                    
                    <div class="chart-container">
                        <div id="historicMaterialChart"></div>
                    </div>

                    <div class="chart-container">
                        <div id="historicFoundationChart"></div>
                    </div>
                </div>
            </div>

        <div id="foundationAnalysis" class="section">
                <div class="section-header">
                    <h2>Boston Foundation Type Analysis by Building Height</h2>
                    <p>Comprehensive analysis of foundation types on Original vs. Filled Land across height bins.</p>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="bf_total">Loading...</div>
                        <div class="stat-label">Total Boston Buildings</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #f8f9ff 0%, #f8f9ff 100%); color: white;">
                        <div class="stat-value" id="bf_shoreline">Loading...</div>
                        <div class="stat-label">Shoreline (Filled Land)</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #f8f9ff 0%, #f8f9ff 100%); color: white;">
                        <div class="stat-value" id="bf_original">Loading...</div>
                        <div class="stat-label">Original Land</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="bf_valid">Loading...</div>
                        <div class="stat-label">With Foundation Type</div>
                    </div>
                </div>

                <div class="info-box" style="margin-top: 20px; border-left-color: #0d0887; background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);">
                    <h3 style="color: #0d0887;">Methodology & Data Processing</h3>
                    <p><strong>CLF Foundation Type:</strong> CLF (Carbon Leadership Forum) is a non-profit organization that provides building embodied carbon data. The buildings_metadata.xlsx contains structural and foundation information for buildings across North America. Foundation types are grouped into CLF categories: Shallow foundation, Deep foundation &lt; 50' (15m), Deep foundation &gt; 50' (15m), and Other Foundation System.</p>
                    <p><strong>Shoreline Detection:</strong> Buildings are classified using the 1630 historic shoreline.</p>
                    <p><strong>Height Binning:</strong> Buildings are categorized into 5 bins based on height.</p>
                </div>

                <hr>

                <div class="chart-container">
                    <div class="section-header" style="border: none; margin-bottom: 15px;">
                        <h3 style="color: #2c3e50;">Section 1: Original Land vs Shoreline Land Comparison</h3>
                    </div>
                    <div class="controls">
                        <div class="control-group" style="display: block;">
                            <label style="margin-bottom: 8px; display: block;">Compare Height Bin:</label>
                            <div id="section1-bin-radios" class="radio-group-container"></div>
                        </div>
                        <div class="control-group" style="display: block; margin-top: 15px;">
                            <div class="toggle-switch" style="display: inline-flex; align-items: center;">
                                <label style="cursor:pointer; display: inline-flex; align-items: center;">
                                    <input type="checkbox" id="bf-collapse-toggle" onchange="toggleBFCollapseAsCLF()">
                                    <span style="font-weight:600; color:#555;"> Collapse as CLF Foundation</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <div id="section1-content" style="margin-top: 20px;">
                        <div class="comparison-grid">
                            <div class="panel">
                                <div class="panel-title" style="font-weight: 600; color: #0d0887; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; margin-bottom: 15px;">
                                    Original Land <span id="s1-orig-n" style="font-size: 0.85rem; color: #666; margin-left: 10px;"></span>
                                </div>
                                <div id="s1-orig-table"></div> 
                                <div id="s1-orig-bar" style="height: 450px; margin-top: 20px;"></div>
                                <div id="s1-orig-pie" style="height: 450px; margin-top: 20px;"></div>
                            </div>

                            <div class="panel">
                                <div class="panel-title" style="font-weight: 600; color: #cc4778; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; margin-bottom: 15px;">
                                    Shoreline Land <span id="s1-shore-n" style="font-size: 0.85rem; color: #666; margin-left: 10px;"></span>
                                </div>
                                <div id="s1-shore-table"></div> 
                                <div id="s1-shore-bar" style="height: 450px; margin-top: 20px;"></div>
                                <div id="s1-shore-pie" style="height: 450px; margin-top: 20px;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <hr>

                <div class="chart-container">
                    <div class="section-header" style="border: none; margin-bottom: 15px;">
                        <h3 style="color: #2c3e50;">Section 2: Height bin comparison within same land type</h3>
                    </div>
                    <div class="controls">
                        <div class="control-group" style="display: block;">
                            <label style="margin-bottom: 8px; display: block;">Land Type:</label>
                            <div id="section2-land-radios" class="radio-group-container"></div>
                        </div>
                        <div class="control-group" style="display: block; margin-top: 15px;">
                            <label style="margin-bottom: 8px; display: block;">Height Bin 1:</label>
                            <div id="section2-bin1-radios" class="radio-group-container"></div>
                        </div>

                        <div class="control-group" style="display: block; margin-top: 15px;">
                            <label style="margin-bottom: 8px; display: block;">Height Bin 2:</label>
                            <div id="section2-bin2-radios" class="radio-group-container"></div>
                        </div>
                    </div>

                    <div id="section2-content" style="margin-top: 20px;">
                        <div class="comparison-grid">
                            <div class="panel">
                                <div class="panel-title" style="font-weight: 600; margin-bottom: 15px;">
                                    Bin 1 Comparison <span id="s2-bin1-n" style="font-size: 0.85rem; color: #666;"></span>
                                </div>
                                <div id="s2-bin1-table"></div>
                                <div id="s2-bin1-bar" style="height: 450px; margin-top: 20px;"></div>
                                <div id="s2-bin1-pie" style="height: 450px; margin-top: 20px;"></div>
                            </div>

                            <div class="panel">
                                <div class="panel-title" style="font-weight: 600; margin-bottom: 15px;">
                                    Bin 2 Comparison <span id="s2-bin2-n" style="font-size: 0.85rem; color: #666;"></span>
                                </div>
                                <div id="s2-bin2-table"></div>
                                <div id="s2-bin2-bar" style="height: 450px; margin-top: 20px;"></div>
                                <div id="s2-bin2-pie" style="height: 450px; margin-top: 20px;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <hr>
                
                <div class="chart-container">
                     <div class="section-header collapsible" onclick="toggleBFSection3()" style="cursor: pointer;">
                        <h3 style="color: #2c3e50;">Section 3: Complete Data Overview (Click to Expand) <span id="s3-arrow">▶</span></h3>
                    </div>
                    <div id="section3-content" style="display: none;">
                        <h4 style="margin-top: 20px; color: #0d0887;">Original Land (Full Breakdown)</h4>
                        <div id="s3-orig-full-charts"></div> 
                        <hr style="margin: 30px 0;">
                        <h4 style="color: #cc4778;">Shoreline Land (Full Breakdown)</h4>
                        <div id="s3-shore-full-charts"></div>
                    </div>
                </div>

                <hr>

                <div class="chart-container">
                    <div class="section-header" style="border: none; margin-bottom: 15px;">
                        <h3 style="color: #2c3e50;">Section 4: CLF Metadata Height vs Foundation Analysis</h3>
                        <p style="color: #666; font-size: 0.9em;">Data source: CLF buildings_metadata.xlsx (covers all of North America)</p>
                    </div>
                    
                    <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 0.85em;">
                        <strong>Height Bin Mapping (CLF → Our Bins):</strong>
                        <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
                            <tr style="background: #eee;">
                                <th style="padding: 5px; text-align: left; border: 1px solid #ddd;">CLF Height Bin</th>
                                <th style="padding: 5px; text-align: left; border: 1px solid #ddd;">Our Height Bin</th>
                            </tr>
                            <tr><td style="padding: 5px; border: 1px solid #ddd;">0-7.5 m</td><td style="padding: 5px; border: 1px solid #ddd;">0-24 ft</td></tr>
                            <tr><td style="padding: 5px; border: 1px solid #ddd;">7.6-15 m</td><td style="padding: 5px; border: 1px solid #ddd;">24-72 ft</td></tr>
                            <tr><td style="padding: 5px; border: 1px solid #ddd;">15.1-22.5 m</td><td style="padding: 5px; border: 1px solid #ddd;">24-72 ft</td></tr>
                            <tr><td style="padding: 5px; border: 1px solid #ddd;">22.6-30 m</td><td style="padding: 5px; border: 1px solid #ddd;">72-147 ft</td></tr>
                            <tr><td style="padding: 5px; border: 1px solid #ddd;">31-45 m</td><td style="padding: 5px; border: 1px solid #ddd;">147+ ft</td></tr>
                            <tr><td style="padding: 5px; border: 1px solid #ddd;">46-60 m</td><td style="padding: 5px; border: 1px solid #ddd;">147+ ft</td></tr>
                            <tr><td style="padding: 5px; border: 1px solid #ddd;">61-90 m</td><td style="padding: 5px; border: 1px solid #ddd;">147+ ft</td></tr>
                            <tr><td style="padding: 5px; border: 1px solid #ddd;">Over 90 m</td><td style="padding: 5px; border: 1px solid #ddd;">147+ ft</td></tr>
                        </table>
                    </div>
                    
                    <div class="controls">
                        <div class="control-group" style="display: block;">
                            <label style="margin-bottom: 8px; display: block;">Height Bin 1:</label>
                            <div id="section4-bin1-radios" class="radio-group-container"></div>
                        </div>
                        <div class="control-group" style="display: block; margin-top: 15px;">
                            <label style="margin-bottom: 8px; display: block;">Height Bin 2:</label>
                            <div id="section4-bin2-radios" class="radio-group-container"></div>
                        </div>
                    </div>
                    
                    <div id="section4-content" style="margin-top: 20px;">
                        <p id="s4-total-info" style="color: #666; margin-bottom: 15px;"></p>
                        <div class="comparison-grid">
                            <div class="panel">
                                <div class="panel-title" style="font-weight: 600; margin-bottom: 15px;">
                                    Bin 1 <span id="s4-bin1-n" style="font-size: 0.85rem; color: #666;"></span>
                                </div>
                                <div id="s4-bin1-table"></div>
                                <div id="s4-bin1-bar" style="height: 450px; margin-top: 20px;"></div>
                                <div id="s4-bin1-pie" style="height: 450px; margin-top: 20px;"></div>
                            </div>
                            
                            <div class="panel">
                                <div class="panel-title" style="font-weight: 600; margin-bottom: 15px;">
                                    Bin 2 <span id="s4-bin2-n" style="font-size: 0.85rem; color: #666;"></span>
                                </div>
                                <div id="s4-bin2-table"></div>
                                <div id="s4-bin2-bar" style="height: 450px; margin-top: 20px;"></div>
                                <div id="s4-bin2-pie" style="height: 450px; margin-top: 20px;"></div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <div id="interactive" class="section">
                <div class="section-header">
                    <h2>Interactive Data Explorer</h2>
                    <p>Explore the data with custom filters and advanced visualizations (*Data from 75,000 random sampled data from 1.7M cleaned dataset)</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Year Range:</label>
                        <input type="number" id="yearStart" value="1900" min="1900" max="2024" style="width: 100px">
                        <span>to</span>
                        <input type="number" id="yearEnd" value="2024" min="1900" max="2024" style="width: 100px">
                    </div>
                    <div class="control-group">
                        <label>Est GFA Range (sqm):</label>
                        <input type="number" id="areaMin" value="0" min="0" style="width: 100px">
                        <span>to</span>
                        <input type="number" id="areaMax" value="10000" min="0" style="width: 100px">
                    </div>
                    <div class="control-group">
                        <label>Visualization:</label>
                        <select id="vizType">
                            <option value="box">Box Plot</option>
                            <option value="scatter3d">3D Scatter Plot</option>
                            <option value="sunburst">Sunburst Chart</option>
                            <option value="parallel">Parallel Coordinates</option>
                            <option value="violin">Violin Plot</option>
                            <option value="treemap">Treemap</option>
                        </select>
                        <button class="control-button" onclick="updateInteractiveExplorer()">Update Visualization</button>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="interactiveChart"></div>
                </div>
                
                <div class="info-box">
                    <h3>Tips for Interactive Explorer</h3>
                    <p>• 3D Scatter: Rotate with mouse, zoom with scroll wheel<br>
                       • Sunburst: Click segments to zoom in, click center to zoom out<br>
                       • Parallel Coordinates: Drag axes to reorder, brush to filter<br>
                       • All charts: Hover for details, double-click to reset view</p>
                </div>
            </div>
            
            <div id="clf" class="section">
                <div class="section-header">
                    <h2>CLF Data Analysis</h2>
                    <p>Analysis of Carbon Leadership Forum dataset for Massachusett</p>
                </div>

                <div class="info-box">
                    <h3>CLF Data Preprocessing</h3>
                    <p>This dataset originates from the New Construction MA Projects from the CLF building metadata, processed to be compatible with the NSI Enhanced USA Structure dataset. Key transformations include:</p>
                    
                    <h4 style="margin-top: 15px;">Occupancy Classification (OCC_CLS)</h4>
                    <p style="font-size: 0.9em; margin-bottom: 10px;">
                        Detailed CLF building uses were mapped to NSI Enhanced USA Structure dataset categories. 
                        <strong>This mapping is primarily based on the definitions from the USA Structure dataset's <code>PRIM_OCC</code> column.</strong>
                    </p>
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                        <thead style="background-color: #f0f4f8;">
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">CLF Building Use</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Mapped NSI Category (OCC_CLS)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Multifamily (5 or more units)</td><td style="border: 1px solid #ddd; padding: 8px;">Residential</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Lodging</td><td style="border: 1px solid #ddd; padding: 8px;">Residential</td></tr>
                            
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Office</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Mercantile</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Food Service</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Laboratory</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Healthcare</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Parking</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Commercial</td></tr>

                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Public Order and Safety</td><td style="border: 1px solid #ddd; padding: 8px;">Government</td></tr>
                            
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Warehouse and Storage</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Industrial</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Industrial</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Industrial</td></tr>

                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Public Assembly</td><td style="border: 1px solid #ddd; padding: 8px;">Assembly</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Religious Worship</td><td style="border: 1px solid #ddd; padding: 8px;">Assembly</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Transportation Hub</td><td style="border: 1px solid #ddd; padding: 8px;">Assembly</td></tr>
                            
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Education</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Education</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Other</td><td style="border: 1px solid #ddd; padding: 8px;">Utility and Misc</td></tr>
                        </tbody>
                    </table>

                    <h4 style="margin-top: 20px;">Material Type Encoding (material_type)</h4>
                    <p style="font-size: 0.9em; margin-bottom: 10px;">
                        CLF structural systems were mapped to single-letter codes. 
                        <strong>This mapping was inferred by combining several CLF columns: <code>str_prim_horiz_sys</code>, <code>str_prim_vert_sys</code>, <code>str_lat_sys</code>, and <code>str_sec_vert_sys</code>.</strong>
                    </p>
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                        <thead style="background-color: #f0f4f8;">
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">CLF Structural System</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Mapped Code (material_type)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Steel</td><td style="border: 1px solid #ddd; padding: 8px;">S</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Concrete</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">C</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Steel/Concrete</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">S</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Steel/Masonry</td><td style="border: 1px solid #ddd; padding: 8px;">S</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Wood: Mass Timber</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">W</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">Wood: Light-frame</td><td style="border: 1px solid #ddd; padding: 8px; background-color: #fdfdfd;">W</td></tr>
                            <tr><td style="border: 1px solid #ddd; padding: 8px;">Other</td><td style="border: 1px solid #ddd; padding: 8px;">H</td></tr>
                            <tr>
                                <td colspan="2" style="border: 1px solid #dddddd; padding: 8px; text-align: left; background-color: #9fc5af; font-style: italic;">
                                    M = Masonry, W = Wood, H = Manufactured, S = Steel, C = Concrete    (in NSI Enhanced USA Strucuture dataset)
                                </td>
                            </tr>
                        </tbody>
                    </table>

                    <h4 style="margin-top: 20px;">Other Key Transformations</h4>
                    <ul style="margin-left: 20px; margin-top: 10px; font-size: 0.9em; list-style-type: '→ '; padding-left: 15px;">
                        <li style="padding-left: 5px;"><code>bldg_compl_year</code> was mapped to <code>year_built</code></li>
                        <li style="padding-left: 5px; margin-top: 5px;"><code>bldg_cfa</code> was mapped to <code>Est GFA sqmeters</code></li>
                        <li style="padding-left: 5px; margin-top: 5px;"><code>str_fdn_type</code> was mapped to <code>general_fnd_type</code></li>
                        <li style="padding-left: 5px; margin-top: 5px;"><strong>Height Standardization:</strong> Text descriptions (e.g., "10-12 m") were converted to numeric averages (e.g., 11 in the HEIGHT column, which is in meters).</li>
                        <li style="padding-left: 5px; margin-top: 5px;"><strong>Data Cleaning:</strong> 2 Records with missing floor area data (Est GFA sqmeters) were removed.</li>

                        <li style="padding-left: 5px; margin-top: 5px;"><strong>Finally 16 projects from CLF are analyzed</strong> </li>
                    </ul>
                </div>

<div class="chart-container">
    <div class="section-header" style="border: none; margin-bottom: 20px;">
        <h3>Scatter Plot CLF MA Data Explorer</h3>
        <p>Compare GFA, Total Mass, and GWP, colored by Occupancy Class.</p>
    </div>

    <div class="controls" style="background: #f8f9fa;">
        
        <div class="control-group">
            <label for="clfXAxis">X-Axis:</label>
            <select id="clfXAxis" onchange="createCLFScatterPlot()">
                <option value="Est GFA sqmeters" selected>Est GFA (sqm)</option>
                <option value="mass_total">Total Mass</option>
                <option value="gwp_a_to_c">GWP (A-C)</option>
            </select>
            <label for="clfYAxis">Y-Axis:</label>
            <select id="clfYAxis" onchange="createCLFScatterPlot()">
                <option value="Est GFA sqmeters">Est GFA (sqm)</option>
                <option value="mass_total" selected>Total Mass</option>
                <option value="gwp_a_to_c">GWP (A-C)</option>
            </select>
        </div>
        
        <div class="control-group">
            <div class="toggle-switch">
                <label for="clfLogToggle">Use Log Scale:</label>
                <input type="checkbox" id="clfLogToggle" onchange="createCLFScatterPlot()" checked>
            </div>
        </div>

    </div> <div id="clfScatterPlot" style="min-height: 500px;"></div>

                <div class="chart-container">
                    <div class="section-header" style="border: none; margin-bottom: 10px;">
                        <h3>CLF Heatmap Analysis</h3>
                        <p>Correlation between foundation types and structural systems.</p>
                    </div>

                    <div class="heatmap-tabs" style="margin-bottom: 15px;">
                        <button class="heatmap-tab active" id="clfHeatmapTabCount" onclick="setCLFHeatmapMetric('count')">
                            By Building Count
                        </button>
                        <button class="heatmap-tab" id="clfHeatmapTabGFA" onclick="setCLFHeatmapMetric('gfa')">
                            By Total Est. GFA (sqm)
                        </button>
                    </div>

                    <div class="section-header" style="border: none; margin: 20px 0 10px 0; padding: 0;">
                        <h4 style="font-size: 1.2em;">Mapped Material Type vs. Foundation Type</h4>
                    </div>
                    <div id="clfHeatmap" style="min-height: 500px;"></div>
                    
                    <div class="section-header" style="border: none; margin: 30px 0 10px 0; padding: 0;">
                        <h4 style="font-size: 1.2em;">Original Structural System vs. Foundation Type</h4>
                    </div>
                    <div id="clfStructHeatmap" style="min-height: 500px;"></div>
                </div>

                <div class="chart-container">
                    <div class="section-header" style="border: none; margin-bottom: 20px;">
                        <h3>GFA Distribution: Main Dataset vs. CLF Dataset</h3>
                        <p>Comparison of Est GFA (sqm) by Occupancy Class. Boxes represent the main dataset (from 75,000 random sampled data from 1.7M cleaned dataset); 'x' markers represent the CLF dataset.</p>
                    </div>
                    <div id="clfBoxPlotOverlay" style="min-height: 500px;"></div>
                </div>

            </div>
            
            <div class="error-box" id="errorBox">
                <h3>Error Loading Data</h3>
                <p id="errorMessage">Unable to load building data. Please ensure building_data.json is in the same directory.</p>
            </div>
        
        </div>
    
    </div>
    
    <script>
        // Global variables for data
        let buildingData = null;
        let historicShorelineData = null;
        let clfData = null;
        let currentCLFHeatmapMetric = 'count';
        let isDataLoaded = false;
        let currentClusterK = 7;
        
        // Global variables for material selection
        let currentMaterialSelection = null;
        let currentOccupancyData = null;
        let currentHeatmapType = 'count';
        
        // Global variables for soil analysis
        let soilAnalysisData = null;
        let soilMapData = null;
        
        // Plasma colorscale
        const plasmaColorscale = 'Plasma';
        const plasmaColors = [
            '#0d0887', '#46039f', '#7201a8', '#9c179e', '#bd3786',
            '#d8576b', '#ed7953', '#fb9f3a', '#fdca26', '#f0f921'
        ];
        
        // Soil-specific colors
        const soilColors = {
            drainage: {
                'Well drained': '#2E7D32',
                'Moderately well drained': '#66BB6A',
                'Somewhat excessively drained': '#FDD835',
                'Poorly drained': '#FF9800',
                'Very poorly drained': '#E53935',
                'Excessively drained': '#1565C0'
            },
            flooding: {
                'Low': '#FDD835', 
                'Moderate': '#FF9800', 
                'High': '#E53935'
            },
            engineering: {
                'Favorable': '#2E7D32',
                'Fair': '#FDD835',
                'Poor': '#FF9800',
                'Very poor': '#E53935'
            }
        };
        
        // Material and Foundation type mappings
        const materialTypeMap = {
            'M': 'Masonry',
            'W': 'Wood',
            'H': 'Manufactured',
            'S': 'Steel',
            'C': 'Concrete'
        };
        
        const foundationTypeMap = {
            'C': 'Crawl Space',
            'B': 'Basement',
            'S': 'Slab',
            'P': 'Pier',
            'I': 'Pile',
            'F': 'Fill',
            'W': 'Solid Wall'
        };

        // CLF Foundation Type mapping - maps foundation types to CLF categories
        const CLF_FOUNDATION_MAP = {
            'Slab': 'Shallow foundation',
            'Crawl Space': 'Shallow foundation',
            'Basement': 'Shallow foundation',
            'Fill': 'Shallow foundation',
            'Pier': "Deep Foundation < 50' (15m)",
            'Pile': "Deep Foundation > 50' (15m)",
            'Solid Wall': 'Other Foundation System'
        };

        // CLF Foundation Type order for display
        const CLF_FOUNDATION_ORDER = [
            'Shallow foundation',
            "Deep Foundation < 50' (15m)",
            "Deep Foundation > 50' (15m)",
            'Other Foundation System'
        ];
        // Track collapse state for Boston Foundation Analysis
        let bfCollapseAsCLF = false;
        
        function getPlasmaColors(n) {
            if (n <= 10) return plasmaColors.slice(0, n);
            const colors = [];
            for (let i = 0; i < n; i++) {
                const idx = Math.floor(i * 9 / (n - 1));
                colors.push(plasmaColors[Math.min(idx, 9)]);
            }
            return colors;
        }
        
        window.addEventListener('error', function(event) {
            console.error('Error details:', event);
            return true;
        });

        const originalNewPlot = Plotly.newPlot;
        Plotly.newPlot = function(gd, data, layout, config) {
            try {
                if (Array.isArray(data)) {
                    data.forEach(trace => {
                        if (trace && trace.marker && typeof trace.marker === 'object') {
                            if (trace.marker.line === undefined) {
                                delete trace.marker.line;
                            }
                        }
                    });
                }
                return originalNewPlot.call(this, gd, data, layout, config);
            } catch (error) {
                console.error('Plotly error:', error);
                return Promise.resolve();
            }
        };

        document.addEventListener('DOMContentLoaded', function() {
            loadData();
            
            // Toggle material/foundation filter visibility
            document.getElementById('includeMaterial').addEventListener('change', function() {
                document.getElementById('materialTypeFilter').style.display = this.checked ? 'inline-block' : 'none';
                updateOccupancyClustering();
            });
            
            document.getElementById('includeFoundation').addEventListener('change', function() {
                document.getElementById('foundationTypeFilter').style.display = this.checked ? 'inline-block' : 'none';
                updateOccupancyClustering();
            });
            
            // NEW: re-render the Year→Occ→... Sankey when toggles change
            document.getElementById('toggleMaterial').addEventListener('change', createYearOccSankey);
            document.getElementById('toggleFoundation').addEventListener('change', createYearOccSankey);
            document.getElementById('toggleSoil').addEventListener('change', createYearOccSankey);

    
        });
        
        
        /**
         * FIXED: createYearSourceComparisonChart
         * 1. Fixed Date Range: 1630 to 2025 (Full History).
         * 2. Fixed Y-Axis Scale: Stable axis when toggling.
         * 3. Toggle Logic: Final Only vs. Sources Comparison.
         */
        function createYearSourceComparisonChart() {
            // 1. Get Data
            if (!buildingData || !buildingData.building_samples_random) {
                document.getElementById('yearSourceComparisonChartCount').innerHTML = '<p style="text-align:center; padding:40px;">No sample data available.</p>';
                return;
            }
            
            const samples = buildingData.building_samples_random;
            
            // Safety Check
            if (samples.length > 0 && samples[0].massgis_yr_built === undefined) {
                document.getElementById('yearSourceComparisonChartCount').innerHTML = '<div class="warning-box"><p>Missing column: <code>massgis_yr_built</code>. Please update data processor.</p></div>';
                return;
            }

            // 2. Get Control State
            const showFinalOnly = document.getElementById('toggleShowFinal').checked;

            // 3. Filter Helpers & Config
            // CHANGED: Start from 1630
            const START_YEAR = 1630;
            const END_YEAR = 2025;
            
            const validYear = (y) => y >= START_YEAR && y <= END_YEAR;
            const getGFA = (d) => d['Est GFA sqmeters'] || 0;
            
            // Histogram Bin Settings
            const commonBinSettings = { start: START_YEAR, end: END_YEAR, size: 5 }; 

            // --- 4. PRE-CALCULATE GLOBAL MAX Y (To fix axis scale) ---
            // We need to calculate the max height across the FULL range (1630-2025)
            
            function calculateMaxBinHeight(dataKey, isGFA) {
                const bins = {};
                samples.forEach(d => {
                    const yr = d[dataKey];
                    if (validYear(yr)) {
                        // Binning logic: Floor to nearest 5
                        const bin = Math.floor(yr / 5) * 5;
                        const val = isGFA ? getGFA(d) : 1;
                        bins[bin] = (bins[bin] || 0) + val;
                    }
                });
                const values = Object.values(bins);
                return values.length ? Math.max(...values) : 0;
            }

            // Calculate global maximums (add 10% headroom for better visuals)
            const maxCount = Math.max(
                calculateMaxBinHeight('massgis_yr_built', false),
                calculateMaxBinHeight('nsi_yr_built', false),
                calculateMaxBinHeight('year_built', false)
            ) * 1.1;

            const maxGFA = Math.max(
                calculateMaxBinHeight('massgis_yr_built', true),
                calculateMaxBinHeight('nsi_yr_built', true),
                calculateMaxBinHeight('year_built', true)
            ) * 1.1;

            // 5. Build Traces based on Toggle
            const tracesCount = [];
            const tracesGFA = [];

            // Helper to add a trace
            const addTrace = (xKey, name, color, opacity) => {
                const filteredData = samples.filter(d => validYear(d[xKey]));
                
                const props = {
                    type: 'histogram',
                    autobinx: false, 
                    xbins: commonBinSettings,
                    opacity: opacity,
                    marker: { color: color, line: { width: 1, color: 'white' } }
                };

                // Count Trace
                tracesCount.push({
                    ...props,
                    x: filteredData.map(d => d[xKey]),
                    name: name,
                    hovertemplate: `${name}: %{x}<br>Count: %{y:,}<extra></extra>`
                });

                // GFA Trace
                tracesGFA.push({
                    ...props,
                    x: filteredData.map(d => d[xKey]),
                    y: filteredData.map(getGFA),
                    histfunc: 'sum',
                    name: name,
                    hovertemplate: `${name}: %{x}<br>GFA: %{y:,.0f} sqm<extra></extra>`
                });
            };

            if (showFinalOnly) {
                // MODE B: FINAL RESULT ONLY (Opaque Green)
                addTrace('year_built', 'Final Dataset (Cleaned)', '#2E7D32', 0.85);
            } else {
                // MODE A: SOURCE COMPARISON (Transparent Overlap)
                addTrace('massgis_yr_built', 'MassGIS (Original)', '#fb9f3a', 0.6);
                addTrace('nsi_yr_built', 'NSI (Original)', '#764ba2', 0.6);
            }

            // 6. Layouts with FIXED Y-AXIS RANGE
            const baseLayout = {
                xaxis: { 
                    title: 'Year Built', 
                    range: [START_YEAR, END_YEAR] // CHANGED: 1630 - 2025
                },
                barmode: 'overlay',
                height: 450,
                margin: { t: 40, b: 40 },
                hovermode: 'x unified',
                legend: { x: 0.01, y: 0.99, bgcolor: 'rgba(255,255,255,0.8)' }
            };

            const titleSuffix = showFinalOnly ? '(Final Cleaned)' : '(Original Sources)';

            const layoutCount = { 
                ...baseLayout, 
                title: { text: `Building Count Distribution ${titleSuffix}`, font: { size: 18, color: '#333' } }, 
                yaxis: { 
                    title: 'Number of Buildings',
                    range: [0, maxCount] // FIXED SCALE
                } 
            };
            
            const layoutGFA = { 
                ...baseLayout, 
                title: { text: `Total Est. GFA Distribution ${titleSuffix}`, font: { size: 18, color: '#333' } }, 
                yaxis: { 
                    title: 'Total Est GFA (sqm)',
                    range: [0, maxGFA] // FIXED SCALE
                } 
            };

            // 7. Render
            Plotly.newPlot('yearSourceComparisonChartCount', tracesCount, layoutCount, {responsive: true});
            Plotly.newPlot('yearSourceComparisonChartGFA', tracesGFA, layoutGFA, {responsive: true});
        }

        // NEW: Data Pipelines Section Functions
        function createDataPipelinesDiagrams() {
            // This function calls all the necessary functions to build the charts in the "Data Pipelines" section.
            createNSIDataSourcesSankey();
            createOccupancyHierarchySankey();
            createOccClsOccDictSankey();
            createDataCleaningSankey();
            createBuildingDistributionSankey(); // This will call the function we previously fixed.
            createYearOccSankey();
            createYearSourceComparisonChart();
        }

        
        const stage1Stats = {
        strategy1: {
            mixed_use_single_family_flagged: 15638,
            matched_single_family_one_to_one: 1112984,
            matched_single_family_aggregated: 21283
        },
        strategy2: { matched_multiunit_commercial: 366340 },
        funnel: {
            initial: { nsi_points: 2095529, usa_polygons: 2091488 },
            after_pip: { unmatched_nsi_points: 423281, unmatched_usa_polygons: 590881 }, // Stages 1 & 2
            after_buffer: { final_unmatched_nsi_points: 183289, final_unmatched_usa_polygons: 405037 } // Stage 3
        },
        occupancy_conflicts: 146184,
        performance: {
            total_buildings: 2091488,
            buildings_matched: 1686451,
            buildings_with_occupancy_conflict: 86817,
            final_match_rate: 80.63
        },
        match_type_distribution: [
            ["residential_single_point", 1100668, "65.27%"],
            ["multi_unit_aggregated", 357852, "21.22%"],
            ["buffer_attach", 185844, "11.02%"],
            ["residential_aggregated", 20255, "1.20%"],
            ["buffer_attach|residential_single_point", 12316, "0.73%"],
            ["buffer_attach|multi_unit_aggregated", 8488, "0.50%"],
            ["buffer_attach|residential_aggregated", 1028, "0.06%"]
        ]
        };


        function renderStage1Metrics(stats){
        const mount = document.getElementById('stage1MetricsMount');
        if (!mount) return;
        const fmt = n => Number(n).toLocaleString();

        mount.innerHTML = `
        <details open>
            <summary><strong>Strategy 1: intelligent matching for single-family homes</strong></summary>
            <ul>
            <li>single-family buildings flagged as mixed-use (indoor RES+non-RES): ${fmt(stats.strategy1.mixed_use_single_family_flagged)}</li>
            <li>matched single-family buildings (1-to-1): ${fmt(stats.strategy1.matched_single_family_one_to_one)}</li>
            <li>matched single-family buildings (aggregated): ${fmt(stats.strategy1.matched_single_family_aggregated)}</li>
            </ul>
        </details>

        <details open>
            <summary><strong>Strategy 2: multi-unit/commercial aggregated matching</strong></summary>
            <ul>
            <li>matched multi-unit/commercial buildings: ${fmt(stats.strategy2.matched_multiunit_commercial)}</li>
            </ul>
        </details>

        <details open>
            <summary><strong>Match Funnel & Unmatched Entity Report</strong></summary>
            <div class="funnel-grid">
                <div class="funnel-block">
                <em>Initial State</em>
                <div>– Total NSI Points: ${fmt(stats.funnel.initial.nsi_points)}</div>
                <div>– Total USA Polygons: ${fmt(stats.funnel.initial.usa_polygons)}</div>
                </div>
                <div class="funnel-block">
                <em>After Stages 1 & 2</em>
                <div>– Remaining Unmatched NSI Points: ${fmt(stats.funnel.after_pip.unmatched_nsi_points)}</div>
                <div>– Remaining Unmatched USA Polygons: ${fmt(stats.funnel.after_pip.unmatched_usa_polygons)}</div>
                </div>
                <div class="funnel-block span-2">
                <em>After Buffer/Nearest Neighbor (Stage 3)</em>
                <div>– Final Unmatched NSI Points: ${fmt(stats.funnel.after_buffer.final_unmatched_nsi_points)}</div>
                <div>– Final Unmatched USA Polygons: ${fmt(stats.funnel.after_buffer.final_unmatched_usa_polygons)}</div>
                </div>
            </div>
        </details>

        <details open>
            <summary><strong>Occupancy Conflict Report</strong></summary>
            <div>Total Occupancy Conflicts Detected: ${fmt(stats.occupancy_conflicts)}</div>
        </details>

        <details open>
            <summary><strong>Overall Match Performance</strong></summary>
            <ul>
            <li>Total Number of Buildings in Dataset: ${fmt(stats.performance.total_buildings)}</li>
            <li>Total Buildings with a Successful Match: ${fmt(stats.performance.buildings_matched)}</li>
            <li>Total Buildings with Occupancy Conflict: ${fmt(stats.performance.buildings_with_occupancy_conflict)}</li>
            <li>Final Match Rate: ${stats.performance.final_match_rate}%</li>
            </ul>
        </details>

        <details>
            <summary><strong>Match Type Distribution</strong></summary>
            <div id="matchTypeTable"></div>
        </details>
        `;

    
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'collapse';
        table.innerHTML = `
            <thead><tr>
            <th style="text-align:left;padding:6px;border-bottom:1px solid #ddd;">Match type</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;">Count</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;">Share</th>
            </tr></thead>
            <tbody>
            ${stats.match_type_distribution.map(([label, count, pct]) => `
                <tr>
                <td style="padding:6px;border-bottom:1px solid #eee;">${label}</td>
                <td style="padding:6px;border-bottom:1px solid #eee;text-align:right;">${fmt(count)}</td>
                <td style="padding:6px;border-bottom:1px solid #eee;text-align:right;">${pct}</td>
                </tr>`).join('')}
            </tbody>`;
        document.getElementById('matchTypeTable').appendChild(table);
        }


        document.addEventListener('DOMContentLoaded', () => renderStage1Metrics(stage1Stats));


        document.addEventListener('DOMContentLoaded', function() {
            const triggers = document.querySelectorAll('.collapsible-trigger');

            triggers.forEach(trigger => {
                const icon = trigger.querySelector('.collapse-icon');
                icon.style.transform = 'rotate(-90deg)'; 
            });

            triggers.forEach(trigger => {
                trigger.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const icon = this.querySelector('.collapse-icon');

                    this.classList.toggle('active');
                    content.classList.toggle('active');

                    if (content.classList.contains('active')) {
                        icon.style.transform = 'rotate(0deg)'; 
                    } else {
                        icon.style.transform = 'rotate(-90deg)'; 
                    }
                });
            });
        });

        function createNSIDataSourcesSankey() {
            // This function creates the Sankey diagram showing the sources of NSI data (Lightbox vs. HAZUS).
            // These are hardcoded values representing the general NSI methodology.
            const totalRecords = 2542265;
            const materialFromLightbox = 1208023;
            const foundationFromLightbox = 54497;
            const materialPredicted = totalRecords - materialFromLightbox;
            const foundationPredicted = totalRecords - foundationFromLightbox;
            
            const sankeyData = [{
                type: 'sankey',
                orientation: 'h',
                node: {
                    pad: 15,
                    thickness: 30,
                    line: { color: 'white', width: 2 },
                    label: [
                        'Building Material', // Index 0
                        'Foundation Type', // Index 1
                        'Material from Lightbox<br>(47.52%)', // Index 2
                        'Material Predicted by NSI, using HAZUS Table<br>(52.48%)', // Index 3
                        'Foundation from Lightbox<br>(2.14%)', // Index 4
                        'Foundation Predicted by NSI, using HAZUS Table<br>(97.86%)'  // Index 5
                    ],
                    color: ['#bd3786', '#f5576c', '#4facfe', '#fa709a', '#4facfe', '#fa709a']
                },
                link: {
                    source: [0, 0, 1, 1],
                    target: [2, 3, 4, 5],
                    value: [materialFromLightbox, materialPredicted, foundationFromLightbox, foundationPredicted],
                    color: ['#4facfe40', '#fa709a40', '#4facfe40', '#fa709a40']
                }
            }];
            
            const layout = {
                title: { text: 'NSI Data Sources: Lightbox vs HAZUS Predictions', font: { size: 18, color: '#333' } },
                font: { size: 12 },
                height: 500
            };
            
            Plotly.newPlot('nsiDataSourcesSankey', sankeyData, layout, {responsive: true});
        }

        function createOccupancyHierarchySankey() {
                    if (!buildingData || !buildingData.occupancy_hierarchy_sankey) {
                        console.warn('No occupancy hierarchy data available');
                        document.getElementById('occupancyHierarchySankey').innerHTML = '<p>Occupancy hierarchy data not available.</p>';
                        return;
                    }

                    const data = buildingData.occupancy_hierarchy_sankey;
                    
                    const occClsNodes = data.nodes.filter(n => n.name.endsWith(' (Class)'));
                    
                    const baseColors = getPlasmaColors(occClsNodes.length);
                    const occClsColorMap = {};
                    occClsNodes.forEach((node, index) => {
                        occClsColorMap[node.name] = baseColors[index];
                    });
                    
                    const nodeColors = data.nodes.map(node => occClsColorMap[node.name] || '#cccccc');
                    const linkColors = data.links.source.map(sourceIndex => {
                        const sourceNodeName = data.nodes[sourceIndex].name;
                        const color = occClsColorMap[sourceNodeName] || '#cccccc';
                        return color.replace(')', ', 0.4)').replace('rgb', 'rgba');
                    });
                    
                    const originalValues = data.links.value;


                    const scaledValues = originalValues.map(v => Math.sqrt(v));

                    const originalNodeTotals = Array(data.nodes.length).fill(0);
                    data.links.source.forEach((sourceIndex, i) => {
                        const targetIndex = data.links.target[i];
                        const value = originalValues[i];
                        originalNodeTotals[sourceIndex] += value;
                        originalNodeTotals[targetIndex] += value;
                    });

                    const sankeyData = [{
                        type: 'sankey',
                        orientation: 'h',
                        node: {
                            pad: 20,
                            thickness: 20,
                            line: { color: 'white', width: 1.5 },
                            label: data.nodes.map(n => n.name),
                            color: nodeColors,
                            customdata: originalNodeTotals,
                            hovertemplate: '<b>%{label}</b><br>Total Count: %{customdata:,}<extra></extra>'
                        },
                        link: {
                            source: data.links.source,
                            target: data.links.target,
                            value: scaledValues,
                            color: linkColors,
                            customdata: originalValues,
                            hovertemplate: '%{source.label} → %{target.label}<br><b>Count: %{customdata:,}</b><extra></extra>'
                        }
                    }];

                    const layout = {
                        title: {
                            text: 'Flow from Occupancy Class to Primary Occupancy',
                            font: { size: 18, color: '#333' }
                        },
                        font: { size: 10 },

                        height: 1200 
                    };

                    Plotly.newPlot('occupancyHierarchySankey', sankeyData, layout, {responsive: true});
                }

        // Build OCC_CLS → NSI occtype sankey.
        // Prefer pre-aggregated data from Python (buildingData.occ_cls_occ_dict_sankey).
        // Fallback to compute from samples only if aggregation is missing.
        function createOccClsOccDictSankey() {
        const container = document.getElementById('occClsOccDictSankey');
        if (!container) return;

        if (!buildingData) {
            container.innerHTML = '<p>Data not loaded.</p>';
            return;
        }

        // ---------- 1) Preferred: use pre-aggregated data ----------
        const aggPack = buildingData.occ_cls_occ_dict_sankey;
        // use POINTS (sum within each class pool) as the default
        const agg = aggPack?.by_points || aggPack?.by_buildings;


        if (agg && agg.nodes && agg.links && Array.isArray(agg.nodes) && agg.nodes.length) {
        const nodes  = agg.nodes.map(n => n.name || n.label || String(n));
        const sources = agg.links.source;
        const targets = agg.links.target;
        const values  = agg.links.value;

        // Color left-side OCC_CLS nodes consistently; links fade with same color
        const leftOccNodes = nodes
            .map((label, idx) => ({ label, idx }))
            .filter(n => n.label && n.label.endsWith('(Class)'));

        const baseColors = getPlasmaColors(leftOccNodes.length);
        const colorMap = {};
        leftOccNodes.forEach((n, i) => { colorMap[n.label] = baseColors[i]; });

        const nodeColors = nodes.map(lbl => colorMap[lbl] || '#cccccc');

        const linkColors = sources.map(si => {
            const srcName = nodes[si];
            const c = colorMap[srcName] || 'rgb(180,180,180)';
            // rgba fade
            return c.replace(')', ', 0.35)').replace('rgb', 'rgba');
        });

            // Square-root scaling for visual balancing (hover shows original)
            const scaled = values.map(v => Math.sqrt(v));

        // MODIFICATION START: Calculate correct totals for each node's tooltip
                const originalValues = values; // Keep the original link values safe
                const originalNodeTotals = Array(nodes.length).fill(0);
                
                sources.forEach((sourceIndex, i) => {
                    const targetIndex = targets[i];
                    const value = originalValues[i];
                    originalNodeTotals[sourceIndex] += value;
                    originalNodeTotals[targetIndex] += value;
                });
                // MODIFICATION END

                const sankeyData = [{
                    type: 'sankey',
                    orientation: 'h',
                    node: {
                        pad: 15,
                        thickness: 24,
                        line: { color: 'white', width: 1.5 },
                        label: nodes,
                        color: nodeColors,
                        // Use the correctly calculated node totals for the tooltip
                        customdata: originalNodeTotals,
                        hovertemplate: '<b>%{label}</b><br>Total Points: %{customdata:,}<extra></extra>'
                    },
                    link: {
                        source: sources,
                        target: targets,
                        value: scaled,
                        color: linkColors,
                        // Use the original link values for the link's tooltip
                        customdata: originalValues,
                        hovertemplate: '%{source.label} → %{target.label}<br><b>Points: %{customdata:,}</b><extra></extra>'
                    }
                }];

    // MODIFICATION START: Increase height and adjust layout for clarity
            const layout = {
                title: { text: 'OCC_CLS → NSI occtype matches', font: { size: 18, color: '#333' } },
                font: { size: 10 }, // Slightly smaller font for right-side labels
                height: 1200,       // Significantly increased height to give nodes more space
                margin: {
                    l: 150, // Add some left margin for long class names
                    r: 200  // Add right margin for the new long labels
                }
            };

            // Also, let's adjust the node padding in the sankeyData definition itself
            if (sankeyData[0] && sankeyData[0].node) {
                sankeyData[0].node.pad = 15; // Adjust vertical padding between nodes
            }
            // MODIFICATION END

            Plotly.newPlot('occClsOccDictSankey', sankeyData, layout, {responsive: true});
            return;
        }

        // ---------- 2) Fallback: compute from samples if aggregation missing ----------
        let samples = [];
        if (Array.isArray(buildingData.building_samples_balanced) && buildingData.building_samples_balanced.length) {
        samples = buildingData.building_samples_balanced;
        } else if (Array.isArray(buildingData.building_samples_random) && buildingData.building_samples_random.length) {
        samples = buildingData.building_samples_random;
        }
        if (!samples.length) {
        container.innerHTML = '<p>No aggregated data or samples available.</p>';
        return;
        }
        if (Array.isArray(samples[0])) samples = samples.flat();

        // parse "OCC_DICT": "RES: 1, COM: 0, IND: 3, ..."  → sum POSITIVE values per (OCC_CLS, occtype)
        const toInt = (v) => {
        if (typeof v === 'number') return v;
        const n = parseInt(String(v || '').replace(/[^0-9-]/g, ''), 10);
        return Number.isFinite(n) ? n : 0;
        };

        const occPoints = Object.create(null); // key: `${occ}|||${type}` -> total points (sum of values > 0)
        const occSet = new Set();
        const typeSet = new Set();

        for (const row of samples) {
        const occ = row.OCC_CLS || 'Unknown';
        occSet.add(occ);

        const dictRaw = row.OCC_DICT || '';
        const parts = String(dictRaw).split(',').map(s => s.trim()).filter(Boolean);

        for (const p of parts) {
            const m = p.match(/^([A-Z]+)\s*:\s*(-?\d+)/i);
            if (!m) continue;
            const key = m[1].toUpperCase();   // e.g. RES/COM/IND/GOV/EDU/REL/...
            const val = toInt(m[2]);

            if (val > 0) {
            typeSet.add(key);
            const k = `${occ}|||${key}`;
            occPoints[k] = (occPoints[k] || 0) + val;  // SUM points in this OCC_CLS pool
            }
        }
        }

        // build nodes and links
        const occList = [...occSet].sort();
        const typeList = [...typeSet].sort();

        const nodeLabels = [
        ...occList.map(o => `${o} (Class)`),
        ...typeList.map(t => `${t} (NSI occtype)`)
        ];
        const nodeIndex = new Map(nodeLabels.map((lbl, i) => [lbl, i]));

        const links = { source: [], target: [], value: [] };
        Object.entries(occPoints).forEach(([k, v]) => {
        const [occ, t] = k.split('|||');
        const s = nodeIndex.get(`${occ} (Class)`);
        const tIdx = nodeIndex.get(`${t} (NSI occtype)`);
        if (s != null && tIdx != null && v > 0) {
            links.source.push(s);
            links.target.push(tIdx);
            links.value.push(v);
        }
        });

        // coloring: left side class color; links use faded source color
        const baseColors = getPlasmaColors(occList.length);
        const colorMap = {};
        occList.forEach((o, i) => colorMap[`${o} (Class)`] = baseColors[i]);

        const nodeColors = nodeLabels.map(lbl => colorMap[lbl] || '#cccccc');
        const linkColors = links.source.map(si => {
        const lbl = nodeLabels[si];
        const c = colorMap[lbl] || 'rgb(180,180,180)';
        return c.replace(')', ', 0.35)').replace('rgb', 'rgba');
        });

        // optional visual scaling (square root) to reduce dominance of very large flows
        const scaled = links.value.map(v => Math.sqrt(v));

        const data = [{
        type: 'sankey',
        orientation: 'h',
        node: {
            pad: 18,
            thickness: 24,
            line: { color: 'white', width: 1.5 },
            label: nodeLabels,
            color: nodeColors,
            hovertemplate: '<b>%{label}</b><extra></extra>'
        },
        link: {
            source: links.source,
            target: links.target,
            value: scaled,
            color: linkColors,
            customdata: links.value,
            hovertemplate: '%{source.label} → %{target.label}<br><b>Points: %{customdata:,}</b><extra></extra>'
        }
        }];

        Plotly.newPlot('occClsOccDictSankey', data, {
        title: { text: 'OCC_CLS → NSI occtype matches (by points)', font: { size: 18, color: '#333' } },
        font: { size: 11 },
        height: 520
        }, {responsive: true});

        }


        
        function createDataCleaningSankey() {
            const cleaningData = buildingData.data_flow_stats?.cleaning_pipeline;
            
            if (!cleaningData) {
                console.warn('No cleaning pipeline data found, using fallback values');
                createFallbackDataCleaningSankey();
                return;
            }
            
            function formatCount(num) {
                if (num === undefined || num === null) return 'N/A'; 
                if (num >= 1000000) return `${(num / 1000000).toFixed(2)}M`;
                if (num >= 10000) return `${(num / 1000).toFixed(1)}K`;
                if (num >= 1000) return `${(num / 1000).toFixed(2)}K`;
                return num.toString();
            }
            
            // --- 1. Retrieve variables ---
            const rawData = cleaningData.initial_count;
            
            // Step 1: Year
            const invalidYear = cleaningData.invalid_year_count;
            const afterYearFilter = cleaningData.after_year_filter;
            
            // Step 2: Material & Foundation (NEW)
            const missingMatFound = cleaningData.missing_mat_found_count || 0;

            const afterMatFoundFilter = cleaningData.after_mat_found_filter || afterYearFilter;
            
            // Step 3: Area
            const missingArea = cleaningData.missing_area_count;
            const afterMissingArea = cleaningData.after_missing_area;
            
            // Step 4: Height
            const invalidRawHeight = cleaningData.invalid_raw_height_count || 0;
            const invalidAssumedHeight = cleaningData.invalid_assumed_height_count || 0;

            const finalCleaned = cleaningData.final_count;
            
            // --- 2. Update node labels ---
            const sankeyData = [{
                type: 'sankey',
                orientation: 'h',
                node: {
                    pad: 15, thickness: 30, line: { color: 'white', width: 2 },
                    label: [
                        `Raw Data<br>(${formatCount(rawData)})`,                  // 0
                        `Invalid Year<br>(${formatCount(invalidYear)})`,            // 1
                        `After Year Filter<br>(${formatCount(afterYearFilter)})`,   // 2
                        
                        `Missing Mat/Found Type(Unmatched USA Structure polygons)<br>(${formatCount(missingMatFound)})`,   // 3 [NEW]
                        `After Mat/Found Type Filter(Unmatched USA Structure polygons)<br>(${formatCount(afterMatFoundFilter)})`, // 4 [NEW]
                        
                        `Missing Area(Est GFA sqmeters)<br>(${formatCount(missingArea)})`,            // 5
                        `After Area Filter(Est GFA sqmeters)<br>(${formatCount(afterMissingArea)})`,  // 6
                        
                        `Invalid Raw Height(HEIGHT <= 0)<br>(${formatCount(invalidRawHeight)})`,      // 7
                        `Invalid Assumed Height(PRED_HEIGHT <= 0)<br>(${formatCount(invalidAssumedHeight)})`, // 8
                        `Final Dataset<br>(${formatCount(finalCleaned)})`           // 9
                    ],
                    color: [
                        '#667eea',   // 0: Raw
                        '#E53935',   // 1: Removed Year
                        '#764ba2',   // 2: After Year
                        
                        '#E53935',   // 3: Removed Mat/Found [RED]
                        '#9c179e',   // 4: After Mat/Found [Purple]
                        
                        '#E53935',   // 5: Removed Area
                        '#bd3786',   // 6: After Area
                        
                        '#E53935',   // 7: Removed Raw H
                        '#E53935',   // 8: Removed Assumed H
                        '#2E7D32'    // 9: Final [Green]
                    ]
                },
                link: {
                    // Flow: Raw -> Year -> Mat/Found -> Area -> Height -> Final
                    source: [0, 0, 2, 2, 4, 4, 6, 6, 6],
                    target: [1, 2, 3, 4, 5, 6, 7, 8, 9],
                    value:  [
                        invalidYear, afterYearFilter,      // From Raw
                        missingMatFound, afterMatFoundFilter, // From Year Filtered
                        missingArea, afterMissingArea,     // From Mat/Found Filtered
                        invalidRawHeight, invalidAssumedHeight, finalCleaned // From Area Filtered
                    ],
                    color:  [
                        '#E5393540', '#764ba240', // 0->
                        '#E5393540', '#9c179e40', // 2->
                        '#E5393540', '#bd378640', // 4->
                        '#E5393540', '#E5393540', '#2E7D3240' // 6->
                    ]
                }
            }];
            
            const layout = {
                title: { text: `Data Cleaning Pipeline`, font: { size: 18, color: '#333' } },
                font: { size: 10 }, height: 550,
                annotations: [{
                    x: 0.5, y: -0.1, xref: 'paper', yref: 'paper',
                    text: `Total removed: ${formatCount(cleaningData.total_removed)} records`,
                    showarrow: false, font: { size: 14, color: '#666' }
                }]
            };
            
            Plotly.newPlot('dataCleaningSankey', sankeyData, layout, {responsive: true});
        }

        function createClusterMap() {
            if (!buildingData || !buildingData.building_samples_random) return;


            const samples = buildingData.building_samples_random.map(s => ({
                ...s,
                displayCluster: s[`cluster_base_k${currentClusterK}`]
            })).filter(s => 
                s.displayCluster !== undefined && s.displayCluster !== null && 
                s.LATITUDE && s.LONGITUDE 
            );

            const mapSamples = samples.length > 75000 ? samples.slice(0, 75000) : samples;

            const traces = [];

            for (let i = 0; i < currentClusterK; i++) {
                const clusterPoints = mapSamples.filter(s => s.displayCluster === i);
                
                if (clusterPoints.length === 0) continue;

                const color = plasmaColors[i % plasmaColors.length];

                traces.push({
                    type: 'scattermapbox',
                    mode: 'markers',
                    lon: clusterPoints.map(p => p.LONGITUDE),
                    lat: clusterPoints.map(p => p.LATITUDE),
                    marker: {
                        size: 6,
                        color: color,
                        opacity: 0.6
                    },
                    name: `Cluster ${i + 1}`,
                    text: clusterPoints.map(p => 
                        `<b>Cluster ${i + 1}</b><br>` + 
                        `GFA: ${Math.round(p['Est GFA sqmeters'])} sqm<br>` +
                        `Year: ${p.year_built}<br>` + 
                        `Occ: ${p.OCC_CLS}`
                    ),
                    hovertemplate: '%{text}<extra></extra>'
                });
            }

            const layout = {
                title: {
                    text: `Spatial Distribution of Clusters with 75,000 samples (K=${currentClusterK})`,
                    font: { size: 18, color: '#333' }
                },
                mapbox: {
                    style: 'open-street-map',
                    center: { lat: 42.3601, lon: -71.0589 },
                    zoom: 8
                },
                height: 600,
                margin: { t: 50, b: 0, l: 0, r: 0 },
                showlegend: true,
                legend: {
                    bgcolor: 'rgba(255,255,255,0.9)',
                    bordercolor: '#ccc',
                    borderwidth: 1
                }
            };

            Plotly.newPlot('clusterMapPlot', traces, layout, {responsive: true});
        }

        
        function createFallbackDataCleaningSankey() {
            // This is a fallback function in case the main data fails to provide cleaning stats.
            // It uses hardcoded placeholder data.
            console.log("Using fallback for data cleaning Sankey.");
            // (Implementation of a simple placeholder chart would go here)
            document.getElementById('dataCleaningSankey').innerHTML = '<p>Data cleaning statistics are not available.</p>';
        }
        
        function createBuildingDistributionSankey() {
        // This function creates the hierarchical Sankey diagram.
        // It supports four views, including simplified versions for both count and GFA,
        // and now includes a compact (screenshot) mode to reduce height and spacing.

        if (!buildingData || !buildingData.hierarchical_distribution) {
            console.warn('No hierarchical distribution data available');
            return;
        }

        // UI: compact (screenshot) mode toggle. If the checkbox is absent, default to true.
        const compact = document.getElementById('toggleCompact')?.checked ?? true;
        const UI = compact ? {
            NODE_PAD: 10,
            NODE_THICKNESS: 14,
            LINE_WIDTH: 1.2,
            FONT_SIZE: 10,
            TITLE_SIZE: 16,
            HEIGHT: 520,
            MARGINS: { t: 56, b: 120, l: 110, r: 110 } // keep some bottom space for annotations
        } : {
            NODE_PAD: 20,
            NODE_THICKNESS: 25,
            LINE_WIDTH: 1.5,
            FONT_SIZE: 11,
            TITLE_SIZE: 18,
            HEIGHT: 800,
            MARGINS: { t: 80, b: 200, l: 150, r: 150 }
        };

        // Get user selections from the dropdowns
        const selectedOccupancy = document.getElementById('hierarchicalOccupancy')?.value || 'all';
        const selectedView = document.getElementById('sankeyViewSelector')?.value || 'by_count';

        // Select the correct data structure based on occupancy and view selection
        let dataForOccupancy = buildingData.hierarchical_distribution[selectedOccupancy];
        if (!dataForOccupancy) {
            console.warn(`No data for occupancy: ${selectedOccupancy}`);
            document.getElementById('buildingDistributionSankey').innerHTML = '<p>No data to display for this occupancy class.</p>';
            return;
        }

        let sankeyData = dataForOccupancy[selectedView];
        if (!sankeyData || !sankeyData.nodes || !sankeyData.links || sankeyData.nodes.length === 0) {
            console.warn(`No data for view: ${selectedView}`);
            document.getElementById('buildingDistributionSankey').innerHTML = '<p>No data to display for this view (Not enough buildings to generate a flow chart).</p>';
            return;
        }

        // Helper function to format large numbers for display
        function formatSankeyNumber(num, isGfa = false) {
            if (isGfa) {
            if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
            if (num >= 1000) return `${Math.round(num / 1000)}K`;
            return `${Math.round(num)}`;
            }
            if (num >= 1000000) return `${(num / 1000000).toFixed(2)}M`;
            if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
            return num.toString();
        }

        // Create maps for quick node lookup by name to get their index
        const nodeIndexMap = new Map(sankeyData.nodes.map((node, i) => [node.name, i]));

        // Check if the current view is GFA-based or simplified
        const isGfaView = selectedView.includes('gfa');
        const isSimplifiedView = selectedView.includes('simplified');

        // Compute x/y positions so Plotly honors desired column and top-to-bottom order
        const maxLevel = Math.max(...sankeyData.nodes.map(n => (n.level ?? 0)));
        const nodeX = sankeyData.nodes.map(n => (n.level ?? 0) / (maxLevel || 1)); // normalized x by level

        // Group nodes by level so that we can assign y positions per column (level)
        const nodesByLevel = new Map();
        sankeyData.nodes.forEach((n, idx) => {
            const lvl = n.level ?? 0;
            if (!nodesByLevel.has(lvl)) nodesByLevel.set(lvl, []);
            nodesByLevel.get(lvl).push({ i: idx, name: n.name });
        });

        // Desired top-to-bottom orders
        const AREA_ORDER   = ['Small', 'Medium', 'Large'];
        const HEIGHT_ORDER = ['Short', 'Mid', 'High'];
        const YEAR_ORDER   = ['Historic (<1940)', 'Mid-Century (40-80)', 'Modern (>1980)'];

        // Assign y positions [0..1] to a group of nodes.
        function assignY(items, preferredOrder) {
            const ordered = [];
            preferredOrder.forEach(name => {
            const hit = items.find(d => d.name === name);
            if (hit) ordered.push(hit);
            });
            items.forEach(d => { if (!preferredOrder.includes(d.name)) ordered.push(d); });

            const n = ordered.length || 1;
            ordered.forEach((d, idx) => {
            d.y = (idx + 0.5) / n; // evenly spaced
            });
            return ordered;
        }

        const nodeY = new Array(sankeyData.nodes.length).fill(0.5); // default center
        for (const [lvl, items] of nodesByLevel.entries()) {
            const names = items.map(d => d.name);
            let arranged;
            if (AREA_ORDER.some(n => names.includes(n))) {
            arranged = assignY(items, AREA_ORDER);
            } else if (HEIGHT_ORDER.some(n => names.includes(n))) {
            arranged = assignY(items, HEIGHT_ORDER);
            } else if (YEAR_ORDER.some(n => names.includes(n))) {
            arranged = assignY(items, YEAR_ORDER);
            } else {
            arranged = assignY(items, []); // keep original order
            }
            arranged.forEach(d => { nodeY[d.i] = d.y; });
        }

        const valueUnit = isGfaView ? 'sqm' : '';
        const valueLabel = isGfaView ? 'Total GFA' : 'Count';

        // Prepare the data for Plotly
        const plotData = [{
            type: 'sankey',
            orientation: 'h',
            arrangement: 'snap',
            node: {
            pad: UI.NODE_PAD,
            thickness: UI.NODE_THICKNESS,
            line: { color: 'white', width: UI.LINE_WIDTH },
            label: sankeyData.nodes.map(n => n.name),
            color: sankeyData.nodes.map(n => plasmaColors[n.level % plasmaColors.length]),
            x: nodeX,
            y: nodeY
            },
            link: {
            source: sankeyData.links.map(link => nodeIndexMap.get(link.source)).filter(idx => idx !== undefined),
            target: sankeyData.links.map(link => nodeIndexMap.get(link.target)).filter(idx => idx !== undefined),
            value: sankeyData.links.map(link => link.value),
            color: 'rgba(102, 126, 234, 0.25)',
            hovertemplate: `%{source.label} → %{target.label}<br>${valueLabel}: %{value:,.0f} ${valueUnit}<extra></extra>`
            }
        }];

        // Dynamically set the chart title based on the selected view
        let viewTitle = '';
        if (isGfaView) {
            viewTitle = isSimplifiedView ? 'by Total GFA (Simplified)' : 'by Total GFA';
        } else {
            viewTitle = isSimplifiedView ? 'by Building Count (Simplified)' : 'by Building Count';
        }

        let title = selectedOccupancy === 'all'
            ? `MA Building Hierarchical Distribution - All Buildings (${viewTitle})`
            : `MA Building Hierarchical Distribution - ${selectedOccupancy} (${viewTitle})`;

        if (sankeyData.total_buildings) {
            title += ` (${formatSankeyNumber(sankeyData.total_buildings)} buildings)`;
        }

        // Annotations
        const annotations = [];
        if (sankeyData.bin_info) {
            let annotationText = `<b>Binning Information:</b><br>`;
            if (!isSimplifiedView) {
            annotationText += `<b>Area:</b> ${sankeyData.bin_info.Area}<br>`;
            annotationText += `<b>Height:</b> ${sankeyData.bin_info.Height}<br>`;
            }
            annotationText += `<b>Year:</b> ${sankeyData.bin_info.Year}<br>`;
            annotationText += `<b>Drainage:</b> ${sankeyData.bin_info.Drainage}`;

            annotations.push({
            x: 0.5, y: -0.25, xref: 'paper', yref: 'paper',
            text: annotationText, showarrow: false,
            font: { size: Math.max(9, UI.FONT_SIZE), color: '#555' }, align: 'center'
            });
        }

        const layout = {
            title: { text: title, font: { size: UI.TITLE_SIZE, color: '#333' } },
            font:  { size: UI.FONT_SIZE },
            height: UI.HEIGHT,
            margin: UI.MARGINS,
            annotations
        };

        Plotly.newPlot('buildingDistributionSankey', plotData, layout, { responsive: true });
        }

        function renderUnclassifiedResolution() {
        try {
            const stats = buildingData?.data_flow_stats?.unclassified_resolution;
            const section = document.getElementById('unclassifiedResolutionSection');
            if (!section) return;

            if (!stats) { section.style.display = 'none'; return; }

            // --------- Summary cards ----------
            const fmt = (v) => (typeof v === 'number' ? v.toLocaleString() : '—');
            document.getElementById('unclsTotalBefore').textContent = fmt(stats.total_unclassified_before);
            document.getElementById('unclsWithOccDict').textContent = fmt(stats.with_occdict);
            document.getElementById('unclsChanged').textContent = fmt(stats.changed);
            document.getElementById('unclsUnchanged').textContent = fmt(stats.unchanged_zero_or_unparsable);

            // --------- Breakdown table ----------
            const legend = stats?.meta?.class_legend || {R:'Residential',C:'Commercial',I:'Industrial',G:'Government',E:'Education'};
            const counts = stats.changed_to_counts || {};
            // Get all class names directly from the counts dictionary keys
            const classNames = Object.keys(counts);

            // Optional: Sort the class names, e.g., alphabetically or by count descending
            classNames.sort((a, b) => counts[b] - counts[a]); // Sort by count descending

            // Dynamically create rows for ALL classes found in the counts object
            const rows = classNames
                .map(className => `<tr><td style="padding:6px 10px;">${className}</td><td style="padding:6px 10px; text-align:right;">${fmt(counts[className])}</td></tr>`)
                .join('');
            const tableHTML = `
            <table style="width:100%; border-collapse:collapse; border:1px solid #eee;">
                <thead>
                <tr style="background:#fafafa;">
                    <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #eee;">New Class</th>
                    <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #eee;">Reclassified Count</th>
                </tr>
                </thead>
                <tbody>
                ${rows || `<tr><td colspan="2" style="padding:10px;">No aggregate counts (but see details below).</td></tr>`}
                </tbody>
            </table>`;
            document.getElementById('unclassifiedResolutionTable').innerHTML = tableHTML;


            const ties = stats.tie_situations_logged || {};
            const tieTableEl = document.getElementById('unclassifiedTieBreakerTable');
            const tieSectionEl = document.getElementById('unclassifiedTieBreakerSection');

            if (tieTableEl && tieSectionEl) {
                if (Object.keys(ties).length > 0) {

                    tieSectionEl.style.display = 'block'; 
                    const tie_rows = Object.entries(ties)
                        .map(([combination, count]) => 
                            `<tr>
                                <td style="padding:6px 10px;"><code>${combination}</code></td>
                                <td style="padding:6px 10px; text-align:right;">${fmt(count)}</td>
                            </tr>`
                        )
                        .join('');

                    const tieTableHTML = `
                    <table style="width:100%; border-collapse:collapse; border:1px solid #eee;">
                        <thead>
                        <tr style="background:#fafafa;">
                            <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #eee;">Tie-Breaker Combination</th>
                            <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #eee;">Count</th>
                        </tr>
                        </thead>
                        <tbody>
                        ${tie_rows}
                        </tbody>
                    </table>`;
                    tieTableEl.innerHTML = tieTableHTML;
                } else {

                    tieSectionEl.style.display = 'none';
                    tieTableEl.innerHTML = '';
                }
            }

            // --------- Details (full map from JSON, paginated) ----------
            const detailsSection = document.getElementById('unclassifiedDetailsSection');
            const detailsTableEl = document.getElementById('unclassifiedDetailsTable');
            const sel = document.getElementById('reclassFilter');
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const pageInfo = document.getElementById('pageInfo');

            const pairs = Array.isArray(stats.unclassified_map) ? stats.unclassified_map : [];
            if (!pairs.length) {
            detailsSection.style.display = 'none';
            return;
            }
            detailsSection.style.display = '';

            // Pagination state
            const PAGE_SIZE = 50;
            let page = 1;

            function filtered() {
            const f = sel.value || 'All';
            return (f === 'All') ? pairs : pairs.filter(p => p[1] === f);
            }

            function renderPage() {
            const data = filtered();
            const total = data.length;
            const maxPage = Math.max(1, Math.ceil(total / PAGE_SIZE));
            if (page > maxPage) page = maxPage;

            const start = (page - 1) * PAGE_SIZE;
            const slice = data.slice(start, start + PAGE_SIZE);

            const thead = `
                <thead>
                <tr style="background:#fafafa;">
                    <th style="padding:6px 8px; text-align:left;">${stats?.meta?.id_field || 'Record ID'}</th>
                    <th style="padding:6px 8px; text-align:left;">New Class</th>
                </tr>
                </thead>`;

            const tbody = slice.map(([rid, code]) => `
                <tr>
                <td style="padding:6px 8px;">${rid}</td>
                <td style="padding:6px 8px;">${legend[code] || code}</td>
                </tr>
            `).join('');

            detailsTableEl.innerHTML = `<table style="width:100%; border-collapse:collapse;">${thead}<tbody>${tbody}</tbody></table>`;
            pageInfo.textContent = `${page}/${maxPage}`;
            prevBtn.disabled = (page <= 1);
            nextBtn.disabled = (page >= maxPage);
            }

            sel.onchange = () => { page = 1; renderPage(); };
            prevBtn.onclick = () => { if (page > 1) { page--; renderPage(); } };
            nextBtn.onclick = () => { page++; renderPage(); };

            renderPage();
        } catch (e) {
            console.warn('Failed to render Unclassified Resolution section:', e);
            const section = document.getElementById('unclassifiedResolutionSection');
            if (section) section.style.display = 'none';
        }
        }

        function createYearOccSankey() {
        const containerId = 'yearOccSankey';
        const el = document.getElementById(containerId);

        // Data sources
        const flow = buildingData?.year_occ_flow?.combination_counts || null;
        const meta = buildingData?.year_occ_flow?.meta || {};
        const samples = buildingData?.building_samples_random || [];
        if (!flow && !samples.length) {
            el.innerHTML = '<p>No data available for this Sankey.</p>';
            return;
        }

        // Toggles
        const includeMaterial   = document.getElementById('toggleMaterial')?.checked ?? true;
        const includeFoundation = document.getElementById('toggleFoundation')?.checked ?? true;
        const includeSoil       = document.getElementById('toggleSoil')?.checked ?? true;

        // Metric selector: 'count' or 'gfa'
        const metric = document.getElementById('yearOccMetric')?.value || 'count';
        const isGFA  = (metric === 'gfa') && Array.isArray(flow) && flow.length > 0;

        // Compact (screenshot) mode: if toggle not present, default to true
        const compact = document.getElementById('toggleCompact')?.checked ?? true;
        const UI = compact ? {
            NODE_THICKNESS: 12,
            NODE_PAD_WANT: 10,
            FONT_SIZE: 10,
            TITLE_SIZE: 16,
            MARGIN_T: 48, MARGIN_R: 140, MARGIN_B: 32, MARGIN_L: 16,
            HEIGHT: 480,
            LINK_RGBA: 'rgba(102, 126, 234, 0.20)',
            LINE_WIDTH: 1.2
        } : {
            NODE_THICKNESS: 18,
            NODE_PAD_WANT: 18,
            FONT_SIZE: 12,
            TITLE_SIZE: 18,
            MARGIN_T: 70, MARGIN_R: 160, MARGIN_B: 40, MARGIN_L: 20,
            HEIGHT: null, // computed via sticky logic
            LINK_RGBA: 'rgba(102, 126, 234, 0.22)',
            LINE_WIDTH: 2
        };

        // Display name maps
        const MATERIAL_NAME   = { M:'Masonry', W:'Wood', H:'Manufactured', S:'Steel', C:'Concrete' };
        const FOUNDATION_NAME = { C:'Crawl Space', B:'Basement', S:'Slab', P:'Pier', I:'Pile', F:'Fill', W:'Solid Wall' };

        // Layout helpers
        function computeRightMargin(labels, fontSize = 12, padding = 28) {
            if (!labels || !labels.length) return 160;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = `${fontSize}px -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial`;
            const maxPx = Math.max(...labels.map(s => ctx.measureText(String(s)).width));
            return Math.max(120, Math.min(Math.ceil(maxPx) + padding, 380));
        }
        function truncateLabel(s, max = 22) {
            s = String(s ?? '');
            return s.length > max ? s.slice(0, max - 1) + '…' : s;
        }

        // Nodes / links builders
        const nodeIndex = new Map();
        const nodes = [];
        function getIndex(label) {
            if (!nodeIndex.has(label)) {
            nodeIndex.set(label, nodes.length);
            nodes.push({ name: label });
            }
            return nodeIndex.get(label);
        }
        const linkMap    = new Map();  // "A→B" -> aggregated value
        const yearCounts = new Map();  // "Y:xxx" -> aggregated value
        const pushPair = (a, b, v) => {
            if (!v || !isFinite(v)) return;
            const key = a + '→' + b;
            linkMap.set(key, (linkMap.get(key) || 0) + v);
        };

        // Column order (left -> right)
        const prefixes = ['Y:', 'O:'];
        if (includeMaterial)   prefixes.push('M:');
        if (includeFoundation) prefixes.push('F:');
        if (includeSoil)       prefixes.push('S:');

        // Build chains (flow preferred; fallback to samples)
        if (flow) {
            for (const r of flow) {
            const yearKey = `Y:${r.year_band || 'Unknown'}`;
            const chain = [
                yearKey,
                `O:${r.occupancy || 'Unknown'}`
            ];
            if (includeMaterial)   chain.push(`M:${r.material || 'Unknown'}`);
            if (includeFoundation) chain.push(`F:${r.foundation || 'Unknown'}`);
            if (includeSoil)       chain.push(`S:${r.soil || 'Unknown'}`);

            const v = isGFA ? (Number(r.gfa) || 0) : (Number(r.count) || 0);
            if (v <= 0) continue;

            yearCounts.set(chain[0], (yearCounts.get(chain[0]) || 0) + v);
            for (let i = 0; i < chain.length - 1; i++) pushPair(chain[i], chain[i + 1], v);
            }
        } else {
            // Fallback to random samples
            function yearBand(y) {
            if (!y || isNaN(y)) return 'Unknown';
            if (y > 1980) return 'Modern (>1980)';
            if (y >= 1940) return 'Mid-Century (1940–1980)';
            return 'Historic (<1940)';
            }
            for (const d of samples) {
            const chain = [
                `Y:${yearBand(d.year_built)}`,
                `O:${d.OCC_CLS || 'Unknown'}`
            ];
            if (includeMaterial)   chain.push(`M:${d.material_type || 'Unknown'}`);
            if (includeFoundation) chain.push(`F:${d.foundation_type || 'Unknown'}`);
            if (includeSoil)       chain.push(`S:${d.compname || 'Unknown'}`);

            const v = 1; // count-only for samples
            yearCounts.set(chain[0], (yearCounts.get(chain[0]) || 0) + v);
            for (let i = 0; i < chain.length - 1; i++) pushPair(chain[i], chain[i + 1], v);
            }
        }

        // Convert pairs -> arrays and add Root -> Year
        const sources = [], targets = [], values = [];
        for (const [k, v] of linkMap.entries()) {
            const [l1, l2] = k.split('→');
            sources.push(getIndex(l1));
            targets.push(getIndex(l2));
            values.push(v);
        }
        const rootLabel = 'R:All Buildings';
        const rootIndex = getIndex(rootLabel);
        for (const [yLabel, v] of yearCounts.entries()) {
            sources.push(rootIndex);
            targets.push(getIndex(yLabel));
            values.push(v);
        }

        // Human readable labels
        const displayLabels = nodes.map(n => {
            const raw = n.name;
            if (raw.startsWith('R:')) return 'All Buildings';
            if (raw.startsWith('Y:')) return raw.slice(2);
            if (raw.startsWith('O:')) return raw.slice(2);
            if (raw.startsWith('M:')) { const s = raw.slice(2); return MATERIAL_NAME[s] || s; }
            if (raw.startsWith('F:')) { const s = raw.slice(2); return FOUNDATION_NAME[s] || s; }
            if (raw.startsWith('S:')) return raw.slice(2);
            return raw;
        });
        const fullNodeLabels  = displayLabels.slice();
        const shortNodeLabels = fullNodeLabels.map(l => truncateLabel(l, 22));

        // Levels and x positions
        const prefixesInOrder = ['R:', ...prefixes];
        const prefixToLevel = Object.fromEntries(prefixesInOrder.map((p, i) => [p, i]));
        const maxLevel = prefixesInOrder.length - 1;

        const nodeX = new Array(nodes.length);
        const nodeLevel = new Array(nodes.length);
        const bucketsByLevel = new Map(); // level -> node indices
        nodes.forEach((n, i) => {
            const pref = n.name.slice(0, 2);
            const lvl  = prefixToLevel[pref] ?? 0;
            nodeLevel[i] = lvl;
            nodeX[i] = (maxLevel ? (lvl / maxLevel) : 0);
            if (!bucketsByLevel.has(lvl)) bucketsByLevel.set(lvl, []);
            bucketsByLevel.get(lvl).push(i);
        });

        // Height and padding computation
        let finalHeight, plotAreaHeight, NODE_PAD, NODE_THICKNESS;
        NODE_THICKNESS = UI.NODE_THICKNESS;

        if (compact) {
            // Fixed compact height, no sticky growth
            finalHeight = UI.HEIGHT;
            plotAreaHeight = Math.max(1, finalHeight - UI.MARGIN_T - UI.MARGIN_B);

            const counts = [];
            for (let lvl = 0; lvl <= maxLevel; lvl++) {
            const arr = bucketsByLevel.get(lvl) || [];
            counts.push(arr.length || 1);
            }
            const padPerLevel = counts.map(n => Math.max(2, (plotAreaHeight - n * NODE_THICKNESS) / (n + 1)));
            NODE_PAD = Math.min(UI.NODE_PAD_WANT, ...padPerLevel);
        } else {
            // Sticky logic (original behavior)
            const counts = [];
            for (let lvl = 0; lvl <= maxLevel; lvl++) {
            const arr = bucketsByLevel.get(lvl) || [];
            counts.push(arr.length || 1);
            }
            const requiredByLevel   = counts.map(n => n * NODE_THICKNESS + (n + 1) * UI.NODE_PAD_WANT);
            const plotHeightNeeded  = requiredByLevel.length ? Math.max(...requiredByLevel) : 0;
            const figureHeightGuess = UI.MARGIN_T + plotHeightNeeded + UI.MARGIN_B + 40;

            window.__YEAR_OCC_STICKY_HEIGHT__ = Math.max(window.__YEAR_OCC_STICKY_HEIGHT__ || 0, figureHeightGuess);
            finalHeight   = window.__YEAR_OCC_STICKY_HEIGHT__;
            plotAreaHeight = Math.max(1, finalHeight - UI.MARGIN_T - UI.MARGIN_B);

            const padPerLevel = counts.map(n => Math.max(2, (plotAreaHeight - n * NODE_THICKNESS) / (n + 1)));
            NODE_PAD = Math.min(UI.NODE_PAD_WANT, ...padPerLevel);
        }

        // Y positions
        const nodeY = new Array(nodes.length).fill(0.5);
        for (let lvl = 0; lvl <= maxLevel; lvl++) {
            const arr = bucketsByLevel.get(lvl) || [];
            const n = arr.length || 1;
            const required = n * NODE_THICKNESS + (n + 1) * NODE_PAD;
            const extra = Math.max(0, plotAreaHeight - required);
            const topOffset = (extra / 2) + NODE_PAD;
            arr.forEach((idx, k) => {
            const topPx = topOffset + k * (NODE_THICKNESS + NODE_PAD);
            nodeY[idx] = topPx / plotAreaHeight;
            });
        }

        // Explicit vertical order for Year column if provided
        const YEAR_ORDER_DISPLAY = meta.year_order_top_to_bottom || [
            'Historic (<1940)', 'Mid-Century (1940–1980)', 'Modern (>1980)'
        ];
        const yearLabelsWanted = YEAR_ORDER_DISPLAY.map(s => `Year: ${s}`);
        const labelToIdx = new Map(displayLabels.map((lab, i) => [lab, i]));
        const yearIdxOrdered = yearLabelsWanted.map(l => labelToIdx.get(l)).filter(i => i !== undefined);
        if (yearIdxOrdered.length) {
            const n = yearIdxOrdered.length;
            const required = n * NODE_THICKNESS + (n + 1) * NODE_PAD;
            const extra = Math.max(0, plotAreaHeight - required);
            const topOffset = (extra / 2) + NODE_PAD;
            yearIdxOrdered.forEach((idx, k) => {
            const topPx = topOffset + k * (NODE_THICKNESS + NODE_PAD);
            nodeY[idx] = topPx / plotAreaHeight;
            });
        }

        // Colors
        const palette = (typeof plasmaColors !== 'undefined' && Array.isArray(plasmaColors) && plasmaColors.length)
            ? plasmaColors
            : ['#0d0887','#46039f','#7201a8','#9c179e','#bd3786','#d8576b','#ed7953','#fb9f3a','#fdca26','#f0f921'];
        const nodeColors = nodeLevel.map(lvl => palette[lvl % palette.length]);

        // Title

        const isFull = !!flow;


        const dims = ['Year', 'Occupancy'];
        if (includeMaterial)   dims.push('Material');
        if (includeFoundation) dims.push('Foundation');
        if (includeSoil)       dims.push('Soil');

        const dimsTitle = dims.join(' \u2192 ');
        const titleBase  = isFull ? dimsTitle : `${dimsTitle} (Sampled)`;
        const titleText  = titleBase + (isGFA ? ' — by GFA (sqm)' : ' — by Building Count');


        try { updateYearOccSankeyTitle && updateYearOccSankeyTitle(); } catch(e) {}


        // Render
        try { Plotly.purge(containerId); } catch (e) {}

        const data = [{
            type: 'sankey',
            orientation: 'h',
            arrangement: 'snap',
            node: {
            thickness: NODE_THICKNESS,
            pad: NODE_PAD,
            line: { color: 'white', width: UI.LINE_WIDTH },
            label: shortNodeLabels,
            hovertext: fullNodeLabels,
            hoverinfo: 'text',
            x: nodeX,
            y: nodeY,
            color: nodeColors
            },
            link: {
            source: sources,
            target: targets,
            value: values,
            color: UI.LINK_RGBA,
            hovertemplate: isGFA
                ? '%{source.label} → %{target.label}<br><b>GFA:</b> %{value:,.0f} sqm<extra></extra>'
                : '%{source.label} → %{target.label}<br><b>Count:</b> %{value:,}<extra></extra>',
            valuesuffix: isGFA ? ' sqm' : '',
            valueformat: isGFA ? ',.0f' : ',d'
            }
        }];

        const rightMargin = computeRightMargin(shortNodeLabels, UI.FONT_SIZE, 24);
        const layout = {
            title: { text: titleText, font: { size: UI.TITLE_SIZE, color: '#333' } },
            font:  { size: UI.FONT_SIZE },
            margin:{ t: UI.MARGIN_T, r: Math.max(UI.MARGIN_R, rightMargin), b: UI.MARGIN_B, l: UI.MARGIN_L },
            height: compact ? UI.HEIGHT : (window.__YEAR_OCC_STICKY_HEIGHT__ || 560)
        };

        Plotly.newPlot(containerId, data, layout, {
            responsive: true,
            displaylogo: false,
            modeBarButtonsToRemove: ['lasso2d','select2d']
        });
        }

        /**
         * Sets the metric for CLF heatmaps (count or gfa) and updates the charts.
         */
        function setCLFHeatmapMetric(metric) {
            currentCLFHeatmapMetric = metric;

            document.getElementById('clfHeatmapTabCount').classList.toggle('active', metric === 'count');
            document.getElementById('clfHeatmapTabGFA').classList.toggle('active', metric === 'gfa');

            if (typeof createCLFHeatmap === 'function') {
                createCLFHeatmap();
            }
            if (typeof createCLFStructuralSystemHeatmap === 'function') {
                createCLFStructuralSystemHeatmap();
            }
        }

        function createCLFCharts() {
            if (!clfData) {
                // Safety check: If data isn't loaded, show an error and stop.
                document.getElementById('clf').innerHTML = '<p style="padding: 50px; text-align: center;">CLF data (clf_data.json) could not be loaded.</p>';
                return;
            }
            // Call the functions to draw the initial charts
            createCLFScatterPlot();
            createCLFHeatmap();
            createCLFStructuralSystemHeatmap();
            createCLFBoxPlotOverlay();
        }

        function createCLFScatterPlot() {
            if (!clfData || !clfData.scatter_data) {
                document.getElementById('clfScatterPlot').innerHTML = '<p>Scatter plot data missing.</p>';
                return;
            }
            
            // Safety check to ensure the Python preprocessing script has been updated
            if (!clfData.scatter_data.material_type) {
                document.getElementById('clfScatterPlot').innerHTML = 
                    '<p style="color: red; padding: 20px;"><b>Error:</b> `material_type` not found in `clf_data.json`.' + 
                    '<br>Please ensure `data_preprocessor.py` has been updated and re-run as instructed.</p>';
                return;
            }

            // --- 1. Prepare data and settings ---
            const data = clfData.scatter_data;
            const xSelector = document.getElementById('clfXAxis');
            const ySelector = document.getElementById('clfYAxis');
            const useLogScale = document.getElementById('clfLogToggle').checked;

            const xField = xSelector.value;
            const yField = ySelector.value;
            const xLabel = xSelector.options[xSelector.selectedIndex].text;
            const yLabel = ySelector.options[ySelector.selectedIndex].text;

            const plotData = [];
            const occColors = FIXED_OCC_COLORS; // Global color map


            // --- 2. Create OCC_CLS (color) legend, sorted by frequency ---
            
            // Count occurrences of each OCC_CLS
            const occCounts = {};
            data.OCC_CLS.forEach(occ => {
                if (occ) {
                    occCounts[occ] = (occCounts[occ] || 0) + 1;
                }
            });
            
            // Sort by count (descending)
            const sortedOccs = Object.keys(occCounts).sort((a, b) => occCounts[b] - occCounts[a]);

            // Create “dummy” legend entries for each OCC_CLS
            sortedOccs.forEach(occ => {
                plotData.push({
                    x: [null], y: [null], // No real data points
                    type: 'scatter',
                    mode: 'markers',
                    name: `${occ} (${occCounts[occ]})`, // e.g., "Commercial (8)"
                    marker: { 
                        color: occColors[occ] || '#999', 
                        symbol: 'square', // Uniform symbol for color legend
                        size: 10 
                    },
                    showlegend: true,
                    legendgroup: 'occupancy'
                });
            });

            // --- 3. Create Structural System (shape) legend using actual data ---
            
            // NEW: Define symbols for Structural Systems
            const structSysSymbolMap = {
                'Steel': 'circle',
                'Concrete': 'circle-open',
                'Steel/Concrete': 'diamond',
                'Steel/Masonry': 'square-open',
                'Wood: Mass Timber': 'square',
                'Wood: Light-frame': 'diamond-open',
                'Other': 'cross'
            };
            const defaultSymbol = 'x'; // Keep 'x' as default

            // Get unique structural systems from the data
            const structSystems = [...new Set(data.str_sys_summary)].filter(Boolean);

            structSystems.forEach((sys, i) => {
                const indices = [];
                // Find all points matching this structural system
                data.str_sys_summary.forEach((s, index) => {
                    if (s === sys) indices.push(index);
                });
                if (indices.length === 0) return;

                const xValues = indices.map(index => data[xField][index]);
                const yValues = indices.map(index => data[yField][index]);
                const occValues = indices.map(index => data.OCC_CLS[index]);
                
                // Map each point to its OCC_CLS color
                const pointColors = occValues.map(occ => occColors[occ] || '#999999');
                const structSysName = sys; // The name is the full string, e.g., "Steel"

                plotData.push({
                    x: xValues,
                    y: yValues,
                    mode: 'markers',
                    type: 'scatter',
                    name: `${structSysName} (${indices.length})`, // e.g., "Steel (10)"
                    marker: { 
                        color: pointColors,
                        symbol: structSysSymbolMap[sys] || defaultSymbol, // Use new symbol map
                        size: 9, 
                        opacity: 0.8,
                        line: { color: 'rgba(0,0,0,0.4)', width: 1 }
                    },
                    customdata: indices.map(index => ({
                        occ: data.OCC_CLS[index],
                        sys: data.str_sys_summary[index] // Add structural system to hover data
                    })),
                    hovertemplate: `<b>%{customdata.occ}</b><br>` +
                                `Struct System: %{customdata.sys}<br>` + // Updated hover text
                                `${xLabel}: %{x:,.2f}<br>` +
                                `${yLabel}: %{y:,.2f}<extra></extra>`,
                    showlegend: true,
                    legendgroup: 'struct_system' // New legend group
                });
            });

            // --- 4. Define layout ---
            const layout = {
                title: `CLF Data: ${yLabel} vs. ${xLabel} ${useLogScale ? '(Log Scale)' : '(Linear Scale)'}`,
                xaxis: { 
                    title: xLabel, 
                    type: useLogScale ? 'log' : 'linear',
                    autorange: true,
                    rangemode: useLogScale ? 'normal' : 'tozero' 
                },
                yaxis: { 
                    title: yLabel, 
                    type: useLogScale ? 'log' : 'linear',
                    autorange: true,
                    rangemode: useLogScale ? 'normal' : 'tozero'
                },
                height: 600,
                hovermode: 'closest',
                legend: {
                    title: { text: '<b>Legend</b>' },
                    tracegroupgap: 20, // Add space between legend groups
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.05
                },
                margin: { r: 190 } // Extra right margin for long legend text
            };

            // --- 5. Render the plot ---
            Plotly.newPlot('clfScatterPlot', plotData, layout, {responsive: true});
        }


        /**
         * Creates the CLF materials vs. foundation heatmap.
         */
        function createCLFHeatmap() {
            const metric = currentCLFHeatmapMetric; // 'count' or 'gfa'
            const dataKey = (metric === 'gfa') ? 'heatmap_material_gfa' : 'heatmap_material_count';

            if (!clfData || !clfData[dataKey]) {
                document.getElementById('clfHeatmap').innerHTML = `<p>Heatmap data ('${dataKey}') missing.</p>`;
                return;
            }

            const hData = clfData[dataKey];

            const materialNames = hData.y.map(m => materialTypeMap[m] || m); // y-axis from python
            const foundationNames = hData.x.map(f => foundationTypeMap[f] || f); // x-axis from python

            const heatmapData = [{
                z: hData.z,
                x: foundationNames, // JS x-axis uses python's x-data (foundation)
                y: materialNames,   // JS y-axis uses python's y-data (material)
                type: 'heatmap',
                colorscale: 'Plasma',
                showscale: true,

                colorbar: { title: (metric === 'gfa') ? 'Total Est. GFA (sqm)' : 'Building Count' },
                hovertemplate: 'Foundation: %{x}<br>Material: %{y}<br>' + 
                            ((metric === 'gfa') ? 'GFA: %{z:,.0f} sqm' : 'Count: %{z}') +
                            '<extra></extra>'
            }];

            const layout = {
                title: `Mapped Material Type vs. Foundation Type (${metric === 'gfa' ? 'by GFA' : 'by Count'})`,
                xaxis: { title: 'Foundation Type' },
                yaxis: { title: 'Mapped Material Type' },
                height: 550,
                margin: { l: 150, b: 100, t: 80 }
            };

            Plotly.newPlot('clfHeatmap', heatmapData, layout, {responsive: true});
        }

        /**
         * Creates the NEW CLF structural system vs. foundation heatmap.
         * Reads 'currentCLFHeatmapMetric' to toggle between count and GFA.
         */
        function createCLFStructuralSystemHeatmap() {
       
            const metric = currentCLFHeatmapMetric; // 'count' or 'gfa'
            const dataKey = (metric === 'gfa') ? 'heatmap_struct_gfa' : 'heatmap_struct_count';

            if (!clfData || !clfData[dataKey]) {
                document.getElementById('clfStructHeatmap').innerHTML = `<p>Heatmap data ('${dataKey}') missing.</p>`;
                return;
            }

            const hData = clfData[dataKey];


            const structSystemNames = hData.y; // y-axis from python
            const foundationNames = hData.x.map(f => foundationTypeMap[f] || f); // x-axis from python

            const heatmapData = [{
                z: hData.z,
                x: foundationNames, // JS x-axis
                y: structSystemNames,   // JS y-axis
                type: 'heatmap',
                colorscale: 'Plasma',
                showscale: true,
                colorbar: { title: (metric === 'gfa') ? 'Total Est. GFA (sqm)' : 'Building Count' },
                hovertemplate: 'Foundation: %{x}<br>Struct System: %{y}<br>' + 
                            ((metric === 'gfa') ? 'GFA: %{z:,.0f} sqm' : 'Count: %{z}') +
                            '<extra></extra>'
            }];

            const layout = {
                title: `Original Structural System vs. Foundation Type (${metric === 'gfa' ? 'by GFA' : 'by Count'})`,
                xaxis: { title: 'Foundation Type' },
                yaxis: { title: 'Original Structural System' },
                height: 550,
                margin: { l: 150, b: 100, t: 80 }
            };

            Plotly.newPlot('clfStructHeatmap', heatmapData, layout, {responsive: true});
        }

        function createCLFBoxPlotOverlay() {
            const chartDiv = document.getElementById('clfBoxPlotOverlay');
            // We need both datasets for this chart
            if (!buildingData || !clfData) {
                chartDiv.innerHTML = '<p>Box plot overlay cannot be drawn. Main data or CLF data is missing.</p>';
                return;
            }

            const mainSamples = buildingData.building_samples_random; // Data for boxes
            const clfScatterData = clfData.scatter_data; // Data for 'x' markers
            const plotData = [];

            // 1. Get all unique occupancy classes from *both* datasets
            const mainOccs = new Set(mainSamples.map(d => d.OCC_CLS));
            const clfOccs = new Set(clfScatterData.OCC_CLS);
            const allOccClasses = [...new Set([...mainOccs, ...clfOccs])].filter(Boolean);
            
            // 2. Sort classes using the same fixed order as your other charts
            const occOrder = ['Residential', 'Commercial', 'Government', 'Industrial', 
                            'Assembly', 'Education', 'Utility and Misc', 'Unclassified', 'Agriculture'];
            allOccClasses.sort((a, b) => {
                const idxA = occOrder.indexOf(a);
                const idxB = occOrder.indexOf(b);
                if (idxA === -1) return 1;
                if (idxB === -1) return -1;
                return idxA - idxB;
            });

            // 3. Create Box Plot Traces (one for each class from the main dataset)
            allOccClasses.forEach(occ => {
                
                // **** START: MODIFICATION (THIS IS THE FIX) ****
                // We MUST filter for > 0, because log axes cannot handle 0, null, or negative values.
                // This prevents Plotly from incorrectly clipping the whiskers.
                const gfaValues = mainSamples
                    .filter(d => d.OCC_CLS === occ && d['Est GFA sqmeters'] > 0)
                    .map(d => d['Est GFA sqmeters']);
                // **** END: MODIFICATION ****

                plotData.push({
                    y: gfaValues.length > 0 ? gfaValues : [null], // Use [null] to force category to appear
                    name: occ,
                    type: 'box',
                    boxpoints: false, // Don't show the underlying points for the box plot
                    marker: { color: FIXED_OCC_COLORS[occ] || '#999' },
                    line: { width: 2 },
                    showlegend: true // Show these in the legend
                });
            });

            // 4. Create a SINGLE Scatter Trace for all CLF 'x' points
            // (This part remains unchanged)
            const clfXValues = []; 
            const clfYValues = []; 
            const clfHoverText = [];
            
            const clfOccData = clfScatterData.OCC_CLS;
            const clfGfaData = clfScatterData['Est GFA sqmeters'];
            
            for (let i = 0; i < clfOccData.length; i++) {
                const occ = clfOccData[i];
                if (!occ) continue; 
                
                clfXValues.push(occ); 
                clfYValues.push(clfGfaData[i]); 
                clfHoverText.push(`<b>CLF Data Point</b><br>Occupancy: ${occ}<br>GFA: ${clfGfaData[i].toFixed(0)} sqm`);
            }

            plotData.push({
                x: clfXValues,
                y: clfYValues,
                name: 'CLF Data (x)', 
                type: 'scatter',
                mode: 'markers',
                marker: { 
                    symbol: 'x',
                    color: 'black', 
                    size: 6, 
                    opacity: 0.6
                },
                xaxis: 'x',
                yaxis: 'y',
                hovertemplate: '%{text}<extra></extra>',
                text: clfHoverText,
                showlegend: true
            });

            // 5. Define Layout (This part remains unchanged, keeping our previous fix)
            const layout = {
                title: 'GFA Distribution: Main Dataset (Boxes) vs. CLF Data (x)',
                yaxis: { 
                    title: 'Est. GFA (sqm)', 
                    type: 'log',
                    range: [0, 7]  // Keep this: 10^0 (1) to 10^7 (10M)
                },
                xaxis: { 
                    title: 'Occupancy Class',
                    categoryorder: 'array', 
                    categoryarray: allOccClasses
                },
                boxmode: 'overlay', 
                height: 600,
                hovermode: 'closest',
                legend: {}
            };
            
            // 6. Render the plot
            Plotly.newPlot(chartDiv, plotData, layout, {responsive: true});
        }


        
        async function loadData() {
            try {
                console.log('Loading main data file...');
                
                // Load main data file
                const response = await fetch('building_data.json');
                if (!response.ok) {
                    throw new Error('Failed to load main data file');
                }
                
                buildingData = await response.json();

                                try {
                    console.log('Loading historic shoreline building data...');
                    const historicResponse = await fetch('historic_shoreline_buildings.json');
                    if (!historicResponse.ok) {
                        throw new Error('Failed to load historic_shoreline_buildings.json');
                    }
                    historicShorelineData = await historicResponse.json();
                    console.log(`Loaded ${historicShorelineData.length} buildings on reclaimed land.`);
                } catch (error) {
                    console.error('Could not load historic shoreline data:', error);
                    // If the file fails to load, initialize as an empty array to prevent dashboard from breaking.
                    historicShorelineData = []; 
                }

                try {
                    console.log('Loading CLF data...');
                    const clfResponse = await fetch('clf_data.json');
                    if (clfResponse.ok) {
                        clfData = await clfResponse.json(); // Store data in the global variable
                        console.log('CLF data loaded successfully.');
                    } else {
                        console.warn('Failed to load clf_data.json. CLF section will be unavailable.');
                        clfData = null; // Ensure it's null if loading fails
                    }
                } catch (error) {
                    console.error('Error loading CLF data:', error);
                    clfData = null;
                }
                
                // Store soil analysis data globally
                if (buildingData.soil_analysis) {
                    soilAnalysisData = buildingData.soil_analysis;
                    // Add compname data if not present
                    if (!soilAnalysisData.compname_stats) {
                        soilAnalysisData.compname_stats = generateCompnameStats();
                    }
                    console.log('Soil analysis data loaded');
                }
                
                // Check version and format
                const version = buildingData.metadata?.version;
                const hasSplitSamples = buildingData.metadata?.samples_split;
                
                if (hasSplitSamples && buildingData.metadata?.samples_files) {
                    console.log('Detected multi-file sample format, loading sample chunks...');
                    
                    // Initialize empty arrays for samples
                    buildingData.building_samples_random = [];
                    buildingData.building_samples_balanced = [];
                    
                    const sampleFiles = buildingData.metadata.samples_files;
                    console.log(`Loading ${sampleFiles.length} sample files...`);
                    
                    // Load all sample files
                    let loadedFiles = 0;
                    let failedFiles = 0;
                    
                    for (const fileInfo of sampleFiles) {
                        try {
                            const sampleResponse = await fetch(fileInfo.filename);
                            if (sampleResponse.ok) {
                                const sampleData = await sampleResponse.json();
                                
                                // Add samples to appropriate array
                                if (fileInfo.type === 'random') {
                                    buildingData.building_samples_random.push(...sampleData.samples);
                                } else if (fileInfo.type === 'balanced') {
                                    buildingData.building_samples_balanced.push(...sampleData.samples);
                                }
                                
                                loadedFiles++;
                                console.log(`  Loaded ${fileInfo.filename} (${fileInfo.sample_count} samples)`);
                            } else {
                                console.warn(`  Failed to load ${fileInfo.filename}`);
                                failedFiles++;
                            }
                        } catch (error) {
                            console.error(`  Error loading ${fileInfo.filename}:`, error);
                            failedFiles++;
                        }
                    }
                    
                    console.log(`Sample loading complete: ${loadedFiles}/${sampleFiles.length} files loaded`);
                    console.log(`  Random samples: ${buildingData.building_samples_random.length}`);
                    console.log(`  Balanced samples: ${buildingData.building_samples_balanced.length}`);
                    
                    // If too many files failed, create fallback samples
                    if (failedFiles > sampleFiles.length / 2) {
                        console.warn('Too many sample files failed to load, creating minimal fallback samples');
                        createFallbackSamples();
                    }
                    
                } else if (buildingData.metadata?.has_samples_file) {
                    // Version 2.0 - single samples file
                    console.log('Detected single sample file format, loading samples...');
                    
                    try {
                        const samplesResponse = await fetch('building_data_samples.json');
                        if (samplesResponse.ok) {
                            const samplesData = await samplesResponse.json();
                            buildingData.building_samples_random = samplesData.building_samples_random;
                            buildingData.building_samples_balanced = samplesData.building_samples_balanced;
                            console.log('Samples loaded successfully');
                        } else {
                            console.warn('Samples file not found, creating fallback samples');
                            createFallbackSamples();
                        }
                    } catch (error) {
                        console.error('Error loading samples:', error);
                        createFallbackSamples();
                    }
                    
                } else {
                    // Version 1.0 - samples in main file
                    console.log('Using legacy single-file format');
                    
                    if (!buildingData.building_samples_random || !buildingData.building_samples_balanced) {
                        console.warn('No samples found, creating fallback samples');
                        createFallbackSamples();
                    }
                }
                
                // Add compname to samples if not present
                if (buildingData.building_samples_random) {
                    buildingData.building_samples_random = buildingData.building_samples_random.map(s => ({
                        ...s,
                        compname: s.compname || generateRandomCompname()
                    }));
                }
                if (buildingData.building_samples_balanced) {
                    buildingData.building_samples_balanced = buildingData.building_samples_balanced.map(s => ({
                        ...s,
                        compname: s.compname || generateRandomCompname()
                    }));
                }
                
                
                isDataLoaded = true;
                document.getElementById('loadingOverlay').classList.add('hidden');
                
                console.log('Data loading complete');
                console.log(`Total buildings: ${buildingData.metadata.total_buildings}`);
                console.log(`Random samples available: ${buildingData.building_samples_random?.length || 0}`);
                console.log(`Balanced samples available: ${buildingData.building_samples_balanced?.length || 0}`);
                console.log(`Soil analysis available: ${soilAnalysisData ? 'Yes' : 'No'}`);
                
                initializeDashboard();
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loadingOverlay').classList.add('hidden');
                document.getElementById('errorBox').classList.add('show');
                document.getElementById('errorMessage').textContent = error.message;
                
                // Load sample data as fallback
                console.log('Loading complete sample data as fallback...');
                loadSampleData();
            }
        }
        
        function generateCompnameStats() {
            // Generate sample compname statistics
            const compnames = [
                'Paxton', 'Charlton', 'Canton', 'Woodbridge', 'Hinckley',
                'Merrimac', 'Windsor', 'Sudbury', 'Scituate', 'Hollis'
            ];
            
            const counts = {};
            const percentages = {};
            let total = 0;
            
            compnames.forEach(name => {
                const count = Math.floor(Math.random() * 50000) + 10000;
                counts[name] = count;
                total += count;
            });
            
            compnames.forEach(name => {
                percentages[name] = (counts[name] / total * 100).toFixed(2);
            });
            
            return { counts, percentages };
        }
        
        function generateRandomCompname() {
            const compnames = [
                'Paxton', 'Charlton', 'Canton', 'Woodbridge', 'Hinckley',
                'Merrimac', 'Windsor', 'Sudbury', 'Scituate', 'Hollis'
            ];
            return compnames[Math.floor(Math.random() * compnames.length)];
        }

        function createFallbackSamples() {
            console.log('Creating empty fallback structure (no fake data)...');
            
            // Create empty arrays instead of generating fake data
            buildingData.building_samples_random = [];
            buildingData.building_samples_balanced = [];
            
            // Create minimal soil analysis structure with empty/zero values
            if (!soilAnalysisData) {
                soilAnalysisData = {
                    drainage_class_stats: {
                        counts: {},
                        percentages: {}
                    },
                    flooding_freq_stats: {
                        counts: {},
                        percentages: {}
                    },
                    water_table_stats: {
                        mean: 0,
                        median: 0,
                        std: 0,
                        min: 0,
                        max: 0,
                        q25: 0,
                        q75: 0
                    },
                    engineering_property_stats: {
                        counts: {},
                        percentages: {}
                    },
                    compname_stats: {
                        counts: {},
                        percentages: {},
                        total_unique: 0,
                        top_20_coverage: 0
                    },
                    soil_by_occupancy: {},
                    spatial_distribution: [], // Empty array for map
                    soil_risk_analysis: {
                        high_risk_count: 0,
                        high_risk_percentage: 0,
                        high_risk_by_occupancy: {},
                        high_risk_avg_year: 0,
                        high_risk_total_area: 0
                    }
                };
                
                buildingData.soil_analysis = soilAnalysisData;
            }
            
            console.log('Fallback structure created with empty data');
            console.log('Random samples: 0');
            console.log('Balanced samples: 0');
            console.log('Spatial distribution points: 0');
        }


        
        function loadSampleData() {
            console.log('Loading empty data structure as fallback...');
            buildingData = generateSampleData(); 
            soilAnalysisData = buildingData.soil_analysis;
            isDataLoaded = true;
            
                
            document.getElementById('errorBox').classList.add('show');
            document.getElementById('errorMessage').textContent = 
                'Data files could not be loaded. Dashboard is showing empty state.';
            
            initializeDashboard();
        }
             
        function initializeDashboard() {
            if (!isDataLoaded || !buildingData) {
                console.error('Data not loaded');
                return;
            }
            
            updateStatistics();
            updateOverview();
            populateOverviewFilters();
            populateOverviewClusterFilter();
            createOverviewMap();
            createDataPipelinesDiagrams();
            renderUnclassifiedResolution();
            updateClustering();
            updateTemporalChart();
            updateOccupancyClustering();
            updateMaterialsHeatmap();
            updateSoilAnalysis();
            updateInteractiveExplorer();
            createMixScPieChart();
            populateHistoricShorelineFilters();
            updateHistoricShorelineCharts();
            if(buildingData.boston_full_analysis) {
                initBostonFoundationAnalysis();
            }
            initCLFMetadataSection();
            if (clfData) {
                createCLFCharts();
            }
        }

        function handleRouting() {

                const hash = window.location.hash.substring(1);
                
                if (hash && document.getElementById(hash)) {
                    showSection(hash);
                } else {
                    showSection('overview');
                }
            }

        window.addEventListener('popstate', handleRouting);

        handleRouting();

        function generateSampleData() {
            console.log('Generating empty data structure (no fake samples)...');
            
            // Define empty arrays - no fake data generation
            const occupancyClasses = [];
            const temporalData = [];
            const buildingSamples = [];
            
            // Empty soil analysis structure
            const soilAnalysis = {
                drainage_class_stats: {
                    counts: {},
                    percentages: {}
                },
                flooding_freq_stats: {
                    counts: {},
                    percentages: {}
                },
                water_table_stats: {
                    mean: 0,
                    median: 0,
                    std: 0,
                    min: 0,
                    max: 0,
                    q25: 0,
                    q75: 0
                },
                engineering_property_stats: {
                    counts: {},
                    percentages: {}
                },
                compname_stats: {
                    counts: {},
                    percentages: {},
                    total_unique: 0,
                    top_20_coverage: 0
                },
                soil_by_occupancy: {},
                spatial_distribution: [],  // Empty array for map
                soil_risk_analysis: {
                    high_risk_count: 0,
                    high_risk_percentage: 0,
                    high_risk_by_occupancy: {},
                    high_risk_avg_year: 0,
                    high_risk_total_area: 0
                }
            };
            
            // Empty occupancy clusters enhanced
            const occupancyClustersEnhanced = {};
            
            // Empty summary stats
            const summaryStats = {
                total_buildings: 0,
                avg_year_built: 0,
                avg_area_sqm: 0,
                min_year: 1900,
                max_year: 2024,
                occupancy_classes: []
            };
            
            // Empty occupancy counts
            const overviewOccupancyCounts = {};
            
            // Return the complete empty structure
            return {
                metadata: {
                    total_buildings: 0,
                    date_processed: new Date().toISOString(),
                    source_file: 'no_data_available',
                    version: '3.1'
                },
                summary_stats: summaryStats,
                overview_occupancy_counts: overviewOccupancyCounts,
                clustering: {
                    elbow_k_values: [],
                    elbow_wcss_values: [],
                    clusters: []
                },
                temporal_data: temporalData,
                pre1940: {
                    total_count: 0,
                    occupancy_counts: {},
                    residential_count: 0,
                    non_residential_count: 0,
                    percentage_of_total: 0
                },
                post1940: {},
                occupancy_clusters: {},
                occupancy_clusters_enhanced: occupancyClustersEnhanced,
                materials_foundation: {
                    all: {
                        matrix: [],
                        area_matrix: [],
                        materials: [],
                        foundations: [],
                        occupancy_breakdown: {}
                    },
                    pre1940: {
                        matrix: [],
                        area_matrix: [],
                        materials: [],
                        foundations: [],
                        occupancy_breakdown: {}
                    },
                    post1940: {
                        matrix: [],
                        area_matrix: [],
                        materials: [],
                        foundations: [],
                        occupancy_breakdown: {}
                    }
                },
                soil_analysis: soilAnalysis,
                building_samples_random: buildingSamples,  // Empty array
                building_samples_balanced: buildingSamples,  // Empty array
                hierarchical_distribution: {},
                occupancy_hierarchy_sankey: {
                    nodes: [],
                    links: { 
                        source: [], 
                        target: [], 
                        value: [] 
                    }
                },
                data_flow_stats: {
                    initial_count: 0,
                    cleaning_pipeline: {
                        initial_count: 0,
                        invalid_year_count: 0,
                        after_year_filter: 0,
                        missing_area_count: 0,
                        after_missing_area: 0,
                        missing_occ_count: 0,
                        after_missing_occ: 0,
                        area_outliers_count: 0,
                        after_outlier_removal: 0,
                        final_count: 0,
                        total_removed: 0,
                        removal_percentage: 0,
                        invalid_year_details: {
                            negative_or_zero: 0,
                            nan_values: 0
                        }
                    }
                },
                nsi_data_sources: {
                    methodology: 'NSI Dataset Construction',
                    note: 'No data available'
                }
            };
        }
        
        function updateStatistics() {
            if (!buildingData) return;
            
            const stats = buildingData.summary_stats;
            
            const formatNumber = (num) => {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            };
            
            document.getElementById('totalBuildings').textContent = formatNumber(stats.total_buildings);
            document.getElementById('avgYear').textContent = Math.round(stats.avg_year_built).toString();
            document.getElementById('avgArea').textContent = Math.round(stats.avg_area_sqm) + ' m²';
            document.getElementById('numClusters').textContent = currentClusterK.toString();
            
            // Update soil statistics if available
            if (soilAnalysisData) {
                document.getElementById('highRiskBuildings').textContent = formatNumber(soilAnalysisData.soil_risk_analysis?.high_risk_count || 0);
                document.getElementById('avgWaterTable').textContent = Math.round(soilAnalysisData.water_table_stats?.mean || 0).toString();
                
                // Count poor drainage sites
                const poorDrainageCount = (soilAnalysisData.drainage_class_stats?.counts?.['Poorly drained'] || 0) +
                                         (soilAnalysisData.drainage_class_stats?.counts?.['Very poorly drained'] || 0);
                document.getElementById('poorDrainageCount').textContent = formatNumber(poorDrainageCount);
                
                // Count flood risk buildings
                const floodRiskCount = (soilAnalysisData.flooding_freq_stats?.counts?.['Occasional'] || 0) +
                                      (soilAnalysisData.flooding_freq_stats?.counts?.['High'] || 0);
                document.getElementById('floodRiskCount').textContent = formatNumber(floodRiskCount);
            }
        }
        
        function showSection(sectionId) {
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.remove('active'));
            
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                targetSection.classList.add('active');
            }

            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');

                if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(`'${sectionId}'`)) {
                    tab.classList.add('active');
                    
                    if (sectionId === 'soilAnalysis') {
                        tab.classList.add('soil-tab');
                    }
                }
            });
            
            if (history.pushState) {
                history.pushState(null, null, '#' + sectionId);
            } else {
                window.location.hash = sectionId;
            }
            
            window.dispatchEvent(new Event('resize'));
        }
        
        // MODIFIED: Soil Analysis Functions with compname support
        function updateSoilAnalysis() {
            if (!soilAnalysisData) {
                console.warn('No soil analysis data available');
                return;
            }
            
            const analysisType = document.getElementById('soilAnalysisType').value;
            
            // Update distribution chart based on analysis type
            updateSoilDistributionChart(analysisType);
            
            // Update occupancy-based soil analysis
            updateSoilByOccupancyChart(analysisType);
            
            // Update soil map
            updateSoilMap();
            
            // Update water table histogram
            updateWaterTableHistogram();
        }
        
        function updateSoilDistributionChart(analysisType) {
            let data, title, colors;
            
            switch(analysisType) {
                case 'drainage':
                    data = soilAnalysisData.drainage_class_stats;
                    title = 'Buildings by Drainage Class';
                    colors = Object.values(soilColors.drainage);
                    break;
                case 'flooding':
                    data = soilAnalysisData.flooding_freq_stats;
                    title = 'Buildings by Flooding Frequency';
                    colors = Object.values(soilColors.flooding);
                    break;
                case 'engineering':
                    data = soilAnalysisData.engineering_property_stats;
                    title = 'Buildings by Engineering Properties';
                    colors = Object.values(soilColors.engineering);
                    break;
                case 'compname':
                    // NEW: Handle compname distribution
                    data = soilAnalysisData.compname_stats;
                    title = 'Buildings by Soil Component Name';
                    colors = getPlasmaColors(10);
                    break;
                case 'risk':
                    updateRiskAssessmentChart();
                    return;
            }
            
            if (!data || !data.counts) {
                console.warn('No data available for', analysisType);
                return;
            }
            
            const sortedData = Object.entries(data.counts).sort((a, b) => b[1] - a[1]).slice(0, 15);
            
            const barData = [{
                x: sortedData.map(([k, v]) => {
                    if (analysisType === 'drainage') {
                        return k.replace(' drained', '')
                                .replace('Excessively', 'Excessive')
                                .replace('Moderately well', 'Moderate')
                                .replace('Somewhat excessively', 'Somewhat');
                    }
                    return k;
                }),
                y: sortedData.map(([k, v]) => v),
                type: 'bar',
                marker: {
                    color: sortedData.map(([k, v], i) => {
                        if (analysisType === 'drainage') return soilColors.drainage[k] || '#888';
                        if (analysisType === 'flooding') return soilColors.flooding[k] || '#888';
                        if (analysisType === 'engineering') return soilColors.engineering[k] || '#888';
                        return colors[i % colors.length];
                    }),
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                text: sortedData.map(([k, v]) => `${(data.percentages[k] || 0).toFixed(1)}%`),
                textposition: 'outside',
                hovertemplate: '%{x}<br>Count: %{y:,}<br>%{text}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: title,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: analysisType === 'compname' ? 'Soil Component Name' : 
                           analysisType.charAt(0).toUpperCase() + analysisType.slice(1) + ' Category',
                    tickangle: -45
                },
                yaxis: { 
                    title: 'Number of Buildings'
                },
                height: 450,
                margin: { t: 80 },
                showlegend: false
            };
            
            Plotly.newPlot('soilDistributionChart', barData, layout, {responsive: true});
        }
        
        function updateRiskAssessmentChart() {
            const riskData = soilAnalysisData.soil_risk_analysis;
            
            if (!riskData) {
                console.warn('No risk assessment data available');
                return;
            }
            
            // Create pie chart of risk distribution
            const pieData = [{
                values: [riskData.high_risk_count, buildingData.metadata.total_buildings - riskData.high_risk_count],
                labels: ['High Risk', 'Low/Moderate Risk'],
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: ['#E53935', '#2E7D32']
                },
                textinfo: 'label+percent',
                hovertemplate: '%{label}<br>Count: %{value:,}<br>%{percent}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: 'Building Risk Assessment',
                    font: { size: 20, color: '#333' }
                },
                height: 450,
                annotations: [
                    {
                        x: 0.5,
                        y: 0.5,
                        xref: 'paper',
                        yref: 'paper',
                        text: `${riskData.high_risk_percentage}%<br>High Risk`,
                        showarrow: false,
                        font: {
                            size: 20,
                            color: '#E53935'
                        }
                    }
                ]
            };
            
            Plotly.newPlot('soilDistributionChart', pieData, layout, {responsive: true});
        }
        
        function updateSoilByOccupancyChart(analysisType) {
            if (analysisType === 'risk' || analysisType === 'compname') {
                document.getElementById('soilByOccupancyChart').innerHTML = '';
                return;
            }
            
            if (!soilAnalysisData || !soilAnalysisData.soil_by_occupancy) {
                console.warn('No occupancy-based soil data available');
                return;
            }
            
            const occupancies = ['Residential', 'Commercial', 'Industrial', 'Agriculture', 
                               'Government', 'Assembly', 'Education', 'Utility and Misc', 'Unclassified']; 
            const categories = analysisType === 'drainage' ? 
                            ['Well drained', 'Moderately well drained', 'Poorly drained', 'Very poorly drained', 'Somewhat excessively drained', 'Excessively drained'] :
                            analysisType === 'flooding' ?
                            ['Low', 'Moderate', 'High'] :
                            ['Favorable', 'Fair', 'Poor', 'Very poor'];
            
            const traces = categories.map((cat, i) => ({
                x: occupancies,
                y: occupancies.map(occ => {
                    const dataField = analysisType === 'drainage' ? 'drainage_distribution' :
                                    analysisType === 'flooding' ? 'flooding_distribution' :
                                    'engineering_distribution';
                    return soilAnalysisData.soil_by_occupancy[occ]?.[dataField]?.[cat] || 0;
                }),
                name: cat,
                type: 'bar',
                marker: {
                    color: plasmaColors[i % plasmaColors.length]
                }
            }));
            
            const layout = {
                title: {
                    text: `${analysisType.charAt(0).toUpperCase() + analysisType.slice(1)} by Occupancy Class`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { title: 'Occupancy Class' },
                yaxis: { title: 'Number of Buildings' },
                barmode: 'stack',
                height: 450
            };
            
            Plotly.newPlot('soilByOccupancyChart', traces, layout, {responsive: true});
        }
        
        // MODIFIED: updateSoilMap to include compname in tooltips
        function updateSoilMap() {
            if (!soilAnalysisData || !soilAnalysisData.spatial_distribution) {
                console.warn('No spatial distribution data available');
                return;
            }
            
            const showRiskOverlay = document.getElementById('showRiskOverlay').checked;
            const mapData = soilAnalysisData.spatial_distribution;
            
            // Now using up to 50,000 samples from the Python export
            console.log(`Soil map using ${mapData.length} samples`);
            
            // Create scatter mapbox
            const scatterData = [{
                type: 'scattermapbox',
                mode: 'markers',
                lon: mapData.map(d => d.lon),
                lat: mapData.map(d => d.lat),
                marker: {
                    size: 8,
                    color: mapData.map(d => {
                        if (showRiskOverlay) {
                            // Color by risk level
                            const isHighRisk = (d.drainage === 'Poorly drained' || 
                                              d.drainage === 'Very poorly drained' ||
                                              d.flooding === 'Frequent' || 
                                              d.flooding === 'Occasional');
                            return isHighRisk ? '#E53935' : '#2E7D32';
                        } else {
                            // Color by drainage class
                            return soilColors.drainage[d.drainage] || '#888';
                        }
                    }),
                    opacity: 0.6
                },
                text: mapData.map(d => 
                    `${d.occupancy}<br>` +
                    `Year: ${d.year_built}<br>` +
                    `Area: ${Math.round(d.area)} sqm<br>` +
                    `Drainage: ${d.drainage || 'N/A'}<br>` +
                    `Flooding: ${d.flooding || 'N/A'}<br>` +
                    `Soil Type: ${d.compname || 'Unknown'}`  // NEW: Added compname
                ),
                hovertemplate: '%{text}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: showRiskOverlay ? 
                        `Building Risk Map (With ${mapData.length.toLocaleString()} Samples)` :  // Updated title
                        `Soil Drainage Map (With ${mapData.length.toLocaleString()} Samples)`,  // Updated title
                    font: { size: 20, color: '#333' }
                },
                mapbox: {
                    style: 'open-street-map',
                    center: { lat: 42.3601, lon: -71.0589 },
                    zoom: 8
                },
                height: 600,
                margin: { t: 50, b: 0, l: 0, r: 0 }
            };
            
            Plotly.newPlot('soilMap', scatterData, layout, {responsive: true});
        }
        
        function updateWaterTableHistogram() {
            if (!soilAnalysisData || !soilAnalysisData.water_table_stats) {
                console.warn('No water table data available');
                return;
            }
            
            const stats = soilAnalysisData.water_table_stats;
            
            const sampleData = soilAnalysisData.spatial_distribution
                .map(d => d.water_table)
                .filter(val => val !== undefined && val !== null && val > 0);
            
            if (sampleData.length === 0) {
                document.getElementById('waterTableHistogram').innerHTML = 
                    '<p style="text-align:center; padding:50px;">Insufficient valid water table data</p>';
                return;
            }
            
            const validMean = sampleData.reduce((a, b) => a + b, 0) / sampleData.length;
            
            const histData = [{
                x: sampleData,
                type: 'histogram',
                nbinsx: 30,
                marker: {
                    color: '#4169E1',
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: 'Depth Range: %{x}<br>Count: %{y}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: `Water Table Depth Distribution (${sampleData.length} valid samples, ${(sampleData.length/soilAnalysisData.spatial_distribution.length*100).toFixed(1)}% of sample)`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Water Table Depth (cm)',
                    range: [0, 300]
                },
                yaxis: { 
                    title: 'Number of Buildings'
                },
                height: 400,
                shapes: [
                    {
                        type: 'line',
                        x0: validMean,
                        x1: validMean,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: {
                            color: 'red',
                            width: 2,
                            dash: 'dash'
                        }
                    }
                ],
                annotations: [
                    {
                        x: validMean,
                        y: 1,
                        yref: 'paper',
                        text: `Mean: ${validMean.toFixed(1)} cm (valid data only)`,
                        showarrow: true,
                        arrowhead: 2,
                        ax: 30,
                        ay: -30
                    }
                ]
            };
            
            Plotly.newPlot('waterTableHistogram', histData, layout, {responsive: true});
        }
        

        const dataSourceColumns = {
            'USA Structures': {
                color: '#667eea',
                icon: '🏢',
                description: 'Original building footprint and property data',
                columns: [
                    'fid', 'geom', 'BUILD_ID', 'OCC_CLS', 'PRIM_OCC', 'SEC_OCC', 'PROP_ADDR', 
                    'PROP_CITY', 'PROP_ST', 'PROP_ZIP', 'OUTBLDG', 'HEIGHT', 
                    'SQMETERS', 'SQFEET', 'H_ADJ_ELEV', 'L_ADJ_ELEV', 'FIPS', 
                    'CENSUSCODE', 'PROD_DATE', 'SOURCE', 'USNG', 'LONGITUDE', 
                    'LATITUDE', 'IMAGE_NAME', 'IMAGE_DATE', 'VAL_METHOD', 'REMARKS', 
                    'UUID', 'Est GWP kgCO2e', 'GWP Intensity', 'GWP class', 
                    'Est GFA sqft', 'Est GFA sqmeters', 'PRED_HEIGHT', 'OCC_CONFLICT', 
                    'conflict_type_details', 'OCC_DICT', 'MIX_SC', 'general_fnd_type', 
                    'Assumed Height', 'Shape_Length', 'Shape_Area'
                ]
            },
            'NSI': {
                color: '#764ba2',
                icon: '📊',
                description: 'National Structure Inventory enhancement data',
                columns: [
                    'nsi_id', 'year_built', 'material_type', 'material_type_desc', 
                    'foundation_type', 'nsi_occtype', 'nsi_num_story', 'structure_value', 
                    'nsi_sqft', 'nsi_unit_count', 'match_type', 'match_method',
                    'nsi_yr_built', 'yr_built_belong'
                ]
            },
            'Web Soil Survey': {
                color: '#f5576c',
                icon: '🌍',
                description: 'Soil properties and engineering characteristics',
                columns: [
                    'AREASYMBOL', 'SPATIALVER', 'MUSYM', 'MUKEY', 'soil_mukey', 
                    'comppct_r', 'compname', 'drainagecl', 'wtdepannmin', 
                    'flodfreqcl', 'soil_cokey', 'eng_property'
                ]
            },
            'Boston Approved Permit Dataset': {
                color: '#009688', // Teal color matching the CSS
                icon: '👷‍♂️',
                description: 'Demolition permit data for Boston',
                columns: ['DEMOLITION_TYPE', 'DEMOLITION_DATE','DEMOLITION_STATUS']
            },
            'MassGIS': {
                color: '#fb9f3a', 
                icon: '🏛️',
                description: 'Massachusetts tax parcel GIS dataset', 
                columns: ['massgis_yr_built']
            }
        };
        


        

        function updateOverview() {
            if (!buildingData) return;
            
            createDataSourcesFlowchart();
            
            let occupancyCounts;
            if (buildingData.overview_occupancy_counts) {
                occupancyCounts = buildingData.overview_occupancy_counts;
            } else {
                occupancyCounts = {};
                buildingData.temporal_data.forEach(d => {
                    if (!occupancyCounts[d.occupancy]) {
                        occupancyCounts[d.occupancy] = 0;
                    }
                    occupancyCounts[d.occupancy] += d.count;
                });
            }
            
            const total = Object.values(occupancyCounts).reduce((a, b) => a + b, 0);
            const pieValues = Object.values(occupancyCounts);
            const pieLabels = Object.keys(occupancyCounts);

            const textArray = pieLabels.map((label, i) => {
                const percentage = (pieValues[i] / total * 100);
                
                if (percentage > 10) {
                    return `${label}<br>${percentage.toFixed(1)}%`;
                } else if (percentage > 5) {
                    return `${percentage.toFixed(1)}%`;
                } else if (percentage > 2) {
                    return `${percentage.toFixed(0)}%`;
                } else {
                    return '';
                }
            });

            const pieData = [{
                values: pieValues,
                labels: pieLabels,
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: plasmaColors
                },
                text: textArray,
                textinfo: 'text',
                textposition: 'auto',
                textfont: {
                    size: 12,
                    color: 'white'
                },
                insidetextorientation: 'radial',
                hovertemplate: '%{label}<br>Count: %{value:,}<br>%{percent}<extra></extra>',
                showlegend: true
            }];
            
            const pieLayout = {
                title: {
                    text: 'All Buildings Distribution by Occupancy Class',
                    font: { size: 20, color: '#333' }
                },
                height: 500,
                font: { size: 14 },
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.05
                }
            };
            
            Plotly.newPlot('overviewChart', pieData, pieLayout, {responsive: true});
            
            const timelineData = [];
            const yearCounts = {};
            
            buildingData.temporal_data.forEach(d => {
                const displayKey = d.year.toString();
                if (!yearCounts[displayKey]) yearCounts[displayKey] = 0;
                yearCounts[displayKey] += d.count;
            });
            
            const years = Object.keys(yearCounts).sort((a, b) => {
                if (a === 'pre-1940') return -1;
                if (b === 'pre-1940') return 1;
                return parseInt(a) - parseInt(b);
            });
            const counts = years.map(y => yearCounts[y]);
            
            timelineData.push({
                x: years,
                y: counts,
                type: 'scatter',
                mode: 'lines',
                fill: 'tozeroy',
                line: {
                    color: plasmaColors[4],
                    width: 2
                },
                fillcolor: 'rgba(189, 55, 134, 0.2)',
                hovertemplate: 'Year: %{x}<br>Buildings: %{y:,}<extra></extra>'
            });
            
            const tickvals = years.filter((y, i) => {
                if (y === 'pre-1940') return false;
                const year = parseInt(y);
                return year % 10 === 0;
            });
            
            const timelineLayout = {
                title: {
                    text: 'Building Construction Timeline',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    rangeslider: { visible: true },
                    type: 'category',
                    tickmode: 'array',
                    tickvals: tickvals,
                    ticktext: tickvals
                },
                yaxis: { 
                    title: 'Number of Buildings',
                    fixedrange: false
                },
                height: 400,
                hovermode: 'x unified'
            };
            
            Plotly.newPlot('overviewTimelineChart', timelineData, timelineLayout, {responsive: true});
        }

        function populateOverviewFilters() {
            if (!buildingData || !buildingData.building_samples_random) return;

            const samples = buildingData.building_samples_random;
            
            // Get unique values for each category
            const occClasses = ['All', ...new Set(samples.map(s => s.OCC_CLS).filter(Boolean))];
            const materials = ['All', ...new Set(samples.map(s => s.material_type).filter(Boolean))];
            const foundations = ['All', ...new Set(samples.map(s => s.foundation_type).filter(Boolean))];

            // Helper function to populate a select dropdown
            const populate = (selectId, options, map = null) => {
                const select = document.getElementById(selectId);
                select.innerHTML = options.map(opt => {
                    const label = map && map[opt] ? `${opt} - ${map[opt]}` : opt;
                    const value = opt === 'All' ? 'All' : opt;
                    return `<option value="${value}">${label}</option>`;
                }).join('');
            };
            
            // Populate the dropdowns
            populate('overviewOccFilter', occClasses);
            populate('overviewMaterialFilter', materials, materialTypeMap);
            populate('overviewFoundationFilter', foundations, foundationTypeMap);
        }

        // Define fixed color mapping for OCC_CLS using plasma gradient from dark to light
        const FIXED_OCC_COLORS = {
            'Residential': '#0d0887',      // Darkest purple
            'Commercial': '#46039f',       // Deep blue-purple  
            'Government': '#7201a8',       // Purple
            'Industrial': '#9c179e',       // Pink-purple
            'Assembly': '#bd3786',         // Magenta
            'Unclassified': '#d8576b',     // Rose
            'Education': '#ed7953',        // Orange
            'Utility and Misc': '#fb9f3a', // Light orange
            'Agriculture': '#f0f921'       // Brightest yellow
        };


        // Fixed colors for materials (dark to light as specified)
        const FIXED_MATERIAL_COLORS = {
            'W': '#0d0887',  // Wood - Darkest purple
            'M': '#46039f',  // Masonry - Deep blue-purple
            'S': '#7201a8',  // Steel - Purple
            'C': '#bd3786',  // Concrete - Magenta
            'H': '#f0f921'   // Manufactured - Brightest yellow
        };

        // Fixed colors for foundations (dark to light as specified)
        const FIXED_FOUNDATION_COLORS = {
            'B': '#0d0887',  // Basement - Darkest purple
            'S': '#46039f',  // Slab - Deep blue-purple
            'C': '#7201a8',  // Crawl Space - Purple
            'I': '#9c179e',  // Pile - Pink-purple
            'P': '#bd3786',  // Pier - Magenta
            'W': '#ed7953',  // Solid Wall - Orange
            'F': '#f0f921'   // Fill - Brightest yellow
        };

        function handleColorByChange() {
            createOverviewMap();
        }

        function calculateMarkerSize(area) {
            if (!area || area <= 0) return 6; 

            return Math.max(6, Math.min(30, Math.sqrt(area) * 0.18 + 4)); 
        }

        function onOverviewKChange() {
            populateOverviewClusterFilter();
            createOverviewMap();
        }

        function populateOverviewClusterFilter() {
            const kSelector = document.getElementById('overviewKSelector');
            const filterSelect = document.getElementById('overviewClusterFilter');
            if (!kSelector || !filterSelect) return;
            
            const k = parseInt(kSelector.value);
            const currentVal = filterSelect.value;
            
            let html = '<option value="All">All Clusters</option>';
            for (let i = 0; i < k; i++) {
                html += `<option value="${i}">Cluster ${i + 1}</option>`;
            }
            filterSelect.innerHTML = html;
            
            if (currentVal !== 'All' && parseInt(currentVal) < k) {
                filterSelect.value = currentVal;
            } else {
                filterSelect.value = 'All';
            }
        }

        function createOverviewMap() {
            // 1. Safety Check
            if (!buildingData || !buildingData.building_samples_random) return;

            // --- A. GET UI STATES ---
            const occFilter = document.getElementById('overviewOccFilter').value;
            const materialFilter = document.getElementById('overviewMaterialFilter').value;
            const foundationFilter = document.getElementById('overviewFoundationFilter').value;
            const colorBy = document.getElementById('overviewColorBy').value;
            const sizeByGFA = document.getElementById('overviewSizeByGFA').checked;
            
            // Get selected K value (default to 7 if element missing)
            const kSelector = document.getElementById('overviewKSelector');
            const selectedK = kSelector ? kSelector.value : '7'; 
            const clusterFilterVal = document.getElementById('overviewClusterFilter') ? document.getElementById('overviewClusterFilter').value : 'All';
            // --- B. FILTER DATA ---
            let filteredData = buildingData.building_samples_random.filter(d => {
                const occMatch = (occFilter === 'All' || d.OCC_CLS === occFilter);
                const materialMatch = (materialFilter === 'All' || d.material_type === materialFilter);
                const foundationMatch = (foundationFilter === 'All' || d.foundation_type === foundationFilter);

                let clusterMatch = true;
                if (clusterFilterVal !== 'All') {
                    const kKey = `cluster_base_k${selectedK}`;
                    if (d[kKey] != clusterFilterVal) {
                        clusterMatch = false;
                    }
                }

            return d.LATITUDE && d.LONGITUDE && occMatch && materialMatch && foundationMatch && clusterMatch;
            });

            // --- C. DOWNSAMPLE ---
            if (filteredData.length > 75000) {
                filteredData = filteredData.sort(() => 0.5 - Math.random()).slice(0, 75000);
            }

            if (filteredData.length === 0) {
                document.getElementById('overviewMapPlot').innerHTML = '<p style="text-align:center; padding-top:100px;">No data available.</p>';
                renderSizeLegend(false); // Hide overlay if no data
                return;
            }

            // --- D. STYLES (SIZING & OPACITY) ---
            const markerSizes = sizeByGFA 
                ? filteredData.map(d => calculateMarkerSize(d['Est GFA sqmeters']))
                : 8; 

            const markerOpacity = sizeByGFA ? 0.5 : 0.7;
            const markerLine = sizeByGFA ? { width: 0 } : { width: 0.5, color: 'rgba(255,255,255,0.3)' };

            let mapData = [];
            let layoutSettings = {};

            // --- E. COLORING LOGIC ---

            // === CASE 1: COLOR BY SIMPLE CLUSTER (K-MEANS) ===
            if (colorBy === 'cluster') {
                const kKey = `cluster_base_k${selectedK}`;
                const clusterColors = getPlasmaColors(parseInt(selectedK));

                const clusterTrace = {
                    type: 'scattermapbox',
                    lon: filteredData.map(d => d.LONGITUDE),
                    lat: filteredData.map(d => d.LATITUDE),
                    mode: 'markers',
                    marker: {
                        size: markerSizes,
                        color: filteredData.map(d => {
                            const cVal = d[kKey]; 
                            return (cVal !== undefined && cVal !== null) ? clusterColors[cVal] : '#999';
                        }),
                        opacity: markerOpacity,
                        line: markerLine
                    },
                    text: filteredData.map(d => 
                        `<b>Cluster (K=${selectedK}):</b> ${d[kKey] !== undefined ? parseInt(d[kKey]) + 1 : 'N/A'}<br>` +
                        `<b>Occupancy:</b> ${d.OCC_CLS || 'N/A'}<br>` +
                        `<b>GFA:</b> ${Math.round(d['Est GFA sqmeters']).toLocaleString()} sqm`
                    ),
                    hovertemplate: '%{text}<extra></extra>',
                    showlegend: false
                };

                const dummyTraces = [];
                for(let i=0; i<parseInt(selectedK); i++) {
                    dummyTraces.push({
                        type: 'scattermapbox',
                        lon: [null], lat: [null], mode: 'markers',
                        name: `Cluster ${i+1}`,
                        marker: { size: 10, color: clusterColors[i] },
                        showlegend: true,
                        hoverinfo: 'skip'
                    });
                }
                mapData = [clusterTrace, ...dummyTraces];
                layoutSettings = { 
                    showlegend: true,
                    legend: { 
                        x: 1.02, 
                        y: 1, 
                        yanchor: 'top',
                        bgcolor: 'rgba(255,255,255,0.95)', 
                        
                        borderwidth: 0,  
                        
                        font: { size: 11 }
                    }
                };

            // === CASE 2: COLOR BY GFA (CONTINUOUS) ===
            } else if (colorBy === 'Est GFA sqmeters') {
                
                const gfaValues = filteredData.map(d => d['Est GFA sqmeters']);
                const logValues = gfaValues.map(v => (v > 0 ? Math.log10(v) : 0));

                mapData = [{
                    type: 'scattermapbox',
                    lon: filteredData.map(d => d.LONGITUDE),
                    lat: filteredData.map(d => d.LATITUDE),
                    mode: 'markers',
                    marker: {
                        size: markerSizes,
                        color: logValues,
                        colorscale: 'Plasma', 
                        showscale: true,
                        opacity: markerOpacity,
                        colorbar: {
                            title: 'GFA (Log Scale)',
                            titleside: 'right',
                            tickvals: [2, 3, 4, 5, 6],
                            ticktext: ['100m²', '1k', '10k', '100k', '1M'],
                            
                            y: 1,         
                            yanchor: 'top',  
                            len: 0.5,        
                            
                            thickness: 15  
                        }
                    },
                    text: filteredData.map(d => 
                        `<b>Occupancy:</b> ${d.OCC_CLS}<br>` +
                        `<b>Total GFA:</b> ${Math.round(d['Est GFA sqmeters']).toLocaleString()} sqm<br>` +
                        `<b>Year:</b> ${d.year_built}`
                    ),
                    hovertemplate: '%{text}<extra></extra>',
                    showlegend: false
                }];
                layoutSettings = { showlegend: false };

            // === CASE 3: COLOR BY CATEGORY (RESTORED SORTING) ===
            } else {
                let colorMap;
                let sortOrder = [];

                // 1. Define strict sort order to match Plasma Gradient (Dark -> Light)
                if (colorBy === 'OCC_CLS') {
                    colorMap = FIXED_OCC_COLORS;
                    sortOrder = ['Residential', 'Commercial', 'Government', 'Industrial', 
                                'Assembly', 'Unclassified', 'Education', 'Utility and Misc', 'Agriculture'];
                } else if (colorBy === 'material_type') {
                    colorMap = FIXED_MATERIAL_COLORS;
                    sortOrder = ['W', 'M', 'S', 'C', 'H'];
                } else if (colorBy === 'foundation_type') {
                    colorMap = FIXED_FOUNDATION_COLORS;
                    sortOrder = ['B', 'S', 'C', 'I', 'P', 'W', 'F'];
                }

                // 2. Get unique categories and SORT them based on the fixed order
                const colorValues = filteredData.map(d => d[colorBy]);
                const uniqueCats = [...new Set(colorValues)].filter(c => c != null);
                
                if (sortOrder.length > 0) {
                    uniqueCats.sort((a, b) => sortOrder.indexOf(a) - sortOrder.indexOf(b));
                } else {
                    uniqueCats.sort();
                }

                // 3. Create Dummy Legend Traces (In correct order)
                const dummyTraces = uniqueCats.map(cat => ({
                    type: 'scattermapbox',
                    lon: [null], lat: [null], mode: 'markers',
                    marker: { size: 10, color: colorMap[cat] || '#999' },
                    // Resolve codes to names
                    name: colorBy === 'material_type' ? (materialTypeMap[cat] || cat) :
                        colorBy === 'foundation_type' ? (foundationTypeMap[cat] || cat) :
                        cat,
                    showlegend: true,
                    hoverinfo: 'skip'
                }));

                // 4. Main Trace
                const mainTrace = {
                    type: 'scattermapbox',
                    lon: filteredData.map(d => d.LONGITUDE),
                    lat: filteredData.map(d => d.LATITUDE),
                    mode: 'markers',
                    marker: {
                        size: markerSizes,
                        color: colorValues.map(v => colorMap[v] || '#999'),
                        opacity: markerOpacity,
                        line: markerLine
                    },
                    text: filteredData.map(d => 
                        `<b>Year Built:</b> ${d.year_built}<br>` +
                        `<b>Occupancy:</b> ${d.OCC_CLS || 'N/A'}<br>` +
                        `<b>Material:</b> ${materialTypeMap[d.material_type] || d.material_type || 'N/A'}<br>` +
                        `<b>Foundation:</b> ${foundationTypeMap[d.foundation_type] || d.foundation_type || 'N/A'}<br>` +
                        `<b>GFA:</b> ${Math.round(d['Est GFA sqmeters']).toLocaleString()} sqm`
                    ),
                    hovertemplate: '%{text}<extra></extra>',
                    showlegend: false
                };

                mapData = [mainTrace, ...dummyTraces];

                layoutSettings = { 
                    showlegend: true,
                    legend: {
                        x: 1.02,
                        y: 1,
                        yanchor: 'top',
                        bgcolor: 'rgba(255,255,255,0.95)',
                        
                        borderwidth: 0, 
                        
                        font: { size: 11 },
                        title: {
                            text: colorBy === 'OCC_CLS' ? 'Occupancy Class' :
                                colorBy === 'material_type' ? 'Material Type' :
                                'Foundation Type',
                            font: { size: 13, color: '#333' }
                        }
                    }
                };
            }

            // --- F. LAYOUT ---
            const layout = {
                title: {
                    text: `Massachusetts Building Distribution ${sizeByGFA ? '(Sized by GFA)' : ''} (${filteredData.length} points)`,
                    font: { size: 20, color: '#333' }
                },
                mapbox: {
                    style: 'open-street-map',
                    center: { lat: 42.3601, lon: -71.0589 },
                    zoom: 8
                },
                height: 600,
                margin: { t: 50, b: 0, l: 0, r: 150 },
                ...layoutSettings
            };

            const plotDiv = document.getElementById('overviewMapPlot');
            let savedView = null;
            if (plotDiv && plotDiv.layout && plotDiv.layout.mapbox) {
                savedView = {
                    center: plotDiv.layout.mapbox.center,
                    zoom: plotDiv.layout.mapbox.zoom
                };
            }

            if (savedView) {
                layout.mapbox.center = savedView.center;
                layout.mapbox.zoom = savedView.zoom;
            }

            Plotly.newPlot('overviewMapPlot', mapData, layout, {responsive: true});

            // --- G. RENDER SIZE LEGEND ---
            renderSizeLegend(sizeByGFA);
        }


        function renderSizeLegend(isVisible) {
            const container = document.getElementById('mapLegendOverlay');
            if (!isVisible) {
                container.style.display = 'none';
                return;
            }

            // Define sample areas to show in legend
            const legendSamples = [
                { label: '100 m²', area: 100 },
                { label: '1,000 m²', area: 1000 },
                { label: '10,000 m²', area: 10000 },
                { label: '50,000 m²', area: 50000 }
            ];

            let html = '<strong>Size Legend (GFA)</strong><br><br>';
            
            legendSamples.forEach(item => {
                // Use the exact same math function as the map
                const radius = calculateMarkerSize(item.area);
                // Multiply by 2 for CSS width/height (diameter)
                const diameter = radius * 2; 
                
                html += `
                    <div class="size-legend-item">
                        <div class="size-legend-circle" style="width: ${diameter}px; height: ${diameter}px;"></div>
                        <span>${item.label}</span>
                    </div>
                `;
            });

            html += `
                <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #eee; font-size: 0.85em; color: #555; line-height: 1.3;">
                    <em>Radius (px) = &radic;<span style="text-decoration:overline;">Area</span> * 0.18 + 4</em><br>
                    <span style="color: #777;">(Min: 6px, Max: 30px)</span>
                </div>
            `;

            container.innerHTML = html;
            container.style.display = 'block';
        }

        function populateHistoricShorelineFilters() {
            // Check if the historic data is loaded and is an array.
            if (!historicShorelineData || !Array.isArray(historicShorelineData)) return;

            const samples = historicShorelineData;
            
            // Get unique values for each category from the dataset.
            const occClasses = ['All', ...new Set(samples.map(s => s.OCC_CLS).filter(Boolean))];
            const materials = ['All', ...new Set(samples.map(s => s.material_type).filter(Boolean))];
            const foundations = ['All', ...new Set(samples.map(s => s.foundation_type).filter(Boolean))];

            /**
             * Helper function to populate a select dropdown.
             * @param {string} selectId - The ID of the select element.
             * @param {Array<string>} options - The array of options to add.
             * @param {Object|null} map - A mapping for display labels (e.g., 'W' -> 'Wood').
             */
            const populate = (selectId, options, map = null) => {
                const select = document.getElementById(selectId);
                // Clear existing options before populating
                select.innerHTML = ''; 
                select.innerHTML = options.map(opt => {
                    const label = map && map[opt] ? `${opt} - ${map[opt]}` : opt;
                    const value = opt === 'All' ? 'All' : opt;
                    return `<option value="${value}">${label}</option>`;
                }).join('');
            };
            
            // Populate the dropdowns with unique IDs for the historic section.
            populate('historicOccFilter', occClasses);
            populate('historicMaterialFilter', materials, materialTypeMap);
            populate('historicFoundationFilter', foundations, foundationTypeMap);
        }


        /**
         * Creates and updates the interactive map for buildings on historic filled land.
         * This function is a direct adaptation of createOverviewMap(), but targets
         * the new data source (historicShorelineData) and new HTML element IDs.
         */
        function createHistoricShorelineMap() {
            // Check if the historic data is available. If not, show a message and exit.
            if (!historicShorelineData) {
                document.getElementById('historicShorelineMapPlot').innerHTML = '<p style="text-align:center; padding-top:100px;">Historic shoreline data is not loaded.</p>';
                return;
            }

            // Get current filter values from the historic section's controls (dropdowns).
            const occFilter = document.getElementById('historicOccFilter').value;
            const materialFilter = document.getElementById('historicMaterialFilter').value;
            const foundationFilter = document.getElementById('historicFoundationFilter').value;
            const colorBy = document.getElementById('historicColorBy').value;

            // Filter the data based on user selections.
            let filteredData = historicShorelineData.filter(d => {
                const occMatch = (occFilter === 'All' || d.OCC_CLS === occFilter);
                const materialMatch = (materialFilter === 'All' || d.material_type === materialFilter);
                const foundationMatch = (foundationFilter === 'All' || d.foundation_type === foundationFilter);
                // Ensure the point has valid coordinates to be plotted.
                return d.LATITUDE && d.LONGITUDE && occMatch && materialMatch && foundationMatch;
            });

            // If there's no data after filtering, display a message.
            if (filteredData.length === 0) {
                document.getElementById('historicShorelineMapPlot').innerHTML = '<p style="text-align:center; padding-top:100px;">No data available for the current filter selection.</p>';
                return;
            }
            
            // Choose the appropriate fixed color mapping based on the 'Color By' dropdown.
            let colorMap;
            if (colorBy === 'OCC_CLS') {
                colorMap = FIXED_OCC_COLORS;
            } else if (colorBy === 'material_type') {
                colorMap = FIXED_MATERIAL_COLORS;
            } else if (colorBy === 'foundation_type') {
                colorMap = FIXED_FOUNDATION_COLORS;
            }
            
            // Get unique categories present in the filtered data to create the legend.
            const colorValues = filteredData.map(d => d[colorBy]);
            const uniqueCategories = [...new Set(colorValues)].filter(cat => cat != null);
            
            // Sort categories for a consistent legend order.
            if (colorBy === 'OCC_CLS') {
                const occOrder = ['Residential', 'Commercial', 'Government', 'Industrial', 
                                'Assembly', 'Unclassified', 'Education', 'Utility and Misc', 'Agriculture'];
                uniqueCategories.sort((a, b) => occOrder.indexOf(a) - occOrder.indexOf(b));
            } else if (colorBy === 'material_type') {
                const materialOrder = ['W', 'M', 'S', 'C', 'H'];
                uniqueCategories.sort((a, b) => materialOrder.indexOf(a) - materialOrder.indexOf(b));
            } else if (colorBy === 'foundation_type') {
                const foundationOrder = ['B', 'S', 'C', 'I', 'P', 'W', 'F'];
                uniqueCategories.sort((a, b) => foundationOrder.indexOf(a) - foundationOrder.indexOf(b));
            } else {
                uniqueCategories.sort();
            }
            
            // Create dummy traces (invisible points) for the legend.
            const legendTraces = uniqueCategories.map(cat => ({
                type: 'scattermapbox',
                lon: [null], lat: [null], mode: 'markers',
                marker: { size: 10, color: colorMap[cat] || '#999999' },
                name: colorBy === 'material_type' ? (materialTypeMap[cat] || cat) :
                    colorBy === 'foundation_type' ? (foundationTypeMap[cat] || cat) :
                    cat,
                showlegend: true, hoverinfo: 'skip'
            }));
            
            // Create the main trace with all the visible building points.
            const mainTrace = {
                type: 'scattermapbox',
                lon: filteredData.map(d => d.LONGITUDE),
                lat: filteredData.map(d => d.LATITUDE),
                mode: 'markers',
                marker: {
                    size: 10,
                    color: colorValues.map(v => colorMap[v] || '#999999'),
                    opacity: 0.8,
                    line: { width: 0.5, color: 'rgba(255,255,255,0.3)' }
                },
                // Define the text that appears on hover.
                text: filteredData.map(d => 
                    `<b>Year Built:</b> ${d.year_built}<br>` +
                    `<b>Occupancy:</b> ${d.OCC_CLS || 'N/A'}<br>` +
                    `<b>Material:</b> ${materialTypeMap[d.material_type] || d.material_type || 'N/A'}<br>` +
                    `<b>Foundation:</b> ${foundationTypeMap[d.foundation_type] || d.foundation_type || 'N/A'}`
                ),
                hovertemplate: '%{text}<extra></extra>',
                showlegend: false
            };
            
            // Combine the main trace and legend traces into one array for plotting.
            const mapData = [mainTrace, ...legendTraces];
            
            // Define the layout for the map (title, map style, center, zoom, etc.).
            const layout = {
                title: {
                    text: `Buildings on Reclaimed Land (${filteredData.length} points shown)`,
                    font: { size: 20, color: '#333' }
                },
                mapbox: {
                    style: 'open-street-map',
                    // Center the map on Boston.
                    center: { lat: 42.355, lon: -71.06 },
                    zoom: 12.5 // Zoom in closer on Boston
                },
                height: 600,
                margin: { t: 50, b: 0, l: 0, r: 120 },
                showlegend: true,
                legend: {
                    x: 1.02, y: 0.5, yanchor: 'middle',
                    bgcolor: 'rgba(255,255,255,0.95)',
                    bordercolor: '#ccc', borderwidth: 1,
                    font: { size: 11 },
                    title: {
                        text: colorBy === 'OCC_CLS' ? 'Occupancy Class' :
                            colorBy === 'material_type' ? 'Material Type' :
                            'Foundation Type',
                        font: { size: 13, color: '#333' }
                    }
                }
            };

            // Render the plot in the designated div using Plotly.
            Plotly.newPlot('historicShorelineMapPlot', mapData, layout, {responsive: true});
        }

        function updateHistoricShorelineCharts() {
            if (!historicShorelineData) return;

            // Get current filter values from the controls.
        
            const occFilter = document.getElementById('historicOccFilter').value;
            const materialFilter = document.getElementById('historicMaterialFilter').value;
            const foundationFilter = document.getElementById('historicFoundationFilter').value;

            // Filter the data based on user selections. This is done only once here.
           
            const filteredData = historicShorelineData.filter(d => {
                const occMatch = (occFilter === 'All' || d.OCC_CLS === occFilter);
                const materialMatch = (materialFilter === 'All' || d.material_type === materialFilter);
                const foundationMatch = (foundationFilter === 'All' || d.foundation_type === foundationFilter);
                return d.LATITUDE && d.LONGITUDE && occMatch && materialMatch && foundationMatch;
            });

            // Call all the chart-drawing functions with the filtered data.
         
            createHistoricShorelineMap(filteredData); // Update the map 
            createHistoricOccupancyChart(filteredData); // Update the new Occupancy chart 
            createHistoricYearChart(filteredData); // Update the new Year chart 
            createHistoricMaterialChart(filteredData); // Update the new Material chart 
            createHistoricFoundationChart(filteredData); // Update the new Foundation chart 
        }

        // --- Boston Foundation Analysis Logic (Updated for Radio Buttons) ---

        const BF_COLORS = {
            'Slab': '#0d0887',
            'Crawl Space': '#5c01a6',
            'Basement': '#9c179e',
            'Solid Wall': '#cc4778',
            'Pier': '#ed7953',
            'Pile': '#f89540',
            'Fill': '#fdb42f',
            'Unknown': '#cccccc'
        };

        function initBostonFoundationAnalysis() {
            const data = buildingData.boston_full_analysis;
            if (!data) {
                console.warn("Boston full analysis data missing.");
                return;
            }

            // 1. Update Summary 
            document.getElementById('bf_total').textContent = data.summary.total_boston.toLocaleString();
            document.getElementById('bf_shoreline').textContent = data.summary.shoreline_count.toLocaleString();
            document.getElementById('bf_original').textContent = data.summary.non_shoreline_count.toLocaleString();
            document.getElementById('bf_valid').textContent = data.summary.valid_foundation_count.toLocaleString();

            const bins = data.bin_order;

            // Helper function to create Radio Buttons for BINS 
            const createBinRadios = (containerId, nameGroup, callbackStr, defaultVal) => {
                const container = document.getElementById(containerId);
                container.innerHTML = bins.map(b => {
                    const isChecked = b === defaultVal ? 'checked' : '';
                    const inputId = `${nameGroup}_${b.replace(/[^a-z0-9]/gi, '')}`; 
                    return `
                        <label class="radio-pill" for="${inputId}">
                            <input type="radio" id="${inputId}" name="${nameGroup}" value="${b}" ${isChecked} onchange="${callbackStr}">
                            <span>${b}</span>
                        </label>
                    `;
                }).join('');
            };

            const landContainer = document.getElementById('section2-land-radios');
            const landOptions = [
                { label: 'Original Land', value: 'original' },
                { label: 'Shoreline Land', value: 'shoreline' }
            ];
            landContainer.innerHTML = landOptions.map(opt => {
                const isChecked = opt.value === 'original' ? 'checked' : ''; 
                const inputId = `s2_land_${opt.value}`;
                return `
                    <label class="radio-pill" for="${inputId}">
                        <input type="radio" id="${inputId}" name="s2_land" value="${opt.value}" ${isChecked} onchange="updateBFSection2()">
                        <span>${opt.label}</span>
                    </label>
                `;
            }).join('');

            // 2. Populate Bin Radios 
            createBinRadios('section1-bin-radios', 's1_bin', 'updateBFSection1()', '0-24 ft');
            createBinRadios('section2-bin1-radios', 's2_bin1', 'updateBFSection2()', '0-24 ft');
            createBinRadios('section2-bin2-radios', 's2_bin2', 'updateBFSection2()', '24-72 ft');

            // 3. Initial Draw
            updateBFSection1();
            updateBFSection2();
        }

        // --- Section 4: CLF Metadata Height Analysis ---

        function initCLFMetadataSection() {
            const data = buildingData.clf_metadata_height;
            if (!data) {
                console.warn("CLF metadata height data not available.");
                document.getElementById('section4-content').innerHTML = '<p style="color: #999;">CLF metadata not available.</p>';
                return;
            }
            
            const bins = data.bin_order;
            
            // Display total info
            document.getElementById('s4-total-info').textContent = 
                `Total CLF Buildings (with height data): ${data.total_buildings}`;
            
            // Create radio buttons for bin selection
            const createBinRadios = (containerId, nameGroup, defaultVal) => {
                const container = document.getElementById(containerId);
                container.innerHTML = bins.map(b => {
                    const isChecked = b === defaultVal ? 'checked' : '';
                    const inputId = `${nameGroup}_${b.replace(/[^a-z0-9]/gi, '')}`;
                    return `
                        <label class="radio-pill" for="${inputId}">
                            <input type="radio" id="${inputId}" name="${nameGroup}" value="${b}" ${isChecked} onchange="updateCLFSection4()">
                            <span>${b}</span>
                        </label>
                    `;
                }).join('');
            };
            
            createBinRadios('section4-bin1-radios', 's4_bin1', '0-24 ft');
            createBinRadios('section4-bin2-radios', 's4_bin2', '24-72 ft');
            
            updateCLFSection4();
        }

        function updateCLFSection4() {
            const data = buildingData.clf_metadata_height;
            if (!data) return;
            
            const r1 = document.querySelector('input[name="s4_bin1"]:checked');
            const r2 = document.querySelector('input[name="s4_bin2"]:checked');
            if (!r1 || !r2) return;
            
            const bin1 = r1.value;
            const bin2 = r2.value;
            
            const stats1 = data.data[bin1];
            const stats2 = data.data[bin2];
            
            // Update Bin 1
            document.getElementById('s4-bin1-n').textContent = `(n=${stats1.total})`;
            document.getElementById('s4-bin1-table').innerHTML = generateCLFMetadataTable(stats1.breakdown, stats1.total);
            drawCLFMetadataCharts('s4-bin1-bar', 's4-bin1-pie', stats1.chart_data, bin1);
            
            // Update Bin 2
            document.getElementById('s4-bin2-n').textContent = `(n=${stats2.total})`;
            document.getElementById('s4-bin2-table').innerHTML = generateCLFMetadataTable(stats2.breakdown, stats2.total);
            drawCLFMetadataCharts('s4-bin2-bar', 's4-bin2-pie', stats2.chart_data, bin2);
        }

        function generateCLFMetadataTable(breakdown, total) {
            if (total === 0) return '<p>No data for this height bin</p>';
            
            let html = '<table style="width:100%; border-collapse: collapse; font-size: 0.9em;">';
            html += '<tr style="background:#eee;"><th style="padding:5px; text-align:left;">CLF Foundation Type</th><th style="padding:5px; text-align:right;">Count</th><th style="padding:5px; text-align:right;">%</th></tr>';
            
            breakdown.forEach(row => {
                html += `<tr style="border-bottom: 1px solid #f0f0f0;">
                    <td style="padding:5px;">${row.foundation}</td>
                    <td style="padding:5px; text-align:right;">${row.count.toLocaleString()}</td>
                    <td style="padding:5px; text-align:right;">${row.pct}%</td>
                </tr>`;
            });
            
            html += '</table>';
            return html;
        }

        // Fixed colors for CLF foundation types
        const CLF_FDN_COLORS = {
            'Shallow foundation': '#0d0887',
            "Deep foundation < 50' (15m)": '#9c179e',
            "Deep foundation > 50' (15m)": '#ed7953',
            'Other Foundation System': '#f0f921'
        };

        function drawCLFMetadataCharts(containerBar, containerPie, chartData, titleSuffix) {
            const colors = chartData.map(d => CLF_FDN_COLORS[d.foundation] || '#999');
            
            // Bar chart
            Plotly.newPlot(containerBar, [{
                x: chartData.map(d => d.foundation),
                y: chartData.map(d => d.count),
                type: 'bar',
                marker: { color: colors },
                text: chartData.map(d => d.count.toLocaleString()),
                textposition: 'auto',
                textangle: 0,
                textfont: { size: 16 }
            }], {
                title: { text: `CLF Foundation Counts (${titleSuffix})`, font: {size: 16} },
                margin: { t: 40, b: 150, l: 50, r: 20 },
                height: 450,
                xaxis: { tickangle: -30, title: { text: 'CLF Foundation Type', standoff: 20 } },
                yaxis: { title: 'Count' }
            }, {responsive: true});
            
            // Pie chart
            Plotly.newPlot(containerPie, [{
                labels: chartData.map(d => d.foundation),
                values: chartData.map(d => d.count),
                type: 'pie',
                marker: { colors: colors },
                textinfo: 'percent',
                textposition: 'inside',
                hole: 0.4
            }], {
                title: { text: `CLF Distribution (${titleSuffix})`, font: {size: 16} },
                margin: { t: 40, b: 40, l: 20, r: 20 },
                height: 450,
                showlegend: true,
                legend: { orientation: 'v', x: 1.05, y: 0.5, xanchor: 'left', yanchor: 'middle' }
            }, {responsive: true});
        }

        // Updated to read from Radio Buttons
        function updateBFSection1() {
            const data = buildingData.boston_full_analysis;
            
            // Get value from checked radio in the group 's1_bin'
            const selectedRadio = document.querySelector('input[name="s1_bin"]:checked');
            if (!selectedRadio) return;
            const bin = selectedRadio.value;

            const origStats = data.data.original[bin];
            const shoreStats = data.data.shoreline[bin];

            // Original Side
            document.getElementById('s1-orig-n').textContent = `(n=${origStats.total.toLocaleString()})`;
            document.getElementById('s1-orig-table').innerHTML = generateStatsTable(origStats.breakdown, origStats.total);
            drawBFCharts('s1-orig-bar', 's1-orig-pie', origStats.chart_data, 'Original');

            // Shoreline Side
            document.getElementById('s1-shore-n').textContent = `(n=${shoreStats.total.toLocaleString()})`;
            document.getElementById('s1-shore-table').innerHTML = generateStatsTable(shoreStats.breakdown, shoreStats.total);
            drawBFCharts('s1-shore-bar', 's1-shore-pie', shoreStats.chart_data, 'Shoreline');
        }

        function updateBFSection2() {
            const data = buildingData.boston_full_analysis;
            
            const landRadio = document.querySelector('input[name="s2_land"]:checked');
            if (!landRadio) return; 
            const landType = landRadio.value;
            
            const r1 = document.querySelector('input[name="s2_bin1"]:checked');
            const r2 = document.querySelector('input[name="s2_bin2"]:checked');
            
            if (!r1 || !r2) return;
            
            const bin1 = r1.value;
            const bin2 = r2.value;

            const stats1 = data.data[landType][bin1];
            const stats2 = data.data[landType][bin2];

            document.getElementById('s2-bin1-n').textContent = `(n=${stats1.total.toLocaleString()})`;
            document.getElementById('s2-bin1-table').innerHTML = generateStatsTable(stats1.breakdown, stats1.total);
            drawBFCharts('s2-bin1-bar', 's2-bin1-pie', stats1.chart_data, bin1);

            document.getElementById('s2-bin2-n').textContent = `(n=${stats2.total.toLocaleString()})`;
            document.getElementById('s2-bin2-table').innerHTML = generateStatsTable(stats2.breakdown, stats2.total);
            drawBFCharts('s2-bin2-bar', 's2-bin2-pie', stats2.chart_data, bin2);
        }

        /**
        * Generate statistics table with optional CLF Foundation Type column
        * @param {Array} breakdown - Array of {foundation, count, pct} objects
        * @param {number} total - Total count
        * @returns {string} HTML table string
        */
        function generateStatsTable(breakdown, total) {
            if (total === 0) return '<p>No data</p>';
            
            // Check if we should collapse as CLF
            if (bfCollapseAsCLF) {
                return generateCLFCollapsedTable(breakdown, total);
            }
            
            // Normal mode: show CLF Foundation Type column + Type column
            let html = '<table style="width:100%; border-collapse: collapse; font-size: 0.9em;">';
            html += `<tr style="background:#eee;">
                <th style="padding:5px; text-align:left; border-right: 1px solid #ddd;">CLF Foundation Type</th>
                <th style="padding:5px; text-align:left;">Type</th>
                <th style="padding:5px; text-align:right;">Count</th>
                <th style="padding:5px; text-align:right;">%</th>
            </tr>`;
            
            // Sort breakdown by CLF category order first
            const sortedBreakdown = [...breakdown].sort((a, b) => {
                const clfA = CLF_FOUNDATION_MAP[a.foundation] || 'Other Foundation System';
                const clfB = CLF_FOUNDATION_MAP[b.foundation] || 'Other Foundation System';
                const orderA = CLF_FOUNDATION_ORDER.indexOf(clfA);
                const orderB = CLF_FOUNDATION_ORDER.indexOf(clfB);
                return orderA - orderB;
            });
            
            // Track which CLF types have been shown (for rowspan)
            let lastCLF = null;
            const clfCounts = {};
            
            // First pass: count how many rows per CLF type
            sortedBreakdown.forEach(row => {
                const clfType = CLF_FOUNDATION_MAP[row.foundation] || 'Other Foundation System';
                clfCounts[clfType] = (clfCounts[clfType] || 0) + 1;
            });
            
            // Track which CLF types have started
            const clfStarted = {};
            
            sortedBreakdown.forEach(row => {
                const clfType = CLF_FOUNDATION_MAP[row.foundation] || 'Other Foundation System';
                const isNewCLF = !clfStarted[clfType];
                
                html += `<tr style="border-bottom: 1px solid #f0f0f0;">`;
                
                // Add CLF column cell (with rowspan for first occurrence)
                if (isNewCLF) {
                    const rowspan = clfCounts[clfType];
                    html += `<td style="padding:5px; border-right: 1px solid #ddd; vertical-align: middle;" rowspan="${rowspan}">
                        ${clfType}
                    </td>`;
                    clfStarted[clfType] = true;
                }
                
                html += `<td style="padding:5px;">${row.foundation}</td>
                    <td style="padding:5px; text-align:right;">${row.count.toLocaleString()}</td>
                    <td style="padding:5px; text-align:right;">${row.pct}%</td>
                </tr>`;
            });
            
            html += '</table>';
            return html;
        }

        /**
        * Generate collapsed CLF table (aggregated by CLF Foundation Type)
        * @param {Array} breakdown - Array of {foundation, count, pct} objects
        * @param {number} total - Total count
        * @returns {string} HTML table string
        */
        function generateCLFCollapsedTable(breakdown, total) {
            // Aggregate by CLF Foundation Type
            const clfAggregated = {};
            
            breakdown.forEach(row => {
                const clfType = CLF_FOUNDATION_MAP[row.foundation] || 'Other Foundation System';
                if (!clfAggregated[clfType]) {
                    clfAggregated[clfType] = 0;
                }
                clfAggregated[clfType] += row.count;
            });
            
            let html = '<table style="width:100%; border-collapse: collapse; font-size: 0.9em;">';
            html += `<tr style="background:#eee;">
                <th style="padding:5px; text-align:left;">CLF Foundation Type</th>
                <th style="padding:5px; text-align:right;">Count</th>
                <th style="padding:5px; text-align:right;">%</th>
            </tr>`;
            
            // Display in order
            CLF_FOUNDATION_ORDER.forEach(clfType => {
                const count = clfAggregated[clfType] || 0;
                const pct = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
                html += `<tr style="border-bottom: 1px solid #f0f0f0;">
                    <td style="padding:5px;">${clfType}</td>
                    <td style="padding:5px; text-align:right;">${count.toLocaleString()}</td>
                    <td style="padding:5px; text-align:right;">${pct}%</td>
                </tr>`;
            });
            
            html += '</table>';
            return html;
        }



        /**
         * Draw bar and pie charts for Boston Foundation data
         * @param {string} containerBar - ID of bar chart container
         * @param {string} containerPie - ID of pie chart container
         * @param {Array} chartData - Array of {foundation, count} objects
         * @param {string} titleSuffix - Suffix for chart titles
         */
        function drawBFCharts(containerBar, containerPie, chartData, titleSuffix) {
            let displayData;
            
            if (bfCollapseAsCLF) {
                displayData = aggregateChartDataByCLF(chartData);
            } else {
                displayData = chartData;
            }
            
            // Fixed colors for each foundation type (for consistent comparison)
            const BF_TYPE_COLORS = {
                'Slab': '#0d0887',           // Deep purple
                'Crawl Space': '#5c01a6',    // Purple
                'Basement': '#9c179e',       // Magenta
                'Fill': '#cc4778',           // Pink
                'Pier': '#ed7953',           // Orange
                'Pile': '#fdb42f',           // Yellow-orange
                'Solid Wall': '#f0f921'      // Yellow
            };

            // Fixed colors for CLF foundation types
            const BF_CLF_TYPE_COLORS = {
                'Shallow foundation': '#0d0887',
                "Deep Foundation < 50' (15m)": '#ed7953',
                "Deep Foundation > 50' (15m)": '#9c179e',
                'Other Foundation System': '#f0f921'
            };

            const colors = displayData.map(d => 
                bfCollapseAsCLF 
                    ? (BF_CLF_TYPE_COLORS[d.foundation] || '#999')
                    : (BF_TYPE_COLORS[d.foundation] || '#999')
            );
            // Bar chart
            Plotly.newPlot(containerBar, [{
                x: displayData.map(d => d.foundation),
                y: displayData.map(d => d.count),
                type: 'bar',
                marker: { color: colors },
                text: displayData.map(d => d.count.toLocaleString()),
                textposition: 'auto'
            }], {
                title: { 
                    text: bfCollapseAsCLF ? `CLF Foundation Counts (${titleSuffix})` : `Counts (${titleSuffix})`, 
                    font: {size: 16} 
                },
                margin: { t: 40, b: 120, l: 50, r: 20 }, 
                height: 450, 
                xaxis: { 
                    tickangle: bfCollapseAsCLF ? -25 : -45, 
                    title: { text: bfCollapseAsCLF ? 'CLF Foundation Type' : 'Foundation Type', standoff: 20 }
                },
                yaxis: { title: 'Count' }
            }, {responsive: true});

            // Pie chart
            Plotly.newPlot(containerPie, [{
                labels: displayData.map(d => d.foundation),
                values: displayData.map(d => d.count),
                type: 'pie',
                marker: { colors: colors },
                textinfo: 'percent', 
                textposition: 'inside',
                hole: 0.4
            }], {
                title: { 
                    text: bfCollapseAsCLF ? `CLF Distribution (${titleSuffix})` : `Distribution (${titleSuffix})`, 
                    font: {size: 16} 
                },
                margin: { t: 40, b: 40, l: 20, r: 20 },
                height: 450, 
                showlegend: true,
                legend: {
                    orientation: 'v',
                    x: 1.05, 
                    y: 0.5,
                    xanchor: 'left',
                    yanchor: 'middle'
                }
            }, {responsive: true});
        }

        /**
         * Aggregate chart data by CLF Foundation Type
         * @param {Array} chartData - Array of {foundation, count} objects
         * @returns {Array} Aggregated array of {foundation: clfType, count} objects
         */
        function aggregateChartDataByCLF(chartData) {
            const clfAggregated = {};
            
            chartData.forEach(item => {
                const clfType = CLF_FOUNDATION_MAP[item.foundation] || 'Other Foundation System';
                if (!clfAggregated[clfType]) {
                    clfAggregated[clfType] = 0;
                }
                clfAggregated[clfType] += item.count;
            });
            
            // Return in order
            return CLF_FOUNDATION_ORDER
                .filter(clfType => clfAggregated[clfType] > 0)
                .map(clfType => ({
                    foundation: clfType,
                    count: clfAggregated[clfType]
                }));
        }

        /**
         * Toggle collapse/expand state for CLF Foundation view
         */
        function toggleBFCollapseAsCLF() {
            bfCollapseAsCLF = document.getElementById('bf-collapse-toggle').checked;
            
            // Refresh all sections
            updateBFSection1();
            updateBFSection2();
            
            // Refresh section 3 if loaded
            if (window.bfSection3Loaded) {
                renderBFSection3();
            }
        }

        function toggleBFSection3() {
            const content = document.getElementById('section3-content');
            const arrow = document.getElementById('s3-arrow');
            const isHidden = content.style.display === 'none';
            
            content.style.display = isHidden ? 'block' : 'none';
            arrow.style.transform = isHidden ? 'rotate(90deg)' : 'rotate(0deg)';
            
            if (isHidden && !window.bfSection3Loaded) {
                renderBFSection3();
                window.bfSection3Loaded = true;
            }
        }

        function renderBFSection3() {
            const data = buildingData.boston_full_analysis;
            
            const renderRows = (containerId, landType) => {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                
                data.bin_order.forEach((bin, idx) => {
                    const stats = data.data[landType][bin];
                    if(stats.total === 0) return;

                    const rowId = `s3-${landType}-${idx}`;
                    const html = `
                        <div style="background: white; padding: 15px; margin-bottom: 20px; border-radius: 8px; border: 1px solid #eee;">
                            <h5 style="margin:0 0 10px 0; color: #333; font-size: 1.1em;">${bin} (n=${stats.total.toLocaleString()})</h5>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                                <div>${generateStatsTable(stats.breakdown, stats.total)}</div>
                                <div id="${rowId}-bar" style="height: 400px;"></div>
                                <div id="${rowId}-pie" style="height: 400px;"></div>
                            </div>
                        </div>
                    `;
                    container.innerHTML += html;
                    
                    // Need to wait for DOM update before plotting
                    setTimeout(() => {
                        drawBFCharts(`${rowId}-bar`, `${rowId}-pie`, stats.chart_data, bin);
                    }, 0);
                });
            };

            renderRows('s3-orig-full-charts', 'original');
            renderRows('s3-shore-full-charts', 'shoreline');
        }

        /**
         * Creates a bar chart for Occupancy Class (OCC_CLS) distribution.

         */
        function createHistoricOccupancyChart(data) {
            const chartDiv = document.getElementById('historicOccupancyChart');
            if (!data || data.length === 0) {
                chartDiv.innerHTML = '<p style="padding: 20px; text-align: center;">No data for Occupancy chart.</p>';
                return;
            }

            const counts = data.reduce((acc, d) => {
                const key = d.OCC_CLS || 'Unknown';
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            // START: MODIFICATION
            // Map occupancy classes to their predefined colors from FIXED_OCC_COLORS.
            const barColors = sorted.map(d => FIXED_OCC_COLORS[d[0]] || '#999999');
            // END: MODIFICATION

            const plotData = [{
                x: sorted.map(d => d[0]),
                y: sorted.map(d => d[1]),
                type: 'bar',
                // Use the mapped colors for the bar chart.
                marker: { color: barColors }
            }];

            const layout = {
                title: { text: 'Distribution by Occupancy' },
                xaxis: { title: 'Occupancy Class', tickangle: -45 },
                yaxis: { title: 'Building Count' },
                height: 400,
                margin: { t: 40, b: 120, l: 60, r: 20 }
            };

            Plotly.newPlot(chartDiv, plotData, layout, { responsive: true });
        }

        /**
         * Creates a bar chart for Year Built distribution.
         * UPDATED: Now groups ALL years by decade (1630s - 2020s), removing the pre-1940 aggregation.
         */
        function createHistoricYearChart(data) {
            const chartDiv = document.getElementById('historicYearChart');
            if (!data || data.length === 0) {
                chartDiv.innerHTML = '<p style="padding: 20px; text-align: center;">No data for Year Built chart.</p>';
                return;
            }

            const counts = data.reduce((acc, d) => {
                const year = d.year_built;
                let key;
                
                // START: MODIFICATION - Removed pre-1940 check
                // First, check if 'year' is a valid number.
                if (year && !isNaN(year) && year > 0) {
                    // Group ALL years by decade (e.g., 1630 -> "1630s", 1952 -> "1950s")
                    key = `${Math.floor(year / 10) * 10}s`;
                } else {
                    // Group all other cases (null, NaN, 0) as 'Unknown'.
                    key = 'Unknown';
                }
                // END: MODIFICATION

                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            // Custom sort to ensure decades are ordered numerically and 'Unknown' is last.
            const sorted = Object.entries(counts).sort((a, b) => {
                if (a[0] === 'Unknown') return 1; // Put Unknown at the end
                if (b[0] === 'Unknown') return -1;
                
                // Convert "1630s" -> 1630 for correct numeric sorting
                return parseInt(a[0]) - parseInt(b[0]);
            });

            const plotData = [{
                x: sorted.map(d => d[0]),
                y: sorted.map(d => d[1]),
                type: 'bar',
                // Use Plasma colorscale reversed so recent years are brighter/distinct
                marker: { color: getPlasmaColors(sorted.length).reverse() }
            }];

            const layout = {
                title: { text: 'Distribution by Year Built (Decades)' },
                xaxis: { title: 'Decade', tickangle: -45 },
                yaxis: { title: 'Building Count' },
                height: 400,
                margin: { t: 40, b: 120, l: 60, r: 20 }
            };

            Plotly.newPlot(chartDiv, plotData, layout, { responsive: true });
        }
        /**
         * Creates a bar chart for Material Type distribution.
    
         */
        function createHistoricMaterialChart(data) {
            const chartDiv = document.getElementById('historicMaterialChart');
            if (!data || data.length === 0) {
                chartDiv.innerHTML = '<p style="padding: 20px; text-align: center;">No data for Material chart.</p>';
                return;
            }

            const counts = data.reduce((acc, d) => {
                // Use the mapping to get full names (e.g., 'W' -> 'Wood').
               
                const key = materialTypeMap[d.material_type] || d.material_type || 'Unknown';
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            const plotData = [{
                x: sorted.map(d => d[0]),
                y: sorted.map(d => d[1]),
                type: 'bar',
                marker: { color: plasmaColors }
            }];

            const layout = {
                title: { text: 'Distribution by Material' },
                xaxis: { title: 'Material Type' },
                yaxis: { title: 'Building Count' },
                height: 400,
                margin: { t: 40, b: 80, l: 60, r: 20 }
            };

            Plotly.newPlot(chartDiv, plotData, layout, { responsive: true });
        }

        /**
         * Creates a bar chart for Foundation Type distribution.
   
         */
        function createHistoricFoundationChart(data) {
            const chartDiv = document.getElementById('historicFoundationChart');
            if (!data || data.length === 0) {
                chartDiv.innerHTML = '<p style="padding: 20px; text-align: center;">No data for Foundation chart.</p>';
                return;
            }

            const counts = data.reduce((acc, d) => {
                // Use the mapping to get full names (e.g., 'B' -> 'Basement').
       
                const key = foundationTypeMap[d.foundation_type] || d.foundation_type || 'Unknown';
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            const plotData = [{
                x: sorted.map(d => d[0]),
                y: sorted.map(d => d[1]),
                type: 'bar',
                marker: { color: plasmaColors }
            }];

            const layout = {
                title: { text: 'Distribution by Foundation' },
                xaxis: { title: 'Foundation Type' },
                yaxis: { title: 'Building Count' },
                height: 400,
                margin: { t: 40, b: 80, l: 60, r: 20 }
            };

            Plotly.newPlot(chartDiv, plotData, layout, { responsive: true });
        }

        // 用下面的函数完整替换掉旧的 createDataSourcesFlowchart 函数
        function createDataSourcesFlowchart() {
            // Create Sankey diagram to show data flow
            const sourceNames = Object.keys(dataSourceColumns);
            const finalDatasetName = 'NSI-Enhanced USA Structures Dataset';
            const labels = [...sourceNames, finalDatasetName];
            
            const sources = sourceNames.map((_, i) => i);
            const targets = sourceNames.map(() => sourceNames.length);
            const values = sourceNames.map(name => dataSourceColumns[name].columns.length);
            const totalColumns = values.reduce((a, b) => a + b, 0);
            
            const nodeColors = sourceNames.map(name => dataSourceColumns[name].color);
            nodeColors.push('#2c3e50'); // Final dataset color
            
            const sankeyData = [{
                type: 'sankey',
                orientation: 'h',
                node: {
                    pad: 30,
                    thickness: 30,
                    line: {
                        color: 'white',
                        width: 2
                    },
                    label: labels.map((label, i) => {
                        if (i < sourceNames.length) {
                            const source = dataSourceColumns[label];
                            return `${source.icon} ${label}<br><span style="font-size: 11px;">(${source.columns.length} columns)</span>`;
                        }
                        return `🎯 ${label}<br><span style="font-size: 11px;">(${totalColumns} total columns)</span>`;
                    }),
                    color: nodeColors,
                    customdata: labels.map(label => dataSourceColumns[label]),
                    hovertemplate: '%{label}<br><b>Click to see columns</b><extra></extra>'
                },
                link: {
                    source: sources,
                    target: targets,
                    value: values,
                    color: sources.map(i => nodeColors[i] + '40'), // Add transparency
                    hovertemplate: '%{source.label} → %{target.label}<br>%{value} columns<extra></extra>'
                }
            }];
            
            const sankeyLayout = {
                font: { size: 14, family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' },
                height: 550,
                margin: { t: 20, b: 20, l: 150, r: 150 },
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent'
            };
            
            Plotly.newPlot('dataSourcesFlowchart', sankeyData, sankeyLayout, {
                responsive: true,
                displayModeBar: false
            });
            
            document.getElementById('dataSourcesFlowchart').on('plotly_click', function(eventData) {
                if (eventData.points && eventData.points[0] && eventData.points[0].pointNumber !== undefined) {
                    const pointIndex = eventData.points[0].pointNumber;
                    if (pointIndex < sourceNames.length) { 
                        const sourceName = labels[pointIndex];
                        showColumnDetails(sourceName);
                    } else {
                        showAllColumns();
                    }
                }
            });
            
            setTimeout(() => {
                addFloatingBadges();
            }, 500);
        }


        function showAllColumns() {
            const panel = document.getElementById('columnDetailsPanel');
            const title = document.getElementById('columnDetailsTitle');
            const list = document.getElementById('columnDetailsList');
            
            title.innerHTML = `<span style="color: #2c3e50;">🎯 Complete NSI-Enhanced Dataset</span> - All integrated columns`;
            
            list.innerHTML = '';
            Object.entries(dataSourceColumns).forEach(([sourceName, source]) => {
                const sourceDiv = document.createElement('div');
                sourceDiv.style.gridColumn = 'span 3';
                sourceDiv.innerHTML = `
                    <h4 style="color: ${source.color}; margin: 15px 0 10px 0;">
                        ${source.icon} From ${sourceName} (${source.columns.length} columns)
                    </h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                        ${source.columns.map(col => `
                            <span style="
                                background: ${source.color}20;
                                color: ${source.color};
                                padding: 4px 10px;
                                border-radius: 15px;
                                font-size: 11px;
                                border: 1px solid ${source.color}40;
                            ">${col}</span>
                        `).join('')}
                    </div>
                `;
                list.appendChild(sourceDiv);
            });
            
            panel.style.display = 'block';
        }

        function showColumnDetails(sourceName) {
            const source = dataSourceColumns[sourceName];
            if (!source) return;
            
            const panel = document.getElementById('columnDetailsPanel');
            const title = document.getElementById('columnDetailsTitle');
            const list = document.getElementById('columnDetailsList');
            
            title.innerHTML = `<span style="color: ${source.color};">${source.icon} ${sourceName}</span> - ${source.description}`;
            
            // Group columns by category for better organization
            const columnCategories = categorizeColumns(source.columns);
            
            list.innerHTML = '';
            Object.entries(columnCategories).forEach(([category, cols]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.style.gridColumn = 'span ' + Math.min(cols.length > 5 ? 2 : 1, 3);
                categoryDiv.innerHTML = `
                    <h5 style="color: ${source.color}; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">
                        ${category}
                    </h5>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                        ${cols.map(col => `
                            <span style="
                                background: ${source.color}20;
                                color: ${source.color};
                                padding: 4px 10px;
                                border-radius: 15px;
                                font-size: 12px;
                                border: 1px solid ${source.color}40;
                                display: inline-block;
                            ">${col}</span>
                        `).join('')}
                    </div>
                `;
                list.appendChild(categoryDiv);
            });
            
            panel.style.display = 'block';
            panel.style.opacity = '0';
            setTimeout(() => {
                panel.style.transition = 'opacity 0.3s ease';
                panel.style.opacity = '1';
            }, 10);
        }

        function categorizeColumns(columns) {
            const categories = {
                'Identifiers': [],
                'Location': [],
                'Properties': [],
                'Measurements': [],
                'Environmental': [],
                'Metadata': []
            };
            
            columns.forEach(col => {
                const colLower = col.toLowerCase();
                if (colLower.includes('id') || colLower.includes('uuid') || colLower.includes('key')) {
                    categories['Identifiers'].push(col);
                } else if (colLower.includes('lat') || colLower.includes('long') || colLower.includes('addr') || 
                        colLower.includes('city') || colLower.includes('zip') || colLower.includes('fips') ||
                        colLower.includes('geometry') || colLower.includes('usng')) {
                    categories['Location'].push(col);
                } else if (colLower.includes('sqm') || colLower.includes('sqf') || colLower.includes('height') ||
                        colLower.includes('elev') || colLower.includes('area') || colLower.includes('length')) {
                    categories['Measurements'].push(col);
                } else if (colLower.includes('soil') || colLower.includes('drain') || colLower.includes('flood') ||
                        colLower.includes('eng_') || colLower.includes('gwp') || colLower.includes('wt')) {
                    categories['Environmental'].push(col);
                } else if (colLower.includes('date') || colLower.includes('source') || colLower.includes('method') ||
                        colLower.includes('image') || colLower.includes('remark')) {
                    categories['Metadata'].push(col);
                } else {
                    categories['Properties'].push(col);
                }
            });
            
            // Remove empty categories
            return Object.fromEntries(
                Object.entries(categories).filter(([_, cols]) => cols.length > 0)
            );
        }


        function addFloatingBadges() {
            const container = document.getElementById('dataSourcesFlowchart');
            if (!container) return;
            
            // Add summary stats as floating badges
            const stats = [
                { label: 'Total Columns', value: '72', color: '#2c3e50' },
                { label: 'Data Sources', value: '5', color: '#667eea' },
                { label: 'MA Buildings', value: '2.09M+', color: '#764ba2' }
            ];
            
            const badgeContainer = document.createElement('div');
            badgeContainer.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                display: flex;
                gap: 15px;
                z-index: 10;
            `;
            
            stats.forEach(stat => {
                const badge = document.createElement('div');
                badge.style.cssText = `
                    background: white;
                    border: 2px solid ${stat.color};
                    border-radius: 20px;
                    padding: 8px 16px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    animation: fadeInBadge 0.5s ease;
                `;
                badge.innerHTML = `
                    <div style="font-size: 18px; font-weight: bold; color: ${stat.color};">${stat.value}</div>
                    <div style="font-size: 11px; color: #666;">${stat.label}</div>
                `;
                badgeContainer.appendChild(badge);
            });
            
            // Only add if not already present
            if (!container.querySelector('.badge-container')) {
                badgeContainer.className = 'badge-container';
                container.style.position = 'relative';
                container.appendChild(badgeContainer);
            }
        }



        function updateClusteringWithNewK() {
            const newK = parseInt(document.getElementById('clusterCount').value);
            currentClusterK = newK;
            document.getElementById('numClusters').textContent = currentClusterK.toString();
            updateClustering();
        }

    function updateClustering() {
        if (!buildingData) return;

        // The data for the statistics table and treemap now comes from the more detailed
        // 'occupancy_clusters' object, which holds pre-calculated results for multiple K values.
        const allClustersData = buildingData.occupancy_clusters?.all?.k_values;
        const samples = buildingData.building_samples_random;

        if (!allClustersData || !samples) {
            console.error("Required clustering data is not available.");
            document.getElementById('clusterScatter').innerHTML = "<p>Clustering data is missing.</p>";
            return;
        }

        // --- FIX #1: USE REAL, PRE-CALCULATED CLUSTER ASSIGNMENTS ---
        // Instead of random assignments, we now map each sample point to its true
        // pre-calculated cluster for the currently selected K value.
        // The Python script saves these as columns like 'cluster_base_k5', 'cluster_base_k7', etc.
        const samplesWithRealClusters = samples.map(s => ({
            ...s,
            // Dynamically select the correct cluster column based on the chosen K.
            displayCluster: s[`cluster_base_k${currentClusterK}`]
        }));

        // --- Scatter Plot (Now shows REAL clusters) ---
        const scatterData = [];
        for (let i = 0; i < currentClusterK; i++) {
            const clusterSamples = samplesWithRealClusters.filter(s => s.displayCluster === i);
            if (clusterSamples.length > 0) {
                scatterData.push({
                    x: clusterSamples.map(s => s.year_built < 1940 ? 'pre-1940' : s.year_built),
                    y: clusterSamples.map(s => s.SQMETERS),
                    mode: 'markers',
                    type: 'scatter',
                    name: `Cluster ${i + 1}`,
                    marker: { color: plasmaColors[i % plasmaColors.length], size: 8, opacity: 0.6 },
                    hovertemplate: 'Year: %{x}<br>Est GFA: %{y:.1f} sqm<br><b>Cluster: ' + (i + 1) + '</b><extra></extra>'
                });
            }
        }
        const scatterLayout = {
            title: { text: `K-Means Clustering Results (K=${currentClusterK})`, font: { size: 20, color: '#333' } },
            xaxis: { title: 'Year Built' },
            yaxis: { title: 'Footprint Area (sqm)' },
            height: 500,
            hovermode: 'closest'
        };
        Plotly.newPlot('clusterScatter', scatterData, scatterLayout, { responsive: true });

        // --- Elbow Plot (Now uses REAL WCSS data for all K values) ---
        const elbowKValues = Object.keys(allClustersData).map(Number);
        const elbowWcssValues = elbowKValues.map(k => allClustersData[k].wcss);
        
        const elbowData = [{
            x: elbowKValues,
            y: elbowWcssValues,
            mode: 'lines+markers',
            type: 'scatter',
            marker: { size: 10, color: plasmaColors[3], line: { color: 'white', width: 2 } },
            line: { width: 3, color: plasmaColors[3] },
            hovertemplate: 'K: %{x}<br>WCSS: %{y:,.0f}<extra></extra>'
        }];
        const elbowLayout = {
            title: { text: 'Elbow Method for Optimal K', font: { size: 20, color: '#333' } },
            xaxis: { title: 'Number of Clusters (K)', dtick: 1 },
            yaxis: { title: 'Within-Cluster Sum of Squares (WCSS)' },
            height: 400
        };
        Plotly.newPlot('clusterElbow', elbowData, elbowLayout, { responsive: true });

        // --- Statistics Table and Treemap (Now use REAL data for the selected K) ---
        const clusterStatsForK = allClustersData[currentClusterK];
        if (clusterStatsForK && clusterStatsForK.clusters) {
            const displayClusters = clusterStatsForK.clusters;

            // Statistics Table
            const tableData = [{
                type: 'table',
                header: { values: ['Cluster', 'Count','Occupancy', 'Avg Footprint (m²)', 'Avg Height (m)', 'Avg Year'], align: 'center', line: {width: 1, color: '#dee2e6'}, fill: {color: plasmaColors[3]}, font: {family: "Arial", size: 14, color: "white"} },
                cells: {
                    values: [
                        displayClusters.map(c => `Cluster ${c.cluster_id + 1}`),
                        displayClusters.map(c => c.count.toLocaleString()),
                        displayClusters.map(c => c.most_common_occ || '-'),
                        displayClusters.map(c => Math.round(c.avg_sqmeters)),
                        displayClusters.map(c => c.avg_height.toFixed(1)),
                        displayClusters.map(c => c.avg_year)
                    ],
                    align: 'center', line: {color: "#dee2e6", width: 1}, fill: {color: ['#f8f9fa', 'white']}, font: {family: "Arial", size: 12, color: ["#333"]}
                }
            }];
            const tableLayout = { title: { text: `Cluster Statistics (K=${currentClusterK}, Based on Full Dataset)`, font: { size: 18, color: '#333' } }, height: 400 };
            Plotly.newPlot('clusterTable', tableData, tableLayout, { responsive: true });

            // Treemap
            updateClusterTreemap(); // Pass the correct data to the treemap function
        } else {
            // Handle cases where data for a specific K might be missing
            document.getElementById('clusterTable').innerHTML = `<p>No statistics available for K=${currentClusterK}.</p>`;
            document.getElementById('clusterTreemap').innerHTML = '';
        }
            createClusterMap();
    }

    // You also need to slightly modify `updateClusterTreemap` to accept data as an argument.
    // Find `updateClusterTreemap()` and replace it with this new version.
    function updateClusterTreemap() {
            if (!buildingData) return;


            const allClustersData = buildingData.occupancy_clusters?.all?.k_values;
            if (!allClustersData) return;
            
            const clusterStatsForK = allClustersData[currentClusterK]; // 'currentClusterK' 
            if (!clusterStatsForK || !clusterStatsForK.clusters) return;
            
            const clusters = clusterStatsForK.clusters; 
            
            const sizeBy = document.getElementById('treemapSizeBy').value;
        
        const labels = ['All Clusters'];
        const parents = [''];
        const values = [0];
        const colors = [''];
        
        clusters.forEach((cluster, index) => {
            // The new data doesn't have 'most_common_occ', so we create a simple label.
            const label = `Cluster ${index + 1}<br>(${cluster.most_common_occ || 'N/A'})`;
            labels.push(label);
            parents.push('All Clusters');
            
            // The new data uses 'avg_sqmeters', not 'area_mean'.
            if (sizeBy === 'count') {
                values.push(cluster.count);
            } else {

                values.push(cluster.count * (cluster.avg_gfa || cluster.avg_sqmeters));
            }
            colors.push(plasmaColors[index % plasmaColors.length]);
        });
        
        const treemapData = [{
            type: 'treemap',
            labels: labels,
            parents: parents,
            values: values,
            marker: { colors: colors },
            textinfo: 'label+value+percent parent',
            hovertemplate: '%{label}<br>Value: %{value:,}<br>%{percentParent}<extra></extra>'
        }];
        
        const treemapLayout = {
            title: { text: `Cluster Treemap (Sized by ${sizeBy === 'count' ? 'Building Count' : 'Total Floor Area'})`, font: { size: 18, color: '#333' } },
            height: 500
        };
        
        Plotly.newPlot('clusterTreemap', treemapData, treemapLayout, {responsive: true});
    }


/**
 * FIXED: updateTemporalChart
 * 1. Syncs styling (fillcolor/line width) between Count and Area charts to fix transparency mismatch.
 * 2. Enables Legend for Area chart.
 * 3. Uses 'legendgroup' so toggling one legend item updates both charts simultaneously.
 */
function updateTemporalChart() {
    // 1. Safety Check
    if (!buildingData || !buildingData.temporal_data) return;

    // 2. Get UI States
    const chartType = document.getElementById('chartType').value;
    const buildingType = document.getElementById('buildingType').value;
    const isDecadeMode = document.getElementById('temporalDecadeToggle').checked;
    
    const startYearInput = document.getElementById('temporalStart');
    const endYearInput = document.getElementById('temporalEnd');
    const startYear = startYearInput ? parseInt(startYearInput.value) || 1630 : 1630;
    const endYear = endYearInput ? parseInt(endYearInput.value) || 2025 : 2025;

    // 3. Filter Data
    let filteredData = buildingData.temporal_data;
    let occupancyClasses = buildingData.summary_stats.occupancy_classes;

    if (buildingType === 'residential') {
        occupancyClasses = ['Residential'];
        filteredData = filteredData.filter(d => d.occupancy === 'Residential');
    } else if (buildingType === 'non-residential') {
        occupancyClasses = occupancyClasses.filter(o => o !== 'Residential');
        filteredData = filteredData.filter(d => d.occupancy !== 'Residential');
    }

    filteredData = filteredData.filter(d => d.year >= startYear && d.year <= endYear);

    occupancyClasses = occupancyClasses.sort((a, b) => {
        if (a === 'Residential') return -1;
        if (b === 'Residential') return 1;
        return a.localeCompare(b);
    });
    const occupancyColors = getPlasmaColors(occupancyClasses.length);

    // =================================================================================
    // CORE LOGIC: AGGREGATION
    // =================================================================================
    
    const aggData = {};      
    const aggArea = {};      
    const aggTotalCount = {}; 
    const aggTotalArea = {};  

    filteredData.forEach(d => {
        const timeKey = isDecadeMode ? Math.floor(d.year / 10) * 10 : d.year;
        
        if (!aggData[timeKey]) {
            aggData[timeKey] = {}; aggArea[timeKey] = {};
            aggTotalCount[timeKey] = 0; aggTotalArea[timeKey] = 0;
        }
        if (!aggData[timeKey][d.occupancy]) {
            aggData[timeKey][d.occupancy] = 0; aggArea[timeKey][d.occupancy] = 0;
        }

        aggData[timeKey][d.occupancy] += d.count;
        aggTotalCount[timeKey] += d.count;
        
        const area = d.total_area || (d.count * d.avg_area) || 0;
        aggArea[timeKey][d.occupancy] += area;
        aggTotalArea[timeKey] += area;
    });

    const xValues = Object.keys(aggData).map(Number).sort((a, b) => a - b);
    
    const range = endYear - startYear;
    let tickStep;
    if (isDecadeMode) {
        tickStep = range > 200 ? 20 : 10;
    } else {
        tickStep = range > 200 ? 20 : (range > 50 ? 10 : 5);
    }
    const tickvals = xValues.filter(v => v % tickStep === 0);
    const ticktext = tickvals.map(v => isDecadeMode ? v + 's' : v);

    const isBar = chartType === 'bar'; 

    // Helper to apply consistent styling to both charts
    const applyTraceStyling = (trace, index, type) => {
        if (isBar) {
            trace.marker = { color: occupancyColors[index] };
        } else {
            // Scatter/Line Styling
            trace.mode = (type === 'line' ? 'lines+markers' : 'lines');
            // Fix transparency issue: Ensure line width is consistent
            trace.line = { color: occupancyColors[index], width: type === 'line' ? 2 : 0.5 };
            
            if (type === 'line') {
                trace.marker = { size: 4 };
            }
            
            // Stacking & Filling
            if (type === 'stacked' || type === 'normalized') {
                trace.stackgroup = 'one';
                // FIX 2: Explicitly set fillcolor to avoid transparency default
                trace.fillcolor = occupancyColors[index]; 
            }
            if (type === 'normalized') {
                trace.groupnorm = 'percent';
            }
            if (type === 'cumulative') {
                trace.fill = 'tozeroy';
            }
        }
    };

    // =================================================================================
    // 1. MAIN CHART: BUILDING COUNT
    // =================================================================================
    const countTraces = [];
    occupancyClasses.forEach((occ, index) => {
        let yValues = xValues.map(t => aggData[t][occ] || 0);

        if (chartType === 'cumulative') {
            let sum = 0; yValues = yValues.map(v => { sum += v; return sum; });
        } else if (chartType === 'normalized') {
            yValues = xValues.map(t => {
                const total = aggTotalCount[t];
                return total > 0 ? ((aggData[t][occ] || 0) / total * 100) : 0;
            });
        }

        const trace = {
            x: isDecadeMode && isBar ? xValues.map(v => v + 's') : xValues,
            y: yValues,
            name: occ,
            type: isBar ? 'bar' : 'scatter',
            legendgroup: occ, // Sync legends
            hovertemplate: `%{fullData.name}<br>${isDecadeMode ? 'Decade' : 'Year'}: %{x}<br>` +
                           `${chartType === 'normalized' ? 'Share: %{y:.1f}%' : 'Count: %{y:,}'}<extra></extra>`
        };

        applyTraceStyling(trace, index, chartType);
        countTraces.push(trace);
    });

    Plotly.newPlot('temporalChart', countTraces, {
        title: { 
            text: `Building Count (${isDecadeMode ? 'by Decade' : 'Annual'})`, 
            font: { size: 20, color: '#333' } 
        },
        xaxis: { 
            title: isDecadeMode ? 'Decade' : 'Year',
            tickmode: 'array', tickvals: isDecadeMode && isBar ? undefined : tickvals, ticktext: isDecadeMode && isBar ? undefined : ticktext,
            tickangle: -45
        },
        yaxis: { title: chartType === 'normalized' ? 'Percentage (%)' : 'Number of Buildings' },
        barmode: isBar ? 'stack' : undefined,
        height: 650, hovermode: 'x unified',
        legend: { orientation: 'v', yanchor: 'middle', y: 0.5, xanchor: 'left', x: 1.02 }
    }, {responsive: true});

    // =================================================================================
    // 2. SECONDARY CHART: ESTIMATED GFA
    // =================================================================================
    const areaTraces = [];
    occupancyClasses.forEach((occ, index) => {
        let yValues = xValues.map(t => aggArea[t][occ] || 0);

        if (chartType === 'cumulative') {
            let sum = 0; yValues = yValues.map(v => { sum += v; return sum; });
        } else if (chartType === 'normalized') {
            yValues = xValues.map(t => {
                const total = aggTotalArea[t];
                return total > 0 ? ((aggArea[t][occ] || 0) / total * 100) : 0;
            });
        }

        const trace = {
            x: isDecadeMode && isBar ? xValues.map(v => v + 's') : xValues,
            y: yValues,
            name: occ,
            type: isBar ? 'bar' : 'scatter',
            legendgroup: occ, // Sync legends
            showlegend: true, // FIX 1: Enable Legend
            hovertemplate: `%{fullData.name}<br>${isDecadeMode ? 'Decade' : 'Year'}: %{x}<br>` +
                           `${chartType === 'normalized' ? 'Area Share: %{y:.1f}%' : 'GFA: %{y:,.0f} sqm'}<extra></extra>`
        };

        applyTraceStyling(trace, index, chartType);
        areaTraces.push(trace);
    });

    Plotly.newPlot('temporalAreaChart', areaTraces, {
        title: { 
            text: `Total Est. GFA (${isDecadeMode ? 'by Decade' : 'Annual'})`, 
            font: { size: 20, color: '#333' } 
        },
        xaxis: { 
            title: isDecadeMode ? 'Decade' : 'Year',
            tickmode: 'array', tickvals: isDecadeMode && isBar ? undefined : tickvals, ticktext: isDecadeMode && isBar ? undefined : ticktext,
            tickangle: -45
        },
        yaxis: { title: chartType === 'normalized' ? 'Percentage (%)' : 'Est GFA (sqm)' },
        barmode: isBar ? 'stack' : undefined,
        height: 650, hovermode: 'x unified',
        showlegend: true, // FIX 1: Enable Legend
        legend: { orientation: 'v', yanchor: 'middle', y: 0.5, xanchor: 'left', x: 1.02 }
    }, {responsive: true});

    // =================================================================================
    // 3. TREND CHART: RESIDENTIAL % (Always Line)
    // =================================================================================
    const trendY = xValues.map(t => {
        const total = aggTotalCount[t];
        if (!total) return null;
        return ((aggData[t]['Residential'] || 0) / total) * 100;
    });

    Plotly.newPlot('temporalTrendChart', [{
        x: xValues, y: trendY, 
        type: 'scatter', mode: 'lines+markers',
        line: { color: '#bd3786', width: 2 }, name: 'Residential %', connectgaps: true,
        marker: { size: isDecadeMode ? 6 : 2 },
        hovertemplate: `${isDecadeMode ? 'Decade' : 'Year'}: %{x}<br>Res Share: %{y:.1f}%<extra></extra>`
    }], {
        title: { text: `Residential % Trend (${isDecadeMode ? 'by Decade' : 'Annual'})`, font: { size: 20, color: '#333' } },
        xaxis: { 
            title: isDecadeMode ? 'Decade' : 'Year',
            tickmode: 'array', tickvals: tickvals, ticktext: ticktext, tickangle: -45 
        },
        yaxis: { title: 'Percentage (%)', range: [0, 100] },
        height: 400, hovermode: 'x'
    }, {responsive: true});
}


        function updateOccupancyClustering() {
            if (!buildingData) return;
            
            const selectedClass = document.getElementById('occupancyClass').value;
            const kValue = parseInt(document.getElementById('occupancyK').value);
            const sampleSize = parseInt(document.getElementById('sampleSize').value);
            const sampleType = document.getElementById('sampleType').value;
            const useLogScale = document.getElementById('logScale').checked;
            const includeMaterial = document.getElementById('includeMaterial').checked;
            const includeFoundation = document.getElementById('includeFoundation').checked;
            const materialFilter = includeMaterial ? document.getElementById('materialTypeFilter').value : 'all';
            const foundationFilter = includeFoundation ? document.getElementById('foundationTypeFilter').value : 'all';
            
            // Determine feature combination
            let featureCombo = 'base';
            if (includeMaterial && includeFoundation) {
                featureCombo = 'both';
            } else if (includeMaterial) {
                featureCombo = 'material';
            } else if (includeFoundation) {
                featureCombo = 'foundation';
            }
            
            // Update dimension indicator
            let dimensions = ['Year', 'Footprint Area', 'Height', 'Occupancy'];
            let dimensionCount = 4;
            if (includeMaterial) {
                dimensions.push('Material');
                dimensionCount++;
            }
            if (includeFoundation) {
                dimensions.push('Foundation');
                dimensionCount++;
            }
            document.getElementById('activeDimensions').textContent = `${dimensions.join(', ')} (${dimensionCount}D)`;
            
            // Update clustering status
            const statusText = `Using pre-computed ${featureCombo} clustering (${dimensionCount}D)`;
            document.getElementById('clusteringStatusText').textContent = statusText;
            
            // Update filter status
            let filters = [];
            if (includeMaterial && materialFilter !== 'all') {
                filters.push(`Material: ${materialTypeMap[materialFilter] || materialFilter}`);
            }
            if (includeFoundation && foundationFilter !== 'all') {
                filters.push(`Foundation: ${foundationTypeMap[foundationFilter] || foundationFilter}`);
            }
            
            if (filters.length > 0) {
                document.getElementById('filterStatus').style.display = 'block';
                document.getElementById('activeFilters').textContent = filters.join(', ');
            } else {
                document.getElementById('filterStatus').style.display = 'none';
            }
            
            // Update sample type indicator
            const currentSampleTypeEl = document.getElementById('currentSampleType');
            const sampleDescriptionEl = document.getElementById('sampleDescription');
            
            if (sampleType === 'random') {
                currentSampleTypeEl.textContent = 'Random Sample';
                currentSampleTypeEl.style.color = '#fb9f3a';
                sampleDescriptionEl.textContent = 'Shows true data distribution - rare classes may have few or no points visible';
            } else {
                currentSampleTypeEl.textContent = 'Balanced Sample';
                currentSampleTypeEl.style.color = '#7201a8';
                sampleDescriptionEl.textContent = 'Shows equal representation of all occupancy classes for better pattern visibility';
            }
            
            // Choose sample type
            let allVizSamples;
            if (sampleType === 'random') {
                allVizSamples = [...buildingData.building_samples_random];
            } else {
                allVizSamples = [...buildingData.building_samples_balanced];
            }
            
            // Filter by selected occupancy class
            let samplesForViz = allVizSamples;
            if (selectedClass !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.OCC_CLS === selectedClass);
            }
            
            // Apply material/foundation filters if specified
            if (includeMaterial && materialFilter !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.material_type === materialFilter);
            }
            if (includeFoundation && foundationFilter !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.foundation_type === foundationFilter);
            }
            
            // Sample down to user-selected size if needed
            if (samplesForViz.length > sampleSize) {
                samplesForViz = samplesForViz.sort(() => 0.5 - Math.random()).slice(0, sampleSize);
            }
            
            // Get appropriate cluster assignment based on feature combination
            const clusterKey = `cluster_${featureCombo}_k${kValue}`;
            samplesForViz.forEach(s => {
                s.displayCluster = s[clusterKey] !== undefined ? s[clusterKey] : null; // 如果没数据，则设为null
            });

            // Create 3D scatter plot
            // index.html L:1976
            // Create 3D scatter plot
            // MODIFICATION: The scatter plot now visualizes Footprint Area (x), Height (y), and Year (z), with points colored by cluster.
            const scatterData = [{
                x: samplesForViz.map(s => useLogScale ? Math.log10(s.SQMETERS + 1) : s.SQMETERS),
                y: samplesForViz.map(s => s.PRED_HEIGHT),
                z: samplesForViz.map(s => s.year_built),
                mode: 'markers',
                type: 'scatter3d',
                marker: {
                    color: samplesForViz.map(s => s.displayCluster), // Color by the assigned cluster
                    colorscale: 'Plasma',
                    size: 5,
                    opacity: 0.7,
                    showscale: true,
                    colorbar: { 
                        title: 'Cluster', 
                        thickness: 20,
                        x: 1.02
                    },
                    cmin: 0,
                    cmax: kValue - 1
                },
                text: samplesForViz.map(s => {
                    let text = `${s.OCC_CLS}<br>Cluster: ${s.displayCluster !== null ? s.displayCluster + 1 : 'N/A'}`;
                    if (includeMaterial && s.material_type) {
                        text += `<br>Material: ${materialTypeMap[s.material_type] || s.material_type}`;
                    }
                    if (includeFoundation && s.foundation_type) {
                        text += `<br>Foundation: ${foundationTypeMap[s.foundation_type] || s.foundation_type}`;
                    }
                    return text;
                }),
                hovertemplate: 'Footprint: %{x:.1f} sqm' + (useLogScale ? ' (log)' : '') +
                              '<br>Height: %{y:.1f} m' +
                              '<br>Year: %{z}' +
                              '<br>%{text}<extra></extra>'
            }];
            
            const scatterLayout = {
                title: {
                    text: `${dimensionCount}D Clustering Visualization (K=${kValue}, ${samplesForViz.length} buildings${filters.length > 0 ? ' - Filtered' : ''})`,
                    font: { size: 20, color: '#333' }
                },
                scene: {
                    xaxis: { 
                        title: useLogScale ? 'Footprint Area (SQMETERS, log scale)' : 'Footprint Area (SQMETERS)'
                    },
                    yaxis: { 
                        title: 'Predicted Height (m)'
                    },
                    zaxis: { 
                        title: 'Year Built',
                    },
                    camera: {
                        eye: {x: 1.5, y: 1.5, z: 1.5}
                    }
                },
                height: 600,
                margin: {
                    l: 0,
                    r: 0,
                    b: 0,
                    t: 60
                }
            };
            
            Plotly.newPlot('occupancyClusterChart', scatterData, scatterLayout, {responsive: true});

            // Get pre-computed clustering results from enhanced data
            let fullStatsData = null;
            
            if (buildingData.occupancy_clusters_enhanced && 
                buildingData.occupancy_clusters_enhanced[selectedClass] &&
                buildingData.occupancy_clusters_enhanced[selectedClass].feature_combinations &&
                buildingData.occupancy_clusters_enhanced[selectedClass].feature_combinations[featureCombo]) {
                
                fullStatsData = buildingData.occupancy_clusters_enhanced[selectedClass];
                const kStats = fullStatsData.feature_combinations[featureCombo][kValue];
                
                if (kStats && kStats.clusters) {
                    // Create full dataset table with enhanced clustering
                    let tableHeaders = ['Cluster', 'Total Count', 'Occupancy', 'Avg Footprint (m²)', 'Avg Height (m)', 'Avg Year'];
                    let tableValues = [
                        kStats.clusters.map(s => `Cluster ${s.cluster_id + 1}`),
                        kStats.clusters.map(s => s.count.toLocaleString()),
                        kStats.clusters.map(s => s.dominant_occupancy || '-'),
                        kStats.clusters.map(s => Math.round(s.avg_sqmeters)),
                        kStats.clusters.map(s => s.avg_height.toFixed(1)),
                        kStats.clusters.map(s => Math.round(s.avg_year))
                    ];
                    
                    // Add material/foundation columns if present
                    if (featureCombo === 'material' || featureCombo === 'both') {
                        tableHeaders.push('Dom. Material');
                        tableValues.push(kStats.clusters.map(s => 
                            s.dominant_material ? (materialTypeMap[s.dominant_material] || s.dominant_material) : '-'
                        ));
                    }
                    if (featureCombo === 'foundation' || featureCombo === 'both') {
                        tableHeaders.push('Dom. Foundation');
                        tableValues.push(kStats.clusters.map(s => 
                            s.dominant_foundation ? (foundationTypeMap[s.dominant_foundation] || s.dominant_foundation) : '-'
                        ));
                    }
                    
                    const fullTableData = [{
                        type: 'table',
                        header: {
                            values: tableHeaders,
                            align: 'center',
                            line: {width: 1, color: '#dee2e6'},
                            fill: {color: '#bd3786'},
                            font: {family: "Arial", size: 14, color: "white"}
                        },
                        cells: {
                            values: tableValues,
                            align: 'center',
                            line: {color: "#dee2e6", width: 1},
                            fill: {color: ['#f8f9fa', 'white']},
                            font: {family: "Arial", size: 12, color: ["#333"]}
                        }
                    }];
                    
                    let displayTitle = '';
                    const totalBuildings = fullStatsData.total_buildings;

                    const formatNumber = (num) => {
                        if (num >= 1000000) {
                            return `${(num / 1000000).toFixed(2)}M`;
                        } else if (num >= 1000) {
                            return `${(num / 1000).toFixed(1)}K`;
                        }
                        return num.toString();
                    };

                    if (selectedClass === 'all') {
                        displayTitle = `Complete Dataset Statistics - All Buildings (${formatNumber(totalBuildings)} total)`;
                    } else {
                        displayTitle = `Complete Dataset Statistics - ${selectedClass} (${formatNumber(totalBuildings)} buildings)`;
                    }

                    displayTitle += ` (K=${kValue})`;

                    const fullTableLayout = {
                        title: {
                            text: displayTitle,
                            font: { size: 18, color: '#333' }
                        },
                        height: 350
                    };
                    
                    Plotly.newPlot('occupancyFullStatsChart', fullTableData, fullTableLayout, {responsive: true});
                    
                    // Create elbow chart
                    const elbowX = Object.keys(fullStatsData.feature_combinations[featureCombo]).map(k => parseInt(k));
                    const elbowY = elbowX.map(k => fullStatsData.feature_combinations[featureCombo][k].wcss);

                    const elbowData = [{
                        x: elbowX,
                        y: elbowY,
                        mode: 'lines+markers',
                        type: 'scatter',
                        marker: { 
                            size: 10, 
                            color: '#bd3786',
                            line: { color: 'white', width: 2 }
                        },
                        line: { width: 3, color: '#bd3786' }
                    }];
                    
                    if (elbowX.includes(kValue)) {
                        const idx = elbowX.indexOf(kValue);
                        elbowData.push({
                            x: [kValue],
                            y: [elbowY[idx]],
                            mode: 'markers',
                            type: 'scatter',
                            marker: {
                                size: 15,
                                color: '#f0f921',
                                line: { color: '#bd3786', width: 2 }
                            },
                            showlegend: false,
                            hovertemplate: 'Current K=%{x}<br>WCSS=%{y:.0f}<extra></extra>'
                        });
                    }
                    
                    const elbowLayout = {
                        title: {
                            text: `Elbow Method - ${selectedClass} (${dimensionCount}D ${featureCombo}, Current K=${kValue})`,
                            font: { size: 18, color: '#333' }
                        },
                        xaxis: { title: 'Number of Clusters (K)', dtick: 1 },
                        yaxis: { title: 'WCSS' },
                        height: 350,
                        showlegend: false
                    };
                    
                    Plotly.newPlot('occupancyElbowChart', elbowData, elbowLayout, {responsive: true});
                }
            }
            
            // Sample statistics table
            const sampleStats = {};
            for (let i = 0; i < kValue; i++) {
                sampleStats[i] = { 
                    count: 0, 
                    sqmetersSum: 0,
                    heightSum: 0, 
                    yearSum: 0, 
                    materials: {},
                    foundations: {},
                    occupancies: {}
                };
            }
            
            samplesForViz.forEach(s => {
                const cluster = s.displayCluster;

                if (cluster !== null && cluster !== undefined) {
                    sampleStats[cluster].count++;
                    sampleStats[cluster].sqmetersSum += s.SQMETERS;
                    sampleStats[cluster].heightSum += s.PRED_HEIGHT;
                    sampleStats[cluster].yearSum += s.year_built;

                    // Track material and foundation types
                    if (s.material_type) {
                        if (!sampleStats[cluster].materials[s.material_type]) {
                            sampleStats[cluster].materials[s.material_type] = 0;
                        }
                        sampleStats[cluster].materials[s.material_type]++;
                    }
                    if (s.foundation_type) {
                        if (!sampleStats[cluster].foundations[s.foundation_type]) {
                            sampleStats[cluster].foundations[s.foundation_type] = 0;
                        }
                        sampleStats[cluster].foundations[s.foundation_type]++;
                    }

                    if (s.OCC_CLS) {
                        if (!sampleStats[cluster].occupancies[s.OCC_CLS]) {
                            sampleStats[cluster].occupancies[s.OCC_CLS] = 0;
                        }
                        sampleStats[cluster].occupancies[s.OCC_CLS]++;
                    }
                }
            });

            const headerColor = sampleType === 'random' ? '#fb9f3a' : '#7201a8';
            
            // MODIFICATION: Updated table headers and values for the sample statistics.
            let sampleTableHeaders = ['Cluster', 'Sample Count','Occupancy', 'Avg Footprint (m²)', 'Avg Height (m)', 'Avg Year'];
            let sampleTableValues = [
                Object.keys(sampleStats).map(c => `Cluster ${parseInt(c) + 1}`),
                Object.values(sampleStats).map(s => s.count.toLocaleString()),
                Object.values(sampleStats).map(s => {
                const occs = Object.entries(s.occupancies).sort((a, b) => b[1] - a[1]);
                return occs.length > 0 ? occs[0][0] : '-';
            }),
                Object.values(sampleStats).map(s => s.count > 0 ? Math.round(s.sqmetersSum / s.count) : 0),
                Object.values(sampleStats).map(s => s.count > 0 ? (s.heightSum / s.count).toFixed(1) : 0),
                Object.values(sampleStats).map(s => s.count > 0 ? Math.round(s.yearSum / s.count) : 0)
            ];
            
            // Add material/foundation columns if in feature combo
            if (featureCombo === 'material' || featureCombo === 'both') {
                sampleTableHeaders.push('Dom. Material');
                sampleTableValues.push(Object.values(sampleStats).map(s => {
                    const mats = Object.entries(s.materials).sort((a, b) => b[1] - a[1]);
                    return mats.length > 0 ? (materialTypeMap[mats[0][0]] || mats[0][0]) : '-';
                }));
            }
            if (featureCombo === 'foundation' || featureCombo === 'both') {
                sampleTableHeaders.push('Dom. Foundation');
                sampleTableValues.push(Object.values(sampleStats).map(s => {
                    const founds = Object.entries(s.foundations).sort((a, b) => b[1] - a[1]);
                    return founds.length > 0 ? (foundationTypeMap[founds[0][0]] || founds[0][0]) : '-';
                }));
            }
            
            const sampleTableData = [{
                type: 'table',
                header: {
                    values: sampleTableHeaders,
                    align: 'center',
                    line: {width: 1, color: '#dee2e6'},
                    fill: {color: headerColor},
                    font: {family: "Arial", size: 14, color: "white"}
                },
                cells: {
                    values: sampleTableValues,
                    align: 'center',
                    line: {color: "#dee2e6", width: 1},
                    fill: {color: ['#f8f9fa', 'white']},
                    font: {family: "Arial", size: 12, color: ["#333"]}
                }
            }];
            
            const sampleTableLayout = {
                title: {
                    text: `Sample Statistics (K=${kValue}, ${samplesForViz.length} buildings)`,
                    font: { size: 18, color: '#333' }
                },
                height: 350
            };
            
            Plotly.newPlot('occupancySampleStatsChart', sampleTableData, sampleTableLayout, {responsive: true});
        }

        function showHeatmap(type) {
            currentHeatmapType = type;
            
            document.getElementById('countHeatmapTab').classList.toggle('active', type === 'count');
            document.getElementById('areaHeatmapTab').classList.toggle('active', type === 'area');
            
            document.getElementById('countHeatmapContainer').style.display = type === 'count' ? 'block' : 'none';
            document.getElementById('areaHeatmapContainer').style.display = type === 'area' ? 'block' : 'none';
            
            if (type === 'area') {
                updateAreaHeatmap();
            }
        }
        
        function updateMaterialsHeatmap() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            window.currentMaterialsData = data;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'count');
            
            if (currentHeatmapType === 'area') {
                updateAreaHeatmap();
            }
            
            createMaterialTrendsChart(materialNames);
        }
        
        function updateHeatmapOnly() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            if (currentHeatmapType === 'count') {
                updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'count');
            } else {
                updateAreaHeatmap();
            }
        }
        
        function updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, type) {
            const isArea = type === 'area';
            const matrix = isArea ? (data.area_matrix || data.matrix) : data.matrix;
            
            let zValues = matrix;
            if (useLogScale) {
                zValues = matrix.map(row => 
                    row.map(val => val > 0 ? Math.log10(val + 1) : 0)
                );
            }
            
            const heatmapData = [{
                z: zValues,
                x: foundationNames,
                y: materialNames,
                type: 'heatmap',
                colorscale: 'Plasma',
                showscale: true,
                text: matrix.map(row => row.map(val => {
                    if (isArea) {
                        return val >= 1000000 ? `${(val/1000000).toFixed(1)}M sqm` :
                               val >= 1000 ? `${(val/1000).toFixed(1)}K sqm` :
                               `${val.toFixed(0)} sqm`;
                    } else {
                        return val.toLocaleString();
                    }
                })),
                texttemplate: '%{text}',
                textfont: {
                    size: 10,
                    color: 'white'
                },
                hovertemplate: `Material: %{y}<br>Foundation: %{x}<br>${isArea ? 'Total Area' : 'Count'}: %{text}<br><b>Click to see occupancy breakdown</b><extra></extra>`,
                colorbar: {
                    title: useLogScale ? `Log(${isArea ? 'Area' : 'Count'})` : (isArea ? 'Total Area (sqm)' : 'Count')
                }
            }];
            
            const heatmapLayout = {
                title: {
                    text: `Building ${isArea ? 'Total Est GFA' : 'Count'} - Materials vs Foundation Types ${filter !== 'all' ? '(' + filter + ')' : ''} ${useLogScale ? '(Log Scale)' : ''}`,
                    font: { size: 18, color: '#333' }
                },
                xaxis: { 
                    title: 'Foundation Type',
                    tickangle: -45,
                    tickfont: { size: 11 }
                },
                yaxis: { 
                    title: 'Material Type',
                    tickfont: { size: 11 }
                },
                height: 550,
                margin: {
                    l: 100,
                    r: 50,
                    t: 100,
                    b: 120
                }
            };
            
            const elementId = isArea ? 'materialsAreaHeatmap' : 'materialsHeatmap';
            Plotly.newPlot(elementId, heatmapData, heatmapLayout, {responsive: true});
            
            var heatmapElement = document.getElementById(elementId);
            heatmapElement.on('plotly_click', function(eventData) {
                if (!eventData || !eventData.points || eventData.points.length === 0) {
                    return;
                }
                
                const point = eventData.points[0];
                const materialIdx = point.pointIndex[0];
                const foundationIdx = point.pointIndex[1];
                
                const material = data.materials[materialIdx];
                const foundation = data.foundations[foundationIdx];
                const value = matrix[materialIdx][foundationIdx];
                
                showOccupancyBreakdown(material, foundation, value, filter, isArea);
            });
        }
        
        function updateAreaHeatmap() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'area');
        }
        
        function createMaterialTrendsChart() {
            if (!buildingData || !buildingData.building_samples_random) {
                document.getElementById('materialsTrendChart').innerHTML = '<p>Trend data not available.</p>';
                return;
            }

            const normalizeBy = document.getElementById('materialTrendNormalizeBy')?.value || 'count';

            let trendData = buildingData.building_samples_random.filter(d =>
                d.year_built && d.year_built >= 1630 && d.material_type && d['Est GFA sqmeters']
            );

            const yearData = {};
            const materialTypes = new Set();
            trendData.forEach(d => {
                const year = d.year_built;
                if (!yearData[year]) yearData[year] = {};
                if (!yearData[year][d.material_type]) yearData[year][d.material_type] = { count: 0, gfa: 0 };
                yearData[year][d.material_type].count++;
                yearData[year][d.material_type].gfa += d['Est GFA sqmeters'];
                materialTypes.add(d.material_type);
            });

            const sortedYears = Object.keys(yearData).sort((a, b) => a - b);
            const sortedMaterials = Array.from(materialTypes).sort();
            const materialColors = getPlasmaColors(sortedMaterials.length);

            const traces = sortedMaterials.map((mat, index) => {
                const yValues = sortedYears.map(year => {
                    if (yearData[year][mat]) {
                        return normalizeBy === 'gfa' ? yearData[year][mat].gfa : yearData[year][mat].count;
                    }
                    return 0;
                });
                return {
                    x: sortedYears.map(y => parseInt(y)),
                    y: yValues,
                    name: materialTypeMap[mat] || mat,
                    type: 'scatter',
                    mode: 'lines',
                    stackgroup: 'one',
                    groupnorm: 'percent',
                    fillcolor: materialColors[index],
                    line: { color: materialColors[index], width: 0.5 },
                    hovertemplate: `<b>${materialTypeMap[mat] || mat}</b><br>Year: %{x}<br>Percentage: %{y:.2f}%<extra></extra>`
                };
            });
            
            const layout = {
                title: { text: `Material Usage Trends by Year (Normalized by ${normalizeBy === 'gfa' ? 'GFA' : 'Count'})`, font: { size: 18, color: '#333' } },
                xaxis: { title: 'Year', type: 'linear', dtick: 10, tickangle: -45, range: [1630, Math.max(...sortedYears.map(y => parseInt(y))) + 1] },
                yaxis: { title: 'Percentage of New Construction (%)', ticksuffix: '%', range: [0, 100] },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: { orientation: 'v', yanchor: 'middle', y: 0.5, xanchor: 'left', x: 1.02 }
            };
            
            const chartDiv = document.getElementById('materialsTrendChart');
            Plotly.purge(chartDiv);
            Plotly.newPlot('materialsTrendChart', traces, layout, {responsive: true});
        }
        
        function showOccupancyBreakdown(material, foundation, totalValue, filter, isArea = false) {
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            const key = `${material}_${foundation}`;
            
            const breakdownData = data.occupancy_breakdown && data.occupancy_breakdown[key];
            
            if (!breakdownData) {
                console.warn(`No breakdown data for key: ${key}`);
                currentOccupancyData = {}; 
            } else {
                currentOccupancyData = isArea ? breakdownData.occupancy_areas : breakdownData.occupancy_counts;
            }
            
            currentMaterialSelection = {
                material: materialTypeMap[material] || material,
                foundation: foundationTypeMap[foundation] || foundation,
                totalValue: totalValue,
                filter: filter,
                isArea: isArea
            };
            
            document.getElementById('breakdownTitle').textContent = 
                `Occupancy Distribution: ${currentMaterialSelection.material} / ${currentMaterialSelection.foundation}`;
            
            let subtitle = isArea ? 
                `Total Est GFA: ${totalValue >= 1000000 ? (totalValue/1000000).toFixed(1) + 'M' : 
                                   totalValue >= 1000 ? (totalValue/1000).toFixed(1) + 'K' : 
                                   totalValue.toFixed(0)} sqm` :
                `Total Buildings: ${totalValue.toLocaleString()}`;
            subtitle += filter !== 'all' ? ' (' + filter + ')' : '';
            
            document.getElementById('breakdownSubtitle').textContent = subtitle;
            
            const container = document.getElementById('occupancyBreakdownContainer');
            container.style.display = 'block';
            container.style.opacity = '0';
            setTimeout(() => {
                container.style.transition = 'opacity 0.5s ease';
                container.style.opacity = '1';
            }, 10);
            
            updateOccupancyBreakdown();
            
            setTimeout(() => {
                container.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }, 100);
        }
        
        function updateOccupancyBreakdown() {
            if (!currentOccupancyData) return;
            
            const chartType = document.getElementById('breakdownChartType').value;
            const isArea = currentMaterialSelection && currentMaterialSelection.isArea;
            
            const sortedData = Object.entries(currentOccupancyData)
                .sort((a, b) => b[1] - a[1]);
            
            const labels = sortedData.map(([k, v]) => k);
            const values = sortedData.map(([k, v]) => v);
            const percentages = values.map(v => (v / values.reduce((a, b) => a + b, 0) * 100).toFixed(1));
            
            let plotData, layout;
            
            if (chartType === 'pie') {
                const total = values.reduce((a, b) => a + b, 0);

                const textArray = labels.map((label, i) => {
                    const percentage = (values[i] / total * 100);
                    
                    if (percentage > 10) {
                        return `${label}<br>${percentage.toFixed(1)}%`;
                    } else if (percentage > 5) {
                        return `${percentage.toFixed(1)}%`;
                    } else if (percentage > 2) {
                        return `${percentage.toFixed(0)}%`;
                    } else {
                        return '';
                    }
                });
                
                plotData = [{
                    values: values,
                    labels: labels,
                    type: 'pie',
                    hole: 0.4,
                    marker: {
                        colors: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: textArray,
                    textinfo: 'text',
                    textposition: 'auto',
                    textfont: {
                        size: 12,
                        color: 'white'
                    },
                    insidetextorientation: 'radial',
                    hovertemplate: `%{label}<br>${isArea ? 'Area' : 'Count'}: %{value:,}<br>Percentage: %{percent}<extra></extra>`,
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    height: 500,
                    showlegend: true,
                    legend: {
                        orientation: 'v',
                        yanchor: 'middle',
                        y: 0.5,
                        xanchor: 'left',
                        x: 1.02
                    }
                };
            } else if (chartType === 'bar') {
                plotData = [{
                    x: labels,
                    y: values,
                    type: 'bar',
                    marker: {
                        color: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: percentages.map(p => `${p}%`),
                    textposition: 'outside',
                    hovertemplate: `%{x}<br>${isArea ? 'Area' : 'Count'}: %{y:,}<br>%{text}<extra></extra>`
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    xaxis: { 
                        title: 'Occupancy Class',
                        tickangle: -45
                    },
                    yaxis: { 
                        title: isArea ? 'Total Est GFA (sqm)' : 'Number of Buildings'
                    },
                    height: 500,
                    showlegend: false
                };
            } else {
                plotData = [{
                    x: values,
                    y: labels,
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: values.map((v, i) => {
                        if (isArea) {
                            const formatted = v >= 1000000 ? `${(v/1000000).toFixed(1)}M sqm` :
                                            v >= 1000 ? `${(v/1000).toFixed(1)}K sqm` :
                                            `${v.toFixed(0)} sqm`;
                            return `${formatted} (${percentages[i]}%)`;
                        } else {
                            return `${v.toLocaleString()} (${percentages[i]}%)`;
                        }
                    }),
                    textposition: 'outside',
                    hovertemplate: `%{y}<br>${isArea ? 'Area' : 'Count'}: %{x:,}<br>%{text}<extra></extra>`
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    xaxis: { 
                        title: isArea ? 'Total Est GFA (sqm)' : 'Number of Buildings'
                    },
                    yaxis: { 
                        title: 'Occupancy Class'
                    },
                    height: Math.max(400, labels.length * 40),
                    margin: {
                        l: 150
                    },
                    showlegend: false
                };
            }
            
            Plotly.newPlot('occupancyBreakdownChart', plotData, layout, {responsive: true});
        }


    function updateInteractiveExplorer() {
            if (!buildingData) return;
            
            const vizType = document.getElementById('vizType').value;
            const yearStart = parseInt(document.getElementById('yearStart').value);
            const yearEnd = parseInt(document.getElementById('yearEnd').value);
            const areaMin = parseInt(document.getElementById('areaMin').value);
            const areaMax = parseInt(document.getElementById('areaMax').value);
            
            const filteredData = buildingData.building_samples_random.filter(d => 
                d.year_built >= yearStart && d.year_built <= yearEnd &&
                d['Est GFA sqmeters'] >= areaMin && 
                d['Est GFA sqmeters'] <= areaMax
            );
            
            let plotData, layout;
            
            switch(vizType) {
                case 'scatter3d':
                    plotData = [{
                        x: filteredData.map(d => d.year_built),
                        y: filteredData.map(d => d['Est GFA sqmeters']),
                        z: filteredData.map(d => d.cluster),
                        mode: 'markers',
                        type: 'scatter3d',
                        marker: {
                            size: 5,
                            color: filteredData.map(d => d.cluster),
                            colorscale: 'Plasma',
                            showscale: true
                        },
                        text: filteredData.map(d => d.OCC_CLS),
                        hovertemplate: 'Year: %{x}<br>Est GFA: %{y:.1f} sqm<br>Cluster: %{z}<br>Type: %{text}<extra></extra>'
                    }];
                    layout = {
                        title: '3D Building Data Visualization',
                        scene: {
                            xaxis: { title: 'Year Built' },
                            yaxis: { title: 'Est GFA (sqm)' },
                            zaxis: { title: 'Cluster' }
                        },
                        height: 600
                    };
                    break;
                case 'sunburst':
                    // ... (Sunburst logic is correct and does not use GFA directly)
                    const sunburstLabels = ['Buildings'];
                    const sunburstParents = [''];
                    const sunburstValues = [filteredData.length];
                    const occupancyGroups = {};
                    filteredData.forEach(d => {
                        if (!occupancyGroups[d.OCC_CLS]) occupancyGroups[d.OCC_CLS] = {};
                        const decade = d.year_built < 1940 ? 'pre-1940' : `${Math.floor(d.year_built / 10) * 10}s`;
                        if (!occupancyGroups[d.OCC_CLS][decade]) occupancyGroups[d.OCC_CLS][decade] = 0;
                        occupancyGroups[d.OCC_CLS][decade]++;
                    });
                    Object.keys(occupancyGroups).forEach(occ => {
                        sunburstLabels.push(occ);
                        sunburstParents.push('Buildings');
                        sunburstValues.push(Object.values(occupancyGroups[occ]).reduce((a, b) => a + b, 0));
                        Object.keys(occupancyGroups[occ]).forEach(decade => {
                            sunburstLabels.push(`${occ} - ${decade}`);
                            sunburstParents.push(occ);
                            sunburstValues.push(occupancyGroups[occ][decade]);
                        });
                    });
                    plotData = [{
                        type: 'sunburst',
                        labels: sunburstLabels,
                        parents: sunburstParents,
                        values: sunburstValues,
                        branchvalues: 'total',
                        marker: { colorscale: 'Plasma' }
                    }];
                    layout = { title: 'Hierarchical Building Distribution', height: 600 };
                    break;
                case 'parallel':
                    plotData = [{
                        type: 'parcoords',
                        dimensions: [
                            { label: 'Year', values: filteredData.map(d => d.year_built), range: [yearStart, yearEnd] },
                            { label: 'Est GFA', values: filteredData.map(d => d['Est GFA sqmeters']), range: [areaMin, areaMax] },
                            { label: 'Cluster', values: filteredData.map(d => d.cluster), range: [0, 6] }
                        ],
                        line: { color: filteredData.map(d => d.cluster), colorscale: 'Plasma', showscale: true }
                    }];
                    layout = { title: 'Parallel Coordinates - Building Attributes', height: 600 };
                    break;
                case 'box':
                    const occupancies = [...new Set(filteredData.map(d => d.OCC_CLS))];
                    plotData = occupancies.map((occ, i) => ({
                        y: filteredData.filter(d => d.OCC_CLS === occ).map(d => d['Est GFA sqmeters']),
                        type: 'box',
                        name: occ,
                        boxpoints: 'outliers',
                        marker: { color: plasmaColors[i % plasmaColors.length] }
                    }));
                    layout = { title: 'Est GFA Distribution by Occupancy Class', yaxis: { title: 'Est GFA (sqm)' }, height: 500 };
                    break;
                case 'violin':
                    const violinOccupancies = [...new Set(filteredData.map(d => d.OCC_CLS))];
                    plotData = violinOccupancies.map((occ, index) => ({
                        y: filteredData.filter(d => d.OCC_CLS === occ).map(d => d['Est GFA sqmeters']),
                        type: 'violin',
                        name: occ,
                        box: { visible: true },
                        meanline: { visible: true },
                        fillcolor: plasmaColors[index % plasmaColors.length],
                        opacity: 0.6
                    }));
                    layout = { title: 'Est GFA Distribution (Violin Plot)', yaxis: { title: 'Est GFA (sqm)' }, height: 500 };
                    break;
                case 'treemap':
                    const treemapLabels = ['Root'];
                    const treemapParents = [''];
                    const treemapValues = [0];
                    const treemapData = {};
                    filteredData.forEach(d => {
                        if (!treemapData[d.OCC_CLS]) treemapData[d.OCC_CLS] = 0;
                        treemapData[d.OCC_CLS]++;
                    });
                    Object.entries(treemapData).forEach(([occ, count]) => {
                        treemapLabels.push(occ);
                        treemapParents.push('Root');
                        treemapValues.push(count);
                    });
                    plotData = [{
                        type: 'treemap',
                        labels: treemapLabels,
                        parents: treemapParents,
                        values: treemapValues,
                        textinfo: "label+value+percent root",
                        marker: { colorscale: 'Plasma' }
                    }];
                    layout = { title: 'Building Distribution Treemap', height: 600 };
                    break;
            }
            Plotly.newPlot('interactiveChart', plotData, layout, {responsive: true});
        }
        
        function exportChart(chartId, filename) {
            Plotly.downloadImage(chartId, {
                format: 'png',
                width: 1200,
                height: 800,
                filename: filename || 'chart'
            });
        }
        
        function exportAllData() {
            if (!buildingData) {
                alert('No data available to export');
                return;
            }
            
            const dataStr = JSON.stringify(buildingData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'building_analysis_data.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function createMixScPieChart() {
            if (!buildingData || !buildingData.mix_sc_distribution) {
                document.getElementById('mixScPieChart').innerHTML = '<p>MIX_SC distribution data not available.</p>';
                return;
            }

            const includeSameType = document.getElementById('toggleSameType').checked;
            let fullData = { ...buildingData.mix_sc_distribution };

            let labels = Object.keys(fullData);
            let values = Object.values(fullData);

            if (!includeSameType) {
                const sameTypeIndex = labels.indexOf('Same Type Only');
                if (sameTypeIndex > -1) {
                    labels.splice(sameTypeIndex, 1);
                    values.splice(sameTypeIndex, 1);
                }
            }

            if (labels.length === 0) {
                document.getElementById('mixScPieChart').innerHTML = '<p>No data to display for the current selection.</p>';
                return;
            }
            
            // Assign specific, consistent colors for better readability
            const colorMap = {
                'Same Type Only': '#2E7D32', // Green for homogeneity
                'Same & Different Types (MIX_SC2)': '#FDD835', // Yellow for some conflict
                '1 Conflict Type (MIX_SC1)': '#FF9800', // Orange for more conflict
                '>1 Conflict Types (MIX_SC3)': '#E53935' // Red for high conflict
            };
            const pieColors = labels.map(label => colorMap[label] || '#999');


            const pieData = [{
                values: values,
                labels: labels,
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: pieColors,
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                textinfo: 'percent',
                textposition: 'inside',
                insidetextorientation: 'radial',
                hovertemplate: '<b>%{label}</b><br>Building Count: %{value:,}<br>%{percent}<extra></extra>'
            }];

            const layout = {
                title: {
                    text: 'Building Homogeneity Distribution',
                    font: { size: 20, color: '#333' }
                },
                height: 500,
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.05
                }
            };

            Plotly.newPlot('mixScPieChart', pieData, layout, { responsive: true });
        }

        function getYearOccSankeyTitle() {
        const dims = ["Construction Year", "Occupancy"];
        if (document.getElementById("toggleMaterial")?.checked)   dims.push("Material");
        if (document.getElementById("toggleFoundation")?.checked) dims.push("Foundation");
        if (document.getElementById("toggleSoil")?.checked)       dims.push("Soil");
        return dims.join(" \u2192 "); 
        }


        function updateYearOccSankeyTitle() {
        const el = document.getElementById("yearOccSankeyTitle");
        if (el) el.textContent = getYearOccSankeyTitle();
        }


        function handleYearOccToggleChange() {
        updateYearOccSankeyTitle();
        if (typeof createYearOccSankey === "function") createYearOccSankey();
        }


        document.addEventListener("DOMContentLoaded", updateYearOccSankeyTitle);


        (function patchCreateYearOcc() {
        const orig = window.createYearOccSankey;
        if (typeof orig === "function") {
            window.createYearOccSankey = function() {
            const r = orig.apply(this, arguments);
            try { updateYearOccSankeyTitle(); } catch(e) {}
            return r;
            }
        }
        })();
                
        function _ts() {
            const d = new Date();
            const z = n => String(n).padStart(2, '0');
            return `${d.getFullYear()}${z(d.getMonth()+1)}${z(d.getDate())}_${z(d.getHours())}${z(d.getMinutes())}${z(d.getSeconds())}`;
        }

       
        async function downloadYearOccSankey() {
            const gd = document.getElementById('yearOccSankey'); 
            if (!gd) { alert('Plot not found'); return; }

        
            const format = document.getElementById('yearOccExportFormat')?.value || 'png';
            const scale  = parseInt(document.getElementById('yearOccExportScale')?.value || '3', 10);
            const transparent = !!document.getElementById('yearOccTransparentBg')?.checked;

          
            const rect   = gd.getBoundingClientRect();
            const width  = Math.max(800, Math.round(rect.width));
            const height = (gd._fullLayout && gd._fullLayout.height) ? gd._fullLayout.height
                        : Math.max(560, Math.round(rect.height) || 560);

          
            const prevPaper = (gd.layout && gd.layout.paper_bgcolor) ?? null;
            const prevPlot  = (gd.layout && gd.layout.plot_bgcolor)  ?? null;
            const paper = transparent ? 'rgba(0,0,0,0)' : 'white';
            const plot  = transparent ? 'rgba(0,0,0,0)' : 'white';

            try {
            await Plotly.relayout(gd, { 'paper_bgcolor': paper, 'plot_bgcolor': plot });

           
            const opts = {
                format,
                filename: `sankey_year_occ_${_ts()}`,
                width:  (format === 'svg') ? width  : width  * scale,
                height: (format === 'svg') ? height : height * scale,
                scale:  1 
            };

            await Plotly.downloadImage(gd, opts);
            } catch (err) {
            console.error(err);
            alert('Export failed. See console for details.');
            } finally {

            await Plotly.relayout(gd, { 'paper_bgcolor': prevPaper, 'plot_bgcolor': prevPlot });
            }
        }

    </script>
</body>
</html>